! function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("mdb", [], e) : "object" == typeof exports ? exports.mdb = e() : t.mdb = e()
}(this, function() {
    return i = [function(t, e, i) {
        "use strict";
        var n = i(29),
            s = i(102),
            o = i(27),
            a = i(15),
            i = i(70),
            r = "Array Iterator",
            l = a.set,
            c = a.getterFor(r);
        t.exports = i(Array, "Array", function(t, e) {
            l(this, {
                type: r,
                target: n(t),
                index: 0,
                kind: e
            })
        }, function() {
            var t = c(this),
                e = t.target,
                i = t.kind,
                n = t.index++;
            return !e || n >= e.length ? {
                value: t.target = void 0,
                done: !0
            } : "keys" == i ? {
                value: n,
                done: !1
            } : "values" == i ? {
                value: e[n],
                done: !1
            } : {
                value: [n, e[n]],
                done: !1
            }
        }, "values"), o.Arguments = o.Array, s("keys"), s("values"), s("entries")
    }, function(t, e, i) {
        var n, s = i(3),
            o = i(104),
            a = i(0),
            r = i(11),
            i = i(5),
            l = i("iterator"),
            c = i("toStringTag"),
            h = a.values;
        for (n in o) {
            var d = s[n],
                u = d && d.prototype;
            if (u) {
                if (u[l] !== h) try {
                    r(u, l, h)
                } catch (t) {
                    u[l] = h
                }
                if (u[c] || r(u, c, n), o[n])
                    for (var p in a)
                        if (u[p] !== a[p]) try {
                            r(u, p, a[p])
                        } catch (t) {
                            u[p] = a[p]
                        }
            }
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(9),
            i = i(48);
        n({
            target: "RegExp",
            proto: !0,
            forced: /./.exec !== i
        }, {
            exec: i
        })
    }, function(i, t, e) {
        ! function(t) {
            function e(t) {
                return t && t.Math == Math && t
            }
            i.exports = e("object" == typeof globalThis && globalThis) || e("object" == typeof window && window) || e("object" == typeof self && self) || e("object" == typeof t && t) || function() {
                return this
            }() || Function("return this")()
        }.call(this, e(85))
    }, function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    }, function(t, e, i) {
        var n = i(3),
            s = i(44),
            o = i(7),
            a = i(56),
            r = i(68),
            i = i(97),
            l = s("wks"),
            c = n.Symbol,
            h = i ? c : c && c.withoutSetter || a;
        t.exports = function(t) {
            return o(l, t) && (r || "string" == typeof l[t]) || (r && o(c, t) ? l[t] = c[t] : l[t] = h("Symbol." + t)), l[t]
        }
    }, function(t, e, i) {
        var n = i(8);
        t.exports = function(t) {
            if (!n(t)) throw TypeError(String(t) + " is not an object");
            return t
        }
    }, function(t, e, i) {
        var n = i(16),
            s = {}.hasOwnProperty;
        t.exports = Object.hasOwn || function(t, e) {
            return s.call(n(t), e)
        }
    }, function(t, e) {
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
    }, function(t, e, i) {
        var c = i(3),
            h = i(36).f,
            d = i(11),
            u = i(14),
            p = i(40),
            f = i(87),
            g = i(47);
        t.exports = function(t, e) {
            var i, n, s, o = t.target,
                a = t.global,
                r = t.stat,
                l = a ? c : r ? c[o] || p(o, {}) : (c[o] || {}).prototype;
            if (l)
                for (i in e) {
                    if (n = e[i], s = t.noTargetGet ? (s = h(l, i)) && s.value : l[i], !g(a ? i : o + (r ? "." : "#") + i, t.forced) && void 0 !== s) {
                        if (typeof n == typeof s) continue;
                        f(n, s)
                    }(t.sham || s && s.sham) && d(n, "sham", !0), u(l, i, n, t)
                }
        }
    }, function(t, e, i) {
        i = i(4);
        t.exports = !i(function() {
            return 7 != Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        })
    }, function(t, e, i) {
        var n = i(10),
            s = i(13),
            o = i(23);
        t.exports = n ? function(t, e, i) {
            return s.f(t, e, o(1, i))
        } : function(t, e, i) {
            return t[e] = i, t
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(98),
            s = i(4),
            C = i(6),
            k = i(19),
            T = i(30),
            o = i(25),
            S = i(99),
            E = i(100),
            A = i(101),
            a = i(5)("replace"),
            M = Math.max,
            O = Math.min,
            i = "$0" === "a".replace(/./, "$0"),
            r = !!/./ [a] && "" === /./ [a]("a", "$0");
        n("replace", function(t, y, x) {
            var w = r ? "$" : "$0";
            return [function(t, e) {
                var i = o(this),
                    n = null == t ? void 0 : t[a];
                return void 0 !== n ? n.call(t, i, e) : y.call(String(i), t, e)
            }, function(t, e) {
                if ("string" == typeof e && -1 === e.indexOf(w) && -1 === e.indexOf("$<")) {
                    var i = x(y, this, t, e);
                    if (i.done) return i.value
                }
                var n = C(this),
                    s = String(t),
                    o = "function" == typeof e;
                o || (e = String(e));
                var a, r = n.global;
                r && (a = n.unicode, n.lastIndex = 0);
                for (var l = [];;) {
                    if (null === (p = A(n, s))) break;
                    if (l.push(p), !r) break;
                    "" === String(p[0]) && (n.lastIndex = S(s, k(n.lastIndex), a))
                }
                for (var c, h = "", d = 0, u = 0; u < l.length; u++) {
                    for (var p = l[u], f = String(p[0]), g = M(O(T(p.index), s.length), 0), _ = [], m = 1; m < p.length; m++) _.push(void 0 === (c = p[m]) ? c : String(c));
                    var v, b = p.groups,
                        b = o ? (v = [f].concat(_, g, s), void 0 !== b && v.push(b), String(e.apply(void 0, v))) : E(f, s, g, _, b, e);
                    d <= g && (h += s.slice(d, g) + b, d = g + f.length)
                }
                return h + s.slice(d)
            }]
        }, !!s(function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                }, t
            }, "7" !== "".replace(t, "$<a>")
        }) || !i || r)
    }, function(t, e, i) {
        var n = i(10),
            s = i(55),
            o = i(6),
            a = i(38),
            r = Object.defineProperty;
        e.f = n ? r : function(t, e, i) {
            if (o(t), e = a(e, !0), o(i), s) try {
                return r(t, e, i)
            } catch (t) {}
            if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
            return "value" in i && (t[e] = i.value), t
        }
    }, function(t, e, i) {
        var r = i(3),
            l = i(11),
            c = i(7),
            h = i(40),
            n = i(41),
            i = i(15),
            s = i.get,
            d = i.enforce,
            u = String(String).split("String");
        (t.exports = function(t, e, i, n) {
            var s = !!n && !!n.unsafe,
                o = !!n && !!n.enumerable,
                a = !!n && !!n.noTargetGet;
            "function" == typeof i && ("string" != typeof e || c(i, "name") || l(i, "name", e), (n = d(i)).source || (n.source = u.join("string" == typeof e ? e : ""))), t !== r ? (s ? !a && t[e] && (o = !0) : delete t[e], o ? t[e] = i : l(t, e, i)) : o ? t[e] = i : h(e, i)
        })(Function.prototype, "toString", function() {
            return "function" == typeof this && s(this).source || n(this)
        })
    }, function(t, e, i) {
        var n, s, o, a, r, l, c, h, d = i(86),
            u = i(3),
            p = i(8),
            f = i(11),
            g = i(7),
            _ = i(42),
            m = i(43),
            i = i(45),
            v = "Object already initialized",
            u = u.WeakMap;
        c = d || _.state ? (n = _.state || (_.state = new u), s = n.get, o = n.has, a = n.set, r = function(t, e) {
            if (o.call(n, t)) throw new TypeError(v);
            return e.facade = t, a.call(n, t, e), e
        }, l = function(t) {
            return s.call(n, t) || {}
        }, function(t) {
            return o.call(n, t)
        }) : (i[h = m("state")] = !0, r = function(t, e) {
            if (g(t, h)) throw new TypeError(v);
            return e.facade = t, f(t, h, e), e
        }, l = function(t) {
            return g(t, h) ? t[h] : {}
        }, function(t) {
            return g(t, h)
        }), t.exports = {
            set: r,
            get: l,
            has: c,
            enforce: function(t) {
                return c(t) ? l(t) : r(t, {})
            },
            getterFor: function(i) {
                return function(t) {
                    var e;
                    if (!p(t) || (e = l(t)).type !== i) throw TypeError("Incompatible receiver, " + i + " required");
                    return e
                }
            }
        }
    }, function(t, e, i) {
        var n = i(25);
        t.exports = function(t) {
            return Object(n(t))
        }
    }, function(t, e, i) {
        var n = i(10),
            s = i(3),
            o = i(47),
            c = i(94),
            h = i(11),
            a = i(13).f,
            r = i(57).f,
            d = i(96),
            u = i(60),
            l = i(61),
            p = i(14),
            f = i(4),
            g = i(7),
            _ = i(15).enforce,
            m = i(69),
            v = i(5),
            b = i(65),
            y = i(66),
            x = v("match"),
            w = s.RegExp,
            C = w.prototype,
            k = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,
            T = /a/g,
            S = /a/g,
            v = new w(T) !== T,
            E = l.UNSUPPORTED_Y,
            f = n && (!v || E || b || y || f(function() {
                return S[x] = !1, w(T) != T || w(S) == S || "/a/i" != w(T, "i")
            })),
            A = function(t) {
                for (var e, i = t.length, n = 0, s = "", o = !1; n <= i; n++) "\\" !== (e = t.charAt(n)) ? o || "." !== e ? ("[" === e ? o = !0 : "]" === e && (o = !1), s += e) : s += "[\\s\\S]" : s += e + t.charAt(++n);
                return s
            },
            M = function(t) {
                for (var e, i = t.length, n = 0, s = "", o = [], a = {}, r = !1, l = !1, c = 0, h = ""; n <= i; n++) {
                    if ("\\" === (e = t.charAt(n))) e += t.charAt(++n);
                    else if ("]" === e) r = !1;
                    else if (!r) switch (!0) {
                        case "[" === e:
                            r = !0;
                            break;
                        case "(" === e:
                            k.test(t.slice(n + 1)) && (n += 2, l = !0), s += e, c++;
                            continue;
                        case ">" === e && l:
                            if ("" === h || g(a, h)) throw new SyntaxError("Invalid capture group name");
                            a[h] = !0, o.push([h, c]), l = !1, h = "";
                            continue
                    }
                    l ? h += e : s += e
                }
                return [s, o]
            };
        if (o("RegExp", f)) {
            for (var O = function(t, e) {
                    var i, n, s = this instanceof O,
                        o = d(t),
                        a = void 0 === e,
                        r = [],
                        l = t;
                    if (!s && o && a && t.constructor === O) return t;
                    if ((o || t instanceof O) && (t = t.source, a && (e = "flags" in l ? l.flags : u.call(l))), t = void 0 === t ? "" : String(t), e = void 0 === e ? "" : String(e), l = t, o = e = b && "dotAll" in T && (i = !!e && -1 < e.indexOf("s")) ? e.replace(/s/g, "") : e, E && "sticky" in T && (n = !!e && -1 < e.indexOf("y")) && (e = e.replace(/y/g, "")), y && (t = (a = M(t))[0], r = a[1]), e = c(w(t, e), s ? this : C, O), (i || n || r.length) && (s = _(e), i && (s.dotAll = !0, s.raw = O(A(t), o)), n && (s.sticky = !0), r.length && (s.groups = r)), t !== l) try {
                        h(e, "source", "" === l ? "(?:)" : l)
                    } catch (t) {}
                    return e
                }, I = r(w), D = 0; I.length > D;) ! function(e) {
                e in O || a(O, e, {
                    configurable: !0,
                    get: function() {
                        return w[e]
                    },
                    set: function(t) {
                        w[e] = t
                    }
                })
            }(I[D++]);
            (C.constructor = O).prototype = C, p(s, "RegExp", O)
        }
        m("RegExp")
    }, function(t, e, i) {
        function n(t) {
            return "function" == typeof t ? t : void 0
        }
        var s = i(89),
            o = i(3);
        t.exports = function(t, e) {
            return arguments.length < 2 ? n(s[t]) || n(o[t]) : s[t] && s[t][e] || o[t] && o[t][e]
        }
    }, function(t, e, i) {
        var n = i(30),
            s = Math.min;
        t.exports = function(t) {
            return 0 < t ? s(n(t), 9007199254740991) : 0
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(9),
            s = i(92).trim;
        n({
            target: "String",
            proto: !0,
            forced: i(93)("trim")
        }, {
            trim: function() {
                return s(this)
            }
        })
    }, function(t, e, i) {
        i = i(18);
        t.exports = i("navigator", "userAgent") || ""
    }, function(t, e) {
        t.exports = function(t) {
            if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
            return t
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    }, function(t, e) {
        var i = {}.toString;
        t.exports = function(t) {
            return i.call(t).slice(8, -1)
        }
    }, function(t, e) {
        t.exports = function(t) {
            if (null == t) throw TypeError("Can't call method on " + t);
            return t
        }
    }, function(t, e) {
        t.exports = !1
    }, function(t, e) {
        t.exports = {}
    }, function(t, e, i) {
        var n = i(13).f,
            s = i(7),
            o = i(5)("toStringTag");
        t.exports = function(t, e, i) {
            t && !s(t = i ? t : t.prototype, o) && n(t, o, {
                configurable: !0,
                value: e
            })
        }
    }, function(t, e, i) {
        var n = i(37),
            s = i(25);
        t.exports = function(t) {
            return n(s(t))
        }
    }, function(t, e) {
        var i = Math.ceil,
            n = Math.floor;
        t.exports = function(t) {
            return isNaN(t = +t) ? 0 : (0 < t ? n : i)(t)
        }
    }, function(t, e, i) {
        function n() {}
        var s, o = i(6),
            a = i(62),
            r = i(46),
            l = i(45),
            c = i(64),
            h = i(39),
            i = i(43),
            d = "prototype",
            u = "script",
            p = i("IE_PROTO"),
            f = function(t) {
                return "<" + u + ">" + t + "</" + u + ">"
            },
            g = function() {
                try {
                    s = document.domain && new ActiveXObject("htmlfile")
                } catch (t) {}
                var t, e;
                g = s ? function(t) {
                    t.write(f("")), t.close();
                    var e = t.parentWindow.Object;
                    return t = null, e
                }(s) : (t = h("iframe"), e = "java" + u + ":", t.style.display = "none", c.appendChild(t), t.src = String(e), (t = t.contentWindow.document).open(), t.write(f("document.F=Object")), t.close(), t.F);
                for (var i = r.length; i--;) delete g[d][r[i]];
                return g()
            };
        l[p] = !0, t.exports = Object.create || function(t, e) {
            var i;
            return null !== t ? (n[d] = o(t), i = new n, n[d] = null, i[p] = t) : i = g(), void 0 === e ? i : a(i, e)
        }
    }, function(t, e, i) {
        var n, s, o = i(3),
            i = i(21),
            o = o.process,
            o = o && o.versions,
            o = o && o.v8;
        o ? s = (n = o.split("."))[0] < 4 ? 1 : n[0] + n[1] : i && (!(n = i.match(/Edge\/(\d+)/)) || 74 <= n[1]) && (n = i.match(/Chrome\/(\d+)/)) && (s = n[1]), t.exports = s && +s
    }, function(t, e, i) {
        var o = i(22);
        t.exports = function(n, s, t) {
            if (o(n), void 0 === s) return n;
            switch (t) {
                case 0:
                    return function() {
                        return n.call(s)
                    };
                case 1:
                    return function(t) {
                        return n.call(s, t)
                    };
                case 2:
                    return function(t, e) {
                        return n.call(s, t, e)
                    };
                case 3:
                    return function(t, e, i) {
                        return n.call(s, t, e, i)
                    }
            }
            return function() {
                return n.apply(s, arguments)
            }
        }
    }, function(t, e, i) {
        var n = i(77),
            s = i(27),
            o = i(5)("iterator");
        t.exports = function(t) {
            if (null != t) return t[o] || t["@@iterator"] || s[n(t)]
        }
    }, function(t, e, i) {
        var n = i(24),
            i = i(3);
        t.exports = "process" == n(i.process)
    }, function(t, e, i) {
        var n = i(10),
            s = i(54),
            o = i(23),
            a = i(29),
            r = i(38),
            l = i(7),
            c = i(55),
            h = Object.getOwnPropertyDescriptor;
        e.f = n ? h : function(t, e) {
            if (t = a(t), e = r(e, !0), c) try {
                return h(t, e)
            } catch (t) {}
            if (l(t, e)) return o(!s.f.call(t, e), t[e])
        }
    }, function(t, e, i) {
        var n = i(4),
            s = i(24),
            o = "".split;
        t.exports = n(function() {
            return !Object("z").propertyIsEnumerable(0)
        }) ? function(t) {
            return "String" == s(t) ? o.call(t, "") : Object(t)
        } : Object
    }, function(t, e, i) {
        var s = i(8);
        t.exports = function(t, e) {
            if (!s(t)) return t;
            var i, n;
            if (e && "function" == typeof(i = t.toString) && !s(n = i.call(t))) return n;
            if ("function" == typeof(i = t.valueOf) && !s(n = i.call(t))) return n;
            if (!e && "function" == typeof(i = t.toString) && !s(n = i.call(t))) return n;
            throw TypeError("Can't convert object to primitive value")
        }
    }, function(t, e, i) {
        var n = i(3),
            i = i(8),
            s = n.document,
            o = i(s) && i(s.createElement);
        t.exports = function(t) {
            return o ? s.createElement(t) : {}
        }
    }, function(t, e, i) {
        var n = i(3),
            s = i(11);
        t.exports = function(e, i) {
            try {
                s(n, e, i)
            } catch (t) {
                n[e] = i
            }
            return i
        }
    }, function(t, e, i) {
        var i = i(42),
            n = Function.toString;
        "function" != typeof i.inspectSource && (i.inspectSource = function(t) {
            return n.call(t)
        }), t.exports = i.inspectSource
    }, function(t, e, i) {
        var n = i(3),
            s = i(40),
            i = "__core-js_shared__",
            i = n[i] || s(i, {});
        t.exports = i
    }, function(t, e, i) {
        var n = i(44),
            s = i(56),
            o = n("keys");
        t.exports = function(t) {
            return o[t] || (o[t] = s(t))
        }
    }, function(t, e, i) {
        var n = i(26),
            s = i(42);
        (t.exports = function(t, e) {
            return s[t] || (s[t] = void 0 !== e ? e : {})
        })("versions", []).push({
            version: "3.15.2",
            mode: n ? "pure" : "global",
            copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
        })
    }, function(t, e) {
        t.exports = {}
    }, function(t, e) {
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    }, function(t, e, i) {
        var n = i(4),
            s = /#|\.prototype\./,
            i = function(t, e) {
                t = a[o(t)];
                return t == l || t != r && ("function" == typeof e ? n(e) : !!e)
            },
            o = i.normalize = function(t) {
                return String(t).replace(s, ".").toLowerCase()
            },
            a = i.data = {},
            r = i.NATIVE = "N",
            l = i.POLYFILL = "P";
        t.exports = i
    }, function(t, e, i) {
        "use strict";
        var f = i(60),
            n = i(61),
            s = i(44),
            g = i(31),
            _ = i(15).get,
            o = i(65),
            a = i(66),
            m = RegExp.prototype.exec,
            v = s("native-string-replace", String.prototype.replace),
            b = m,
            y = (i = /a/, s = /b*/g, m.call(i, "a"), m.call(s, "a"), 0 !== i.lastIndex || 0 !== s.lastIndex),
            x = n.UNSUPPORTED_Y || n.BROKEN_CARET,
            w = void 0 !== /()??/.exec("")[1];
        (y || w || x || o || a) && (b = function(t) {
            var e, i, n, s, o, a, r = this,
                l = _(r),
                c = l.raw;
            if (c) return c.lastIndex = r.lastIndex, p = b.call(c, t), r.lastIndex = c.lastIndex, p;
            var h = l.groups,
                d = x && r.sticky,
                u = f.call(r),
                c = r.source,
                p = 0,
                l = t;
            if (d && (-1 === (u = u.replace("y", "")).indexOf("g") && (u += "g"), l = String(t).slice(r.lastIndex), 0 < r.lastIndex && (!r.multiline || r.multiline && "\n" !== t[r.lastIndex - 1]) && (c = "(?: " + c + ")", l = " " + l, p++), e = new RegExp("^(?:" + c + ")", u)), w && (e = new RegExp("^" + c + "$(?!\\s)", u)), y && (i = r.lastIndex), n = m.call(d ? e : r, l), d ? n ? (n.input = n.input.slice(p), n[0] = n[0].slice(p), n.index = r.lastIndex, r.lastIndex += n[0].length) : r.lastIndex = 0 : y && n && (r.lastIndex = r.global ? n.index + n[0].length : i), w && n && 1 < n.length && v.call(n[0], e, function() {
                    for (s = 1; s < arguments.length - 2; s++) void 0 === arguments[s] && (n[s] = void 0)
                }), n && h)
                for (n.groups = o = g(null), s = 0; s < h.length; s++) o[(a = h[s])[0]] = n[a[1]];
            return n
        }), t.exports = b
    }, function(t, e, i) {
        var s = i(6),
            o = i(95);
        t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var i, n = !1,
                t = {};
            try {
                (i = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(t, []), n = t instanceof Array
            } catch (t) {}
            return function(t, e) {
                return s(t), o(e), n ? i.call(t, e) : t.__proto__ = e, t
            }
        }() : void 0)
    }, function(t, e, i) {
        var a = i(30),
            r = i(25),
            i = function(o) {
                return function(t, e) {
                    var i, n = String(r(t)),
                        s = a(e),
                        t = n.length;
                    return s < 0 || t <= s ? o ? "" : void 0 : (e = n.charCodeAt(s)) < 55296 || 56319 < e || s + 1 === t || (i = n.charCodeAt(s + 1)) < 56320 || 57343 < i ? o ? n.charAt(s) : e : o ? n.slice(s, s + 2) : i - 56320 + (e - 55296 << 10) + 65536
                }
            };
        t.exports = {
            codeAt: i(!1),
            charAt: i(!0)
        }
    }, function(t, e) {
        t.exports = function(t, e, i) {
            if (!(t instanceof e)) throw TypeError("Incorrect " + (i ? i + " " : "") + "invocation");
            return t
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(9),
            s = i(127).left,
            o = i(84),
            a = i(32),
            i = i(35);
        n({
            target: "Array",
            proto: !0,
            forced: !o("reduce") || !i && 79 < a && a < 83
        }, {
            reduce: function(t) {
                return s(this, t, arguments.length, 1 < arguments.length ? arguments[1] : void 0)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(9),
            r = i(22),
            l = i(16),
            c = i(19),
            s = i(4),
            h = i(128),
            o = i(84),
            a = i(129),
            d = i(130),
            u = i(32),
            p = i(131),
            f = [],
            g = f.sort,
            _ = s(function() {
                f.sort(void 0)
            }),
            i = s(function() {
                f.sort(null)
            }),
            o = o("sort"),
            m = !s(function() {
                if (u) return u < 70;
                if (!(a && 3 < a)) {
                    if (d) return !0;
                    if (p) return p < 603;
                    for (var t, e, i, n = "", s = 65; s < 76; s++) {
                        switch (t = String.fromCharCode(s), s) {
                            case 66:
                            case 69:
                            case 70:
                            case 72:
                                e = 3;
                                break;
                            case 68:
                            case 71:
                                e = 4;
                                break;
                            default:
                                e = 2
                        }
                        for (i = 0; i < 47; i++) f.push({
                            k: t + i,
                            v: e
                        })
                    }
                    for (f.sort(function(t, e) {
                            return e.v - t.v
                        }), i = 0; i < f.length; i++) t = f[i].k.charAt(0), n.charAt(n.length - 1) !== t && (n += t);
                    return "DGBEFHACIJK" !== n
                }
            });
        n({
            target: "Array",
            proto: !0,
            forced: _ || !i || !o || !m
        }, {
            sort: function(t) {
                void 0 !== t && r(t);
                var e = l(this);
                if (m) return void 0 === t ? g.call(e) : g.call(e, t);
                for (var i, n, s = [], o = c(e.length), a = 0; a < o; a++) a in e && s.push(e[a]);
                for (i = (s = h(s, (n = t, function(t, e) {
                        return void 0 === e ? -1 : void 0 === t ? 1 : void 0 !== n ? +n(t, e) || 0 : String(t) > String(e) ? 1 : -1
                    }))).length, a = 0; a < i;) e[a] = s[a++];
                for (; a < o;) delete e[a++];
                return e
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = {}.propertyIsEnumerable,
            s = Object.getOwnPropertyDescriptor,
            o = s && !n.call({
                1: 2
            }, 1);
        e.f = o ? function(t) {
            t = s(this, t);
            return !!t && t.enumerable
        } : n
    }, function(t, e, i) {
        var n = i(10),
            s = i(4),
            o = i(39);
        t.exports = !n && !s(function() {
            return 7 != Object.defineProperty(o("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }, function(t, e) {
        var i = 0,
            n = Math.random();
        t.exports = function(t) {
            return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++i + n).toString(36)
        }
    }, function(t, e, i) {
        var n = i(58),
            s = i(46).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, s)
        }
    }, function(t, e, i) {
        var a = i(7),
            r = i(29),
            l = i(90).indexOf,
            c = i(45);
        t.exports = function(t, e) {
            var i, n = r(t),
                s = 0,
                o = [];
            for (i in n) !a(c, i) && a(n, i) && o.push(i);
            for (; e.length > s;) a(n, i = e[s++]) && (~l(o, i) || o.push(i));
            return o
        }
    }, function(t, e) {
        e.f = Object.getOwnPropertySymbols
    }, function(t, e, i) {
        "use strict";
        var n = i(6);
        t.exports = function() {
            var t = n(this),
                e = "";
            return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
        }
    }, function(t, e, i) {
        function n(t, e) {
            return RegExp(t, e)
        }
        i = i(4);
        e.UNSUPPORTED_Y = i(function() {
            var t = n("a", "y");
            return t.lastIndex = 2, null != t.exec("abcd")
        }), e.BROKEN_CARET = i(function() {
            var t = n("^r", "gy");
            return t.lastIndex = 2, null != t.exec("str")
        })
    }, function(t, e, i) {
        var n = i(10),
            a = i(13),
            r = i(6),
            l = i(63);
        t.exports = n ? Object.defineProperties : function(t, e) {
            r(t);
            for (var i, n = l(e), s = n.length, o = 0; o < s;) a.f(t, i = n[o++], e[i]);
            return t
        }
    }, function(t, e, i) {
        var n = i(58),
            s = i(46);
        t.exports = Object.keys || function(t) {
            return n(t, s)
        }
    }, function(t, e, i) {
        i = i(18);
        t.exports = i("document", "documentElement")
    }, function(t, e, i) {
        i = i(4);
        t.exports = i(function() {
            var t = RegExp(".", "string".charAt(0));
            return !(t.dotAll && t.exec("\n") && "s" === t.flags)
        })
    }, function(t, e, i) {
        i = i(4);
        t.exports = i(function() {
            var t = RegExp("(?<a>b)", "string".charAt(5));
            return "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c")
        })
    }, function(t, e) {
        t.exports = "\t\n\v\f\r                　\u2028\u2029\ufeff"
    }, function(t, e, i) {
        var n = i(32),
            i = i(4);
        t.exports = !!Object.getOwnPropertySymbols && !i(function() {
            var t = Symbol();
            return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && n && n < 41
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(18),
            s = i(13),
            o = i(5),
            a = i(10),
            r = o("species");
        t.exports = function(t) {
            var e = n(t),
                t = s.f;
            a && e && !e[r] && t(e, r, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }, function(t, e, i) {
        "use strict";

        function g() {
            return this
        }
        var _ = i(9),
            m = i(71),
            v = i(73),
            b = i(49),
            y = i(28),
            x = i(11),
            w = i(14),
            n = i(5),
            C = i(26),
            k = i(27),
            i = i(72),
            T = i.IteratorPrototype,
            S = i.BUGGY_SAFARI_ITERATORS,
            E = n("iterator"),
            A = "values",
            M = "entries";
        t.exports = function(t, e, i, n, s, o, a) {
            m(i, e, n);

            function r(t) {
                if (t === s && f) return f;
                if (!S && t in u) return u[t];
                switch (t) {
                    case "keys":
                    case A:
                    case M:
                        return function() {
                            return new i(this, t)
                        }
                }
                return function() {
                    return new i(this)
                }
            }
            var l, c, h = e + " Iterator",
                d = !1,
                u = t.prototype,
                p = u[E] || u["@@iterator"] || s && u[s],
                f = !S && p || r(s),
                n = "Array" == e && u.entries || p;
            if (n && (t = v(n.call(new t)), T !== Object.prototype && t.next && (C || v(t) === T || (b ? b(t, T) : "function" != typeof t[E] && x(t, E, g)), y(t, h, !0, !0), C && (k[h] = g))), s == A && p && p.name !== A && (d = !0, f = function() {
                    return p.call(this)
                }), C && !a || u[E] === f || x(u, E, f), k[e] = f, s)
                if (l = {
                        values: r(A),
                        keys: o ? f : r("keys"),
                        entries: r(M)
                    }, a)
                    for (c in l) !S && !d && c in u || w(u, c, l[c]);
                else _({
                    target: e,
                    proto: !0,
                    forced: S || d
                }, l);
            return l
        }
    }, function(t, e, i) {
        "use strict";

        function n() {
            return this
        }
        var s = i(72).IteratorPrototype,
            o = i(31),
            a = i(23),
            r = i(28),
            l = i(27);
        t.exports = function(t, e, i) {
            e += " Iterator";
            return t.prototype = o(s, {
                next: a(1, i)
            }), r(t, e, !1, !0), l[e] = n, t
        }
    }, function(t, e, i) {
        "use strict";
        var n, s = i(4),
            o = i(73),
            a = i(11),
            r = i(7),
            l = i(5),
            c = i(26),
            h = l("iterator"),
            i = !1;
        [].keys && ("next" in (l = [].keys()) ? (l = o(o(l))) !== Object.prototype && (n = l) : i = !0);
        s = null == n || s(function() {
            var t = {};
            return n[h].call(t) !== t
        });
        s && (n = {}), c && !s || r(n, h) || a(n, h, function() {
            return this
        }), t.exports = {
            IteratorPrototype: n,
            BUGGY_SAFARI_ITERATORS: i
        }
    }, function(t, e, i) {
        var n = i(7),
            s = i(16),
            o = i(43),
            i = i(103),
            a = o("IE_PROTO"),
            r = Object.prototype;
        t.exports = i ? Object.getPrototypeOf : function(t) {
            return t = s(t), n(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? r : null
        }
    }, function(t, e, i) {
        "use strict";
        var n, s, o, a, r = i(9),
            l = i(26),
            g = i(3),
            c = i(18),
            h = i(107),
            d = i(14),
            u = i(75),
            p = i(49),
            f = i(28),
            _ = i(69),
            m = i(8),
            v = i(22),
            b = i(51),
            y = i(41),
            x = i(108),
            w = i(110),
            C = i(111),
            k = i(79).set,
            T = i(112),
            S = i(114),
            E = i(115),
            A = i(81),
            M = i(116),
            O = i(15),
            I = i(47),
            D = i(5),
            L = i(117),
            P = i(35),
            R = i(32),
            B = D("species"),
            N = "Promise",
            H = O.get,
            j = O.set,
            W = O.getterFor(N),
            O = h && h.prototype,
            F = h,
            V = O,
            z = g.TypeError,
            Y = g.document,
            X = g.process,
            U = A.f,
            K = U,
            $ = !!(Y && Y.createEvent && g.dispatchEvent),
            Q = "function" == typeof PromiseRejectionEvent,
            q = "unhandledrejection",
            Z = "rejectionhandled",
            G = 1,
            J = 2,
            tt = 1,
            et = 2,
            it = !1,
            I = I(N, function() {
                var t = y(F),
                    e = t !== String(F);
                if (!e && 66 === R) return !0;
                if (l && !V.finally) return !0;
                if (51 <= R && /native code/.test(t)) return !1;
                var i = new F(function(t) {
                        t(1)
                    }),
                    t = function(t) {
                        t(function() {}, function() {})
                    };
                return (i.constructor = {})[B] = t, !(it = i.then(function() {}) instanceof t) || !e && L && !Q
            }),
            w = I || !w(function(t) {
                F.all(t).catch(function() {})
            }),
            nt = function(t) {
                var e;
                return !(!m(t) || "function" != typeof(e = t.then)) && e
            },
            st = function(u, p) {
                var f;
                u.notified || (u.notified = !0, f = u.reactions, T(function() {
                    for (var s, t = u.value, e = u.state == G, i = 0; f.length > i;) {
                        var n, o, a, r = f[i++],
                            l = e ? r.ok : r.fail,
                            c = r.resolve,
                            h = r.reject,
                            d = r.domain;
                        try {
                            l ? (e || (u.rejection === et && function(e) {
                                k.call(g, function() {
                                    var t = e.facade;
                                    if (P) X.emit("rejectionHandled", t);
                                    else ot(Z, t, e.value)
                                })
                            }(u), u.rejection = tt), !0 === l ? n = t : (d && d.enter(), n = l(t), d && (d.exit(), a = !0)), n === r.promise ? h(z("Promise-chain cycle")) : (o = nt(n)) ? o.call(n, c, h) : c(n)) : h(t)
                        } catch (t) {
                            d && !a && d.exit(), h(t)
                        }
                    }
                    u.reactions = [], u.notified = !1, p && !u.rejection && (s = u, k.call(g, function() {
                        var t, e = s.facade,
                            i = s.value,
                            n = at(s);
                        if (n && (t = M(function() {
                                P ? X.emit("unhandledRejection", i, e) : ot(q, e, i)
                            }), s.rejection = P || at(s) ? et : tt, t.error)) throw t.value
                    }))
                }))
            },
            ot = function(t, e, i) {
                var n, s;
                $ ? ((n = Y.createEvent("Event")).promise = e, n.reason = i, n.initEvent(t, !1, !0), g.dispatchEvent(n)) : n = {
                    promise: e,
                    reason: i
                }, !Q && (s = g["on" + t]) ? s(n) : t === q && E("Unhandled promise rejection", i)
            },
            at = function(t) {
                return t.rejection !== tt && !t.parent
            },
            rt = function(e, i, n) {
                return function(t) {
                    e(i, t, n)
                }
            },
            lt = function(t, e, i) {
                t.done || (t.done = !0, (t = i ? i : t).value = e, t.state = J, st(t, !0))
            },
            ct = function(i, t, e) {
                if (!i.done) {
                    i.done = !0, e && (i = e);
                    try {
                        if (i.facade === t) throw z("Promise can't be resolved itself");
                        var n = nt(t);
                        n ? T(function() {
                            var e = {
                                done: !1
                            };
                            try {
                                n.call(t, rt(ct, e, i), rt(lt, e, i))
                            } catch (t) {
                                lt(e, t, i)
                            }
                        }) : (i.value = t, i.state = G, st(i, !1))
                    } catch (t) {
                        lt({
                            done: !1
                        }, t, i)
                    }
                }
            };
        if (I && (V = (F = function(t) {
                b(this, F, N), v(t), n.call(this);
                var e = H(this);
                try {
                    t(rt(ct, e), rt(lt, e))
                } catch (t) {
                    lt(e, t)
                }
            }).prototype, (n = function(t) {
                j(this, {
                    type: N,
                    done: !1,
                    notified: !1,
                    parent: !1,
                    reactions: [],
                    rejection: !1,
                    state: 0,
                    value: void 0
                })
            }).prototype = u(V, {
                then: function(t, e) {
                    var i = W(this),
                        n = U(C(this, F));
                    return n.ok = "function" != typeof t || t, n.fail = "function" == typeof e && e, n.domain = P ? X.domain : void 0, i.parent = !0, i.reactions.push(n), 0 != i.state && st(i, !1), n.promise
                },
                catch: function(t) {
                    return this.then(void 0, t)
                }
            }), s = function() {
                var t = new n,
                    e = H(t);
                this.promise = t, this.resolve = rt(ct, e), this.reject = rt(lt, e)
            }, A.f = U = function(t) {
                return t === F || t === o ? new s : K(t)
            }, !l && "function" == typeof h && O !== Object.prototype)) {
            a = O.then, it || (d(O, "then", function(t, e) {
                var i = this;
                return new F(function(t, e) {
                    a.call(i, t, e)
                }).then(t, e)
            }, {
                unsafe: !0
            }), d(O, "catch", V.catch, {
                unsafe: !0
            }));
            try {
                delete O.constructor
            } catch (t) {}
            p && p(O, V)
        }
        r({
            global: !0,
            wrap: !0,
            forced: I
        }, {
            Promise: F
        }), f(F, N, !1, !0), _(N), o = c(N), r({
            target: N,
            stat: !0,
            forced: I
        }, {
            reject: function(t) {
                var e = U(this);
                return e.reject.call(void 0, t), e.promise
            }
        }), r({
            target: N,
            stat: !0,
            forced: l || I
        }, {
            resolve: function(t) {
                return S(l && this === o ? F : this, t)
            }
        }), r({
            target: N,
            stat: !0,
            forced: w
        }, {
            all: function(t) {
                var r = this,
                    e = U(r),
                    l = e.resolve,
                    c = e.reject,
                    i = M(function() {
                        var n = v(r.resolve),
                            s = [],
                            o = 0,
                            a = 1;
                        x(t, function(t) {
                            var e = o++,
                                i = !1;
                            s.push(void 0), a++, n.call(r, t).then(function(t) {
                                i || (i = !0, s[e] = t, --a || l(s))
                            }, c)
                        }), --a || l(s)
                    });
                return i.error && c(i.value), e.promise
            },
            race: function(t) {
                var i = this,
                    n = U(i),
                    s = n.reject,
                    e = M(function() {
                        var e = v(i.resolve);
                        x(t, function(t) {
                            e.call(i, t).then(n.resolve, s)
                        })
                    });
                return e.error && s(e.value), n.promise
            }
        })
    }, function(t, e, i) {
        var s = i(14);
        t.exports = function(t, e, i) {
            for (var n in e) s(t, n, e[n], i);
            return t
        }
    }, function(t, e, i) {
        var n = i(5),
            s = i(27),
            o = n("iterator"),
            a = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (s.Array === t || a[o] === t)
        }
    }, function(t, e, i) {
        var n = i(109),
            s = i(24),
            o = i(5)("toStringTag"),
            a = "Arguments" == s(function() {
                return arguments
            }());
        t.exports = n ? s : function(t) {
            var e;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(t = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = Object(t), o)) ? t : a ? s(e) : "Object" == (t = s(e)) && "function" == typeof e.callee ? "Arguments" : t
        }
    }, function(t, e, i) {
        var n = i(6);
        t.exports = function(t) {
            var e = t.return;
            if (void 0 !== e) return n(e.call(t)).value
        }
    }, function(t, e, i) {
        function n(t) {
            return function() {
                w(t)
            }
        }

        function s(t) {
            w(t.data)
        }
        var o, a = i(3),
            r = i(4),
            l = i(33),
            c = i(64),
            h = i(39),
            d = i(80),
            u = i(35),
            p = a.location,
            f = a.setImmediate,
            g = a.clearImmediate,
            _ = a.process,
            m = a.MessageChannel,
            v = a.Dispatch,
            b = 0,
            y = {},
            x = "onreadystatechange",
            w = function(t) {
                var e;
                y.hasOwnProperty(t) && (e = y[t], delete y[t], e())
            },
            i = function(t) {
                a.postMessage(t + "", p.protocol + "//" + p.host)
            };
        f && g || (f = function(t) {
            for (var e = [], i = 1; i < arguments.length;) e.push(arguments[i++]);
            return y[++b] = function() {
                ("function" == typeof t ? t : Function(t)).apply(void 0, e)
            }, o(b), b
        }, g = function(t) {
            delete y[t]
        }, u ? o = function(t) {
            _.nextTick(n(t))
        } : v && v.now ? o = function(t) {
            v.now(n(t))
        } : m && !d ? (m = (d = new m).port2, d.port1.onmessage = s, o = l(m.postMessage, m, 1)) : a.addEventListener && "function" == typeof postMessage && !a.importScripts && p && "file:" !== p.protocol && !r(i) ? (o = i, a.addEventListener("message", s, !1)) : o = x in h("script") ? function(t) {
            c.appendChild(h("script"))[x] = function() {
                c.removeChild(this), w(t)
            }
        } : function(t) {
            setTimeout(n(t), 0)
        }), t.exports = {
            set: f,
            clear: g
        }
    }, function(t, e, i) {
        i = i(21);
        t.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(i)
    }, function(t, e, i) {
        "use strict";

        function n(t) {
            var i, n;
            this.promise = new t(function(t, e) {
                if (void 0 !== i || void 0 !== n) throw TypeError("Bad Promise constructor");
                i = t, n = e
            }), this.resolve = s(i), this.reject = s(n)
        }
        var s = i(22);
        t.exports.f = function(t) {
            return new n(t)
        }
    }, function(t, e, i) {
        var n = i(9),
            i = Math.hypot,
            l = Math.abs,
            c = Math.sqrt;
        n({
            target: "Math",
            stat: !0,
            forced: !!i && i(1 / 0, NaN) !== 1 / 0
        }, {
            hypot: function(t, e) {
                for (var i, n, s = 0, o = 0, a = arguments.length, r = 0; o < a;) r < (i = l(arguments[o++])) ? (s = s * (n = r / i) * n + 1, r = i) : s += 0 < i ? (n = i / r) * n : i;
                return r === 1 / 0 ? 1 / 0 : r * c(s)
            }
        })
    }, function(t, e, i) {
        var n = i(4),
            s = i(5),
            o = i(26),
            a = s("iterator");
        t.exports = !n(function() {
            var t = new URL("b?a=1&b=2&c=3", "http://a"),
                i = t.searchParams,
                n = "";
            return t.pathname = "c%20d", i.forEach(function(t, e) {
                i.delete("b"), n += e + t
            }), o && !t.toJSON || !i.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== i.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !i[a] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== n || "x" !== new URL("http://x", void 0).host
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(4);
        t.exports = function(t, e) {
            var i = [][t];
            return !!i && n(function() {
                i.call(null, e || function() {
                    throw 1
                }, 1)
            })
        }
    }, function(t, e) {
        var i = function() {
            return this
        }();
        try {
            i = i || new Function("return this")()
        } catch (t) {
            "object" == typeof window && (i = window)
        }
        t.exports = i
    }, function(t, e, i) {
        var n = i(3),
            i = i(41),
            n = n.WeakMap;
        t.exports = "function" == typeof n && /native code/.test(i(n))
    }, function(t, e, i) {
        var r = i(7),
            l = i(88),
            c = i(36),
            h = i(13);
        t.exports = function(t, e) {
            for (var i = l(e), n = h.f, s = c.f, o = 0; o < i.length; o++) {
                var a = i[o];
                r(t, a) || n(t, a, s(e, a))
            }
        }
    }, function(t, e, i) {
        var n = i(18),
            s = i(57),
            o = i(59),
            a = i(6);
        t.exports = n("Reflect", "ownKeys") || function(t) {
            var e = s.f(a(t)),
                i = o.f;
            return i ? e.concat(i(t)) : e
        }
    }, function(t, e, i) {
        i = i(3);
        t.exports = i
    }, function(t, e, i) {
        var l = i(29),
            c = i(19),
            h = i(91),
            i = function(r) {
                return function(t, e, i) {
                    var n, s = l(t),
                        o = c(s.length),
                        a = h(i, o);
                    if (r && e != e) {
                        for (; a < o;)
                            if ((n = s[a++]) != n) return !0
                    } else
                        for (; a < o; a++)
                            if ((r || a in s) && s[a] === e) return r || a || 0;
                    return !r && -1
                }
            };
        t.exports = {
            includes: i(!0),
            indexOf: i(!1)
        }
    }, function(t, e, i) {
        var n = i(30),
            s = Math.max,
            o = Math.min;
        t.exports = function(t, e) {
            t = n(t);
            return t < 0 ? s(t + e, 0) : o(t, e)
        }
    }, function(t, e, i) {
        var n = i(25),
            i = "[" + i(67) + "]",
            s = RegExp("^" + i + i + "*"),
            o = RegExp(i + i + "*$"),
            i = function(e) {
                return function(t) {
                    t = String(n(t));
                    return 1 & e && (t = t.replace(s, "")), t = 2 & e ? t.replace(o, "") : t
                }
            };
        t.exports = {
            start: i(1),
            end: i(2),
            trim: i(3)
        }
    }, function(t, e, i) {
        var n = i(4),
            s = i(67);
        t.exports = function(t) {
            return n(function() {
                return !!s[t]() || "​᠎" != "​᠎" [t]() || s[t].name !== t
            })
        }
    }, function(t, e, i) {
        var o = i(8),
            a = i(49);
        t.exports = function(t, e, i) {
            var n, s;
            return a && "function" == typeof(n = e.constructor) && n !== i && o(s = n.prototype) && s !== i.prototype && a(t, s), t
        }
    }, function(t, e, i) {
        var n = i(8);
        t.exports = function(t) {
            if (!n(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
            return t
        }
    }, function(t, e, i) {
        var n = i(8),
            s = i(24),
            o = i(5)("match");
        t.exports = function(t) {
            var e;
            return n(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == s(t))
        }
    }, function(t, e, i) {
        i = i(68);
        t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator
    }, function(t, e, i) {
        "use strict";
        i(2);
        var l = i(14),
            c = i(48),
            h = i(4),
            d = i(5),
            u = i(11),
            p = d("species"),
            f = RegExp.prototype;
        t.exports = function(i, t, e, n) {
            var a, s = d(i),
                r = !h(function() {
                    var t = {};
                    return t[s] = function() {
                        return 7
                    }, 7 != "" [i](t)
                }),
                o = r && !h(function() {
                    var t = !1,
                        e = /a/;
                    return "split" === i && ((e = {
                        constructor: {}
                    }).constructor[p] = function() {
                        return e
                    }, e.flags = "", e[s] = /./ [s]), e.exec = function() {
                        return t = !0, null
                    }, e[s](""), !t
                });
            r && o && !e || (a = /./ [s], t = t(s, "" [i], function(t, e, i, n, s) {
                var o = e.exec;
                return o === c || o === f.exec ? r && !s ? {
                    done: !0,
                    value: a.call(e, i, n)
                } : {
                    done: !0,
                    value: t.call(i, e, n)
                } : {
                    done: !1
                }
            }), l(String.prototype, i, t[0]), l(f, s, t[1])), n && u(f[s], "sham", !0)
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(50).charAt;
        t.exports = function(t, e, i) {
            return e + (i ? n(t, e).length : 1)
        }
    }, function(t, e, i) {
        var n = i(16),
            u = Math.floor,
            s = "".replace,
            p = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
            f = /\$([$&'`]|\d{1,2})/g;
        t.exports = function(o, a, r, l, c, t) {
            var h = r + o.length,
                d = l.length,
                e = f;
            return void 0 !== c && (c = n(c), e = p), s.call(t, e, function(t, e) {
                var i;
                switch (e.charAt(0)) {
                    case "$":
                        return "$";
                    case "&":
                        return o;
                    case "`":
                        return a.slice(0, r);
                    case "'":
                        return a.slice(h);
                    case "<":
                        i = c[e.slice(1, -1)];
                        break;
                    default:
                        var n = +e;
                        if (0 == n) return t;
                        if (d < n) {
                            var s = u(n / 10);
                            return 0 === s ? t : s <= d ? void 0 === l[s - 1] ? e.charAt(1) : l[s - 1] + e.charAt(1) : t
                        }
                        i = l[n - 1]
                }
                return void 0 === i ? "" : i
            })
        }
    }, function(t, e, i) {
        var n = i(24),
            s = i(48);
        t.exports = function(t, e) {
            var i = t.exec;
            if ("function" == typeof i) {
                i = i.call(t, e);
                if ("object" != typeof i) throw TypeError("RegExp exec method returned something other than an Object or null");
                return i
            }
            if ("RegExp" !== n(t)) throw TypeError("RegExp#exec called on incompatible receiver");
            return s.call(t, e)
        }
    }, function(t, e, i) {
        var n = i(5),
            s = i(31),
            i = i(13),
            o = n("unscopables"),
            a = Array.prototype;
        null == a[o] && i.f(a, o, {
            configurable: !0,
            value: s(null)
        }), t.exports = function(t) {
            a[o][t] = !0
        }
    }, function(t, e, i) {
        i = i(4);
        t.exports = !i(function() {
            function t() {}
            return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
        })
    }, function(t, e) {
        t.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
        }
    }, function(t, e) {
        function s(t) {
            var e = n[t];
            if (void 0 !== e) return e.exports;
            e = n[t] = {
                id: t,
                exports: {}
            };
            return i[t](e, e.exports, s), e.exports
        }
        var i, n;
        i = {
            454: (t, e, i) => {
                "use strict";
                i.d(e, {
                    Z: () => n
                });
                e = i(645), e = i.n(e)()(function(t) {
                    return t[1]
                });
                e.push([t.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
                const n = e
            },
            645: t => {
                "use strict";
                t.exports = function(i) {
                    var l = [];
                    return l.toString = function() {
                        return this.map(function(t) {
                            var e = i(t);
                            return t[2] ? "@media ".concat(t[2], " {").concat(e, "}") : e
                        }).join("")
                    }, l.i = function(t, e, i) {
                        "string" == typeof t && (t = [
                            [null, t, ""]
                        ]);
                        var n = {};
                        if (i)
                            for (var s = 0; s < this.length; s++) {
                                var o = this[s][0];
                                null != o && (n[o] = !0)
                            }
                        for (var a = 0; a < t.length; a++) {
                            var r = [].concat(t[a]);
                            i && n[r[0]] || (e && (r[2] ? r[2] = "".concat(e, " and ").concat(r[2]) : r[2] = e), l.push(r))
                        }
                    }, l
                }
            },
            810: () => {
                ! function() {
                    if ("undefined" != typeof window) try {
                        var t = new window.CustomEvent("test", {
                            cancelable: !0
                        });
                        if (t.preventDefault(), !0 !== t.defaultPrevented) throw new Error("Could not prevent default")
                    } catch (t) {
                        function e(t, e) {
                            var i, n;
                            return (e = e || {}).bubbles = !!e.bubbles, e.cancelable = !!e.cancelable, (i = document.createEvent("CustomEvent")).initCustomEvent(t, e.bubbles, e.cancelable, e.detail), n = i.preventDefault, i.preventDefault = function() {
                                n.call(this);
                                try {
                                    Object.defineProperty(this, "defaultPrevented", {
                                        get: function() {
                                            return !0
                                        }
                                    })
                                } catch (t) {
                                    this.defaultPrevented = !0
                                }
                            }, i
                        }
                        e.prototype = window.Event.prototype, window.CustomEvent = e
                    }
                }()
            },
            379: (t, e, s) => {
                "use strict";
                var i, n, o = (n = {}, function(t) {
                        if (void 0 === n[t]) {
                            var e = document.querySelector(t);
                            if (window.HTMLIFrameElement && e instanceof window.HTMLIFrameElement) try {
                                e = e.contentDocument.head
                            } catch (t) {
                                e = null
                            }
                            n[t] = e
                        }
                        return n[t]
                    }),
                    c = [];

                function h(t) {
                    for (var e = -1, i = 0; i < c.length; i++)
                        if (c[i].identifier === t) {
                            e = i;
                            break
                        }
                    return e
                }

                function r(t, e) {
                    for (var i = {}, n = [], s = 0; s < t.length; s++) {
                        var o = t[s],
                            a = e.base ? o[0] + e.base : o[0],
                            r = i[a] || 0,
                            l = "".concat(a, " ").concat(r);
                        i[a] = r + 1;
                        r = h(l), o = {
                            css: o[1],
                            media: o[2],
                            sourceMap: o[3]
                        }; - 1 !== r ? (c[r].references++, c[r].updater(o)) : c.push({
                            identifier: l,
                            updater: function(e, t) {
                                var i, n, s; {
                                    var o;
                                    s = t.singleton ? (o = f++, i = p = p || d(t), n = u.bind(null, i, o, !1), u.bind(null, i, o, !0)) : (i = d(t), n = function(t, e, i) {
                                        var n = i.css,
                                            s = i.media,
                                            i = i.sourceMap;
                                        if (s ? t.setAttribute("media", s) : t.removeAttribute("media"), i && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i)))), " */")), t.styleSheet) t.styleSheet.cssText = n;
                                        else {
                                            for (; t.firstChild;) t.removeChild(t.firstChild);
                                            t.appendChild(document.createTextNode(n))
                                        }
                                    }.bind(null, i, t), function() {
                                        var t;
                                        null !== (t = i).parentNode && t.parentNode.removeChild(t)
                                    })
                                }
                                return n(e),
                                    function(t) {
                                        t ? t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap || n(e = t) : s()
                                    }
                            }(o, e),
                            references: 1
                        }), n.push(l)
                    }
                    return n
                }

                function d(t) {
                    var e, i = document.createElement("style"),
                        n = t.attributes || {};
                    if (void 0 !== n.nonce || (e = s.nc) && (n.nonce = e), Object.keys(n).forEach(function(t) {
                            i.setAttribute(t, n[t])
                        }), "function" == typeof t.insert) t.insert(i);
                    else {
                        t = o(t.insert || "head");
                        if (!t) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        t.appendChild(i)
                    }
                    return i
                }
                var a, l = (a = [], function(t, e) {
                    return a[t] = e, a.filter(Boolean).join("\n")
                });

                function u(t, e, i, n) {
                    i = i ? "" : n.media ? "@media ".concat(n.media, " {").concat(n.css, "}") : n.css;
                    t.styleSheet ? t.styleSheet.cssText = l(e, i) : (n = document.createTextNode(i), (i = t.childNodes)[e] && t.removeChild(i[e]), i.length ? t.insertBefore(n, i[e]) : t.appendChild(n))
                }
                var p = null,
                    f = 0;
                t.exports = function(t, o) {
                    (o = o || {}).singleton || "boolean" == typeof o.singleton || (o.singleton = i = void 0 === i ? Boolean(window && document && document.all && !window.atob) : i);
                    var a = r(t = t || [], o);
                    return function(t) {
                        if (t = t || [], "[object Array]" === Object.prototype.toString.call(t)) {
                            for (var e = 0; e < a.length; e++) {
                                var i = h(a[e]);
                                c[i].references--
                            }
                            for (var t = r(t, o), n = 0; n < a.length; n++) {
                                var s = h(a[n]);
                                0 === c[s].references && (c[s].updater(), c.splice(s, 1))
                            }
                            a = t
                        }
                    }
                }
            }
        }, n = {}, s.n = t => {
            var e = t && t.__esModule ? () => t.default : () => t;
            return s.d(e, {
                a: e
            }), e
        }, s.d = (t, e) => {
            for (var i in e) s.o(e, i) && !s.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            })
        }, s.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), (() => {
            "use strict";
            var t = s(379),
                e = s.n(t),
                t = s(454);

            function i(t) {
                var e;
                t.hasAttribute("autocompleted") || (t.setAttribute("autocompleted", ""), e = new window.CustomEvent("onautocomplete", {
                    bubbles: !0,
                    cancelable: !0,
                    detail: null
                }), t.dispatchEvent(e) || (t.value = ""))
            }

            function n(t) {
                t.hasAttribute("autocompleted") && (t.removeAttribute("autocompleted"), t.dispatchEvent(new window.CustomEvent("onautocomplete", {
                    bubbles: !0,
                    cancelable: !1,
                    detail: null
                })))
            }
            e()(t.Z, {
                insert: "head",
                singleton: !1
            }), t.Z.locals, s(810), document.addEventListener("animationstart", function(t) {
                ("onautofillstart" === t.animationName ? i : n)(t.target)
            }, !0), document.addEventListener("input", function(t) {
                ("insertReplacementText" !== t.inputType && "data" in t ? n : i)(t.target)
            }, !0)
        })()
    }, function(t, e, i) {
        "use strict";

        function s(t) {
            return !(!(e = t) || "object" != typeof e || (e = t, "[object RegExp]" === (t = Object.prototype.toString.call(e)) || "[object Date]" === t || function(t) {
                return t.$$typeof === n
            }(e)));
            var e
        }
        var n = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;

        function r(t, e) {
            return !1 !== e.clone && e.isMergeableObject(t) ? h(Array.isArray(t) ? [] : {}, t, e) : t
        }

        function o(t, e, i) {
            return t.concat(e).map(function(t) {
                return r(t, i)
            })
        }

        function l(t) {
            return Object.keys(t).concat((e = t, Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter(function(t) {
                return e.propertyIsEnumerable(t)
            }) : []));
            var e
        }

        function c(t, e) {
            try {
                return e in t
            } catch (t) {
                return !1
            }
        }

        function a(n, s, o) {
            var a = {};
            return o.isMergeableObject(n) && l(n).forEach(function(t) {
                a[t] = r(n[t], o)
            }), l(s).forEach(function(t) {
                var e, i;
                (!c(e = n, i = t) || Object.hasOwnProperty.call(e, i) && Object.propertyIsEnumerable.call(e, i)) && (c(n, t) && o.isMergeableObject(s[t]) ? a[t] = (e = t, ((i = o).customMerge && "function" == typeof(e = i.customMerge(e)) ? e : h)(n[t], s[t], o)) : a[t] = r(s[t], o))
            }), a
        }

        function h(t, e, i) {
            (i = i || {}).arrayMerge = i.arrayMerge || o, i.isMergeableObject = i.isMergeableObject || s, i.cloneUnlessOtherwiseSpecified = r;
            var n = Array.isArray(e);
            return n === Array.isArray(t) ? n ? i.arrayMerge(t, e, i) : a(t, e, i) : r(e, i)
        }
        h.all = function(t, i) {
            if (!Array.isArray(t)) throw new Error("first argument should be an array");
            return t.reduce(function(t, e) {
                return h(t, e, i)
            }, {})
        }, t.exports = h
    }, function(t, e, i) {
        i = i(3);
        t.exports = i.Promise
    }, function(t, e, i) {
        function _(t, e) {
            this.stopped = t, this.result = e
        }
        var m = i(6),
            v = i(76),
            b = i(19),
            y = i(33),
            x = i(34),
            w = i(78);
        t.exports = function(t, e, i) {
            function n(t) {
                return o && w(o), new _(!0, t)
            }

            function s(t) {
                return u ? (m(t), f ? g(t[0], t[1], n) : g(t[0], t[1])) : f ? g(t, n) : g(t)
            }
            var o, a, r, l, c, h, d = i && i.that,
                u = !(!i || !i.AS_ENTRIES),
                p = !(!i || !i.IS_ITERATOR),
                f = !(!i || !i.INTERRUPTED),
                g = y(e, d, 1 + u + f);
            if (p) o = t;
            else {
                if ("function" != typeof(p = x(t))) throw TypeError("Target is not iterable");
                if (v(p)) {
                    for (a = 0, r = b(t.length); a < r; a++)
                        if ((l = s(t[a])) && l instanceof _) return l;
                    return new _(!1)
                }
                o = p.call(t)
            }
            for (c = o.next; !(h = c.call(o)).done;) {
                try {
                    l = s(h.value)
                } catch (t) {
                    throw w(o), t
                }
                if ("object" == typeof l && l && l instanceof _) return l
            }
            return new _(!1)
        }
    }, function(t, e, i) {
        var n = {};
        n[i(5)("toStringTag")] = "z", t.exports = "[object z]" === String(n)
    }, function(t, e, i) {
        var s = i(5)("iterator"),
            o = !1;
        try {
            var n = 0,
                a = {
                    next: function() {
                        return {
                            done: !!n++
                        }
                    },
                    return: function() {
                        o = !0
                    }
                };
            a[s] = function() {
                return this
            }, Array.from(a, function() {
                throw 2
            })
        } catch (t) {}
        t.exports = function(t, e) {
            if (!e && !o) return !1;
            var i = !1;
            try {
                var n = {};
                n[s] = function() {
                    return {
                        next: function() {
                            return {
                                done: i = !0
                            }
                        }
                    }
                }, t(n)
            } catch (t) {}
            return i
        }
    }, function(t, e, i) {
        var n = i(6),
            s = i(22),
            o = i(5)("species");
        t.exports = function(t, e) {
            var i, t = n(t).constructor;
            return void 0 === t || null == (i = n(t)[o]) ? e : s(i)
        }
    }, function(t, e, i) {
        var n, s, o, a, r, l, c, h, d = i(3),
            u = i(36).f,
            p = i(79).set,
            f = i(80),
            g = i(113),
            _ = i(35),
            m = d.MutationObserver || d.WebKitMutationObserver,
            v = d.document,
            b = d.process,
            i = d.Promise,
            u = u(d, "queueMicrotask"),
            u = u && u.value;
        u || (n = function() {
            var t, e;
            for (_ && (t = b.domain) && t.exit(); s;) {
                e = s.fn, s = s.next;
                try {
                    e()
                } catch (t) {
                    throw s ? a() : o = void 0, t
                }
            }
            o = void 0, t && t.enter()
        }, a = f || _ || g || !m || !v ? i && i.resolve ? ((c = i.resolve(void 0)).constructor = i, h = c.then, function() {
            h.call(c, n)
        }) : _ ? function() {
            b.nextTick(n)
        } : function() {
            p.call(d, n)
        } : (r = !0, l = v.createTextNode(""), new m(n).observe(l, {
            characterData: !0
        }), function() {
            l.data = r = !r
        })), t.exports = u || function(t) {
            t = {
                fn: t,
                next: void 0
            };
            o && (o.next = t), s || (s = t, a()), o = t
        }
    }, function(t, e, i) {
        i = i(21);
        t.exports = /web0s(?!.*chrome)/i.test(i)
    }, function(t, e, i) {
        var n = i(6),
            s = i(8),
            o = i(81);
        t.exports = function(t, e) {
            if (n(t), s(e) && e.constructor === t) return e;
            t = o.f(t);
            return (0, t.resolve)(e), t.promise
        }
    }, function(t, e, i) {
        var n = i(3);
        t.exports = function(t, e) {
            var i = n.console;
            i && i.error && (1 === arguments.length ? i.error(t) : i.error(t, e))
        }
    }, function(t, e) {
        t.exports = function(t) {
            try {
                return {
                    error: !1,
                    value: t()
                }
            } catch (t) {
                return {
                    error: !0,
                    value: t
                }
            }
        }
    }, function(t, e) {
        t.exports = "object" == typeof window
    }, function(t, e, i) {
        "use strict";
        i(119);

        function h(t) {
            var e, i, n, s;
            if ("number" == typeof t) {
                for (e = [], i = 0; i < 4; i++) e.unshift(t % 256), t = M(t / 256);
                return e.join(".")
            }
            if ("object" != typeof t) return t;
            for (e = "", n = K(t), i = 0; i < 8; i++) s && 0 === t[i] || (s = s && !1, n === i ? (e += i ? ":" : "::", s = !0) : (e += t[i].toString(16), i < 7 && (e += ":")));
            return "[" + e + "]"
        }

        function s(t) {
            return !t.host || t.cannotBeABaseURL || "file" == t.scheme
        }

        function r(t, e, i, n) {
            var s, o, a, r = i || rt,
                l = 0,
                c = "",
                h = !1,
                d = !1,
                u = !1;
            for (i || (t.scheme = "", t.username = "", t.password = "", t.host = null, t.port = null, t.path = [], t.query = null, t.fragment = null, t.cannotBeABaseURL = !1, e = e.replace(Y, "")), e = e.replace(X, ""), s = b(e); l <= s.length;) {
                switch (o = s[l], r) {
                    case rt:
                        if (!o || !R.test(o)) {
                            if (i) return D;
                            r = ct;
                            continue
                        }
                        c += o.toLowerCase(), r = lt;
                        break;
                    case lt:
                        if (o && (B.test(o) || "+" == o || "-" == o || "." == o)) c += o.toLowerCase();
                        else {
                            if (":" != o) {
                                if (i) return D;
                                c = "", r = ct, l = 0;
                                continue
                            }
                            if (i && (tt(t) != v(J, c) || "file" == c && (et(t) || null !== t.port) || "file" == t.scheme && !t.host)) return;
                            if (t.scheme = c, i) return void(tt(t) && J[t.scheme] == t.port && (t.port = null));
                            c = "", "file" == t.scheme ? r = yt : tt(t) && n && n.scheme == t.scheme ? r = ht : tt(t) ? r = ft : "/" == s[l + 1] ? (r = dt, l++) : (t.cannotBeABaseURL = !0, t.path.push(""), r = Tt)
                        }
                        break;
                    case ct:
                        if (!n || n.cannotBeABaseURL && "#" != o) return D;
                        if (n.cannotBeABaseURL && "#" == o) {
                            t.scheme = n.scheme, t.path = n.path.slice(), t.query = n.query, t.fragment = "", t.cannotBeABaseURL = !0, r = Et;
                            break
                        }
                        r = "file" == n.scheme ? yt : ut;
                        continue;
                    case ht:
                        if ("/" != o || "/" != s[l + 1]) {
                            r = ut;
                            continue
                        }
                        r = gt, l++;
                        break;
                    case dt:
                        if ("/" == o) {
                            r = _t;
                            break
                        }
                        r = kt;
                        continue;
                    case ut:
                        if (t.scheme = n.scheme, o == m) t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = n.query;
                        else if ("/" == o || "\\" == o && tt(t)) r = pt;
                        else if ("?" == o) t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = "", r = St;
                        else {
                            if ("#" != o) {
                                t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.path.pop(), r = kt;
                                continue
                            }
                            t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = n.query, t.fragment = "", r = Et
                        }
                        break;
                    case pt:
                        if (!tt(t) || "/" != o && "\\" != o) {
                            if ("/" != o) {
                                t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, r = kt;
                                continue
                            }
                            r = _t
                        } else r = gt;
                        break;
                    case ft:
                        if (r = gt, "/" != o || "/" != c.charAt(l + 1)) continue;
                        l++;
                        break;
                    case gt:
                        if ("/" == o || "\\" == o) break;
                        r = _t;
                        continue;
                    case _t:
                        if ("@" == o) {
                            h && (c = "%40" + c);
                            for (var h = !0, p = b(c), f = 0; f < p.length; f++) {
                                var g = p[f];
                                ":" != g || u ? (g = G(g, Z), u ? t.password += g : t.username += g) : u = !0
                            }
                            c = ""
                        } else if (o == m || "/" == o || "?" == o || "#" == o || "\\" == o && tt(t)) {
                            if (h && "" == c) return I;
                            l -= b(c).length + 1, c = "", r = mt
                        } else c += o;
                        break;
                    case mt:
                    case vt:
                        if (i && "file" == t.scheme) {
                            r = wt;
                            continue
                        }
                        if (":" != o || d) {
                            if (o == m || "/" == o || "?" == o || "#" == o || "\\" == o && tt(t)) {
                                if (tt(t) && "" == c) return L;
                                if (i && "" == c && (et(t) || null !== t.port)) return;
                                if (a = U(t, c)) return a;
                                if (c = "", r = Ct, i) return;
                                continue
                            }
                            "[" == o ? d = !0 : "]" == o && (d = !1), c += o
                        } else {
                            if ("" == c) return L;
                            if (a = U(t, c)) return a;
                            if (c = "", r = bt, i == vt) return
                        }
                        break;
                    case bt:
                        if (!N.test(o)) {
                            if (o == m || "/" == o || "?" == o || "#" == o || "\\" == o && tt(t) || i) {
                                if ("" != c) {
                                    var _ = parseInt(c, 10);
                                    if (65535 < _) return P;
                                    t.port = tt(t) && _ === J[t.scheme] ? null : _, c = ""
                                }
                                if (i) return;
                                r = Ct;
                                continue
                            }
                            return P
                        }
                        c += o;
                        break;
                    case yt:
                        if (t.scheme = "file", "/" == o || "\\" == o) r = xt;
                        else {
                            if (!n || "file" != n.scheme) {
                                r = kt;
                                continue
                            }
                            if (o == m) t.host = n.host, t.path = n.path.slice(), t.query = n.query;
                            else if ("?" == o) t.host = n.host, t.path = n.path.slice(), t.query = "", r = St;
                            else {
                                if ("#" != o) {
                                    nt(s.slice(l).join("")) || (t.host = n.host, t.path = n.path.slice(), st(t)), r = kt;
                                    continue
                                }
                                t.host = n.host, t.path = n.path.slice(), t.query = n.query, t.fragment = "", r = Et
                            }
                        }
                        break;
                    case xt:
                        if ("/" == o || "\\" == o) {
                            r = wt;
                            break
                        }
                        n && "file" == n.scheme && !nt(s.slice(l).join("")) && (it(n.path[0], !0) ? t.path.push(n.path[0]) : t.host = n.host), r = kt;
                        continue;
                    case wt:
                        if (o == m || "/" == o || "\\" == o || "?" == o || "#" == o) {
                            if (!i && it(c)) r = kt;
                            else if ("" == c) {
                                if (t.host = "", i) return;
                                r = Ct
                            } else {
                                if (a = U(t, c)) return a;
                                if ("localhost" == t.host && (t.host = ""), i) return;
                                c = "", r = Ct
                            }
                            continue
                        }
                        c += o;
                        break;
                    case Ct:
                        if (tt(t)) {
                            if (r = kt, "/" != o && "\\" != o) continue
                        } else if (i || "?" != o)
                            if (i || "#" != o) {
                                if (o != m && (r = kt, "/" != o)) continue
                            } else t.fragment = "", r = Et;
                        else t.query = "", r = St;
                        break;
                    case kt:
                        if (o == m || "/" == o || "\\" == o && tt(t) || !i && ("?" == o || "#" == o)) {
                            if (at(c) ? (st(t), "/" == o || "\\" == o && tt(t) || t.path.push("")) : ot(c) ? "/" == o || "\\" == o && tt(t) || t.path.push("") : ("file" == t.scheme && !t.path.length && it(c) && (t.host && (t.host = ""), c = c.charAt(0) + ":"), t.path.push(c)), c = "", "file" == t.scheme && (o == m || "?" == o || "#" == o))
                                for (; 1 < t.path.length && "" === t.path[0];) t.path.shift();
                            "?" == o ? (t.query = "", r = St) : "#" == o && (t.fragment = "", r = Et)
                        } else c += G(o, q);
                        break;
                    case Tt:
                        "?" == o ? (t.query = "", r = St) : "#" == o ? (t.fragment = "", r = Et) : o != m && (t.path[0] += G(o, $));
                        break;
                    case St:
                        i || "#" != o ? o != m && ("'" == o && tt(t) ? t.query += "%27" : t.query += "#" == o ? "%23" : G(o, $)) : (t.fragment = "", r = Et);
                        break;
                    case Et:
                        o != m && (t.fragment += G(o, Q))
                }
                l++
            }
        }

        function l(t) {
            var e, i = g(this, l, "URL"),
                n = 1 < arguments.length ? arguments[1] : void 0,
                t = String(t),
                s = E(i, {
                    type: "URL"
                });
            if (void 0 !== n)
                if (n instanceof l) e = A(n);
                else if (a = r(e = {}, String(n))) throw TypeError(a);
            if (a = r(s, t, null, e)) throw TypeError(a);
            var o = s.searchParams = new T,
                a = S(o);
            a.updateSearchParams(s.query), a.updateURL = function() {
                s.query = String(o) || null
            }, c || (i.href = At.call(i), i.origin = Mt.call(i), i.protocol = Ot.call(i), i.username = It.call(i), i.password = Dt.call(i), i.host = Lt.call(i), i.hostname = Pt.call(i), i.port = Rt.call(i), i.pathname = Bt.call(i), i.search = Nt.call(i), i.searchParams = Ht.call(i), i.hash = jt.call(i))
        }
        var m, n, o, a = i(9),
            c = i(10),
            d = i(83),
            u = i(3),
            p = i(62),
            f = i(14),
            g = i(51),
            v = i(7),
            _ = i(120),
            b = i(121),
            y = i(50).codeAt,
            x = i(124),
            w = i(28),
            C = i(125),
            i = i(15),
            k = u.URL,
            T = C.URLSearchParams,
            S = C.getState,
            E = i.set,
            A = i.getterFor("URL"),
            M = Math.floor,
            O = Math.pow,
            I = "Invalid authority",
            D = "Invalid scheme",
            L = "Invalid host",
            P = "Invalid port",
            R = /[A-Za-z]/,
            B = /[\d+-.A-Za-z]/,
            N = /\d/,
            H = /^0x/i,
            j = /^[0-7]+$/,
            W = /^\d+$/,
            F = /^[\dA-Fa-f]+$/,
            V = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
            z = /[\0\t\n\r #/:<>?@[\\\]^|]/,
            Y = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g,
            X = /[\t\n\r]/g,
            U = function(t, e) {
                var i, n, s;
                if ("[" == e.charAt(0)) return "]" == e.charAt(e.length - 1) && (i = function(t) {
                    var e = [0, 0, 0, 0, 0, 0, 0, 0],
                        i = 0,
                        n = null,
                        s = 0,
                        o, a, r, l, c, h, d, u = function() {
                            return t.charAt(s)
                        };
                    if (u() == ":") {
                        if (t.charAt(1) != ":") return;
                        s += 2;
                        i++;
                        n = i
                    }
                    while (u()) {
                        if (i == 8) return;
                        if (u() == ":") {
                            if (n !== null) return;
                            s++;
                            i++;
                            n = i;
                            continue
                        }
                        o = a = 0;
                        while (a < 4 && F.test(u())) {
                            o = o * 16 + parseInt(u(), 16);
                            s++;
                            a++
                        }
                        if (u() == ".") {
                            if (a == 0) return;
                            s -= a;
                            if (i > 6) return;
                            r = 0;
                            while (u()) {
                                l = null;
                                if (r > 0)
                                    if (u() == "." && r < 4) s++;
                                    else return;
                                if (!N.test(u())) return;
                                while (N.test(u())) {
                                    c = parseInt(u(), 10);
                                    if (l === null) l = c;
                                    else if (l == 0) return;
                                    else l = l * 10 + c;
                                    if (l > 255) return;
                                    s++
                                }
                                e[i] = e[i] * 256 + l;
                                r++;
                                if (r == 2 || r == 4) i++
                            }
                            if (r != 4) return;
                            break
                        } else if (u() == ":") {
                            s++;
                            if (!u()) return
                        } else if (u()) return;
                        e[i++] = o
                    }
                    if (n !== null) {
                        h = i - n;
                        i = 7;
                        while (i != 0 && h > 0) {
                            d = e[i];
                            e[i--] = e[n + h - 1];
                            e[n + --h] = d
                        }
                    } else if (i != 8) return;
                    return e
                }(e.slice(1, -1))) ? void(t.host = i) : L;
                if (tt(t)) return e = x(e), V.test(e) || null === (i = function(t) {
                    var e = t.split("."),
                        i, n, s, o, a, r, l;
                    if (e.length && e[e.length - 1] == "") e.pop();
                    if ((i = e.length) > 4) return t;
                    for (n = [], s = 0; s < i; s++) {
                        o = e[s];
                        if (o == "") return t;
                        a = 10;
                        if (o.length > 1 && o.charAt(0) == "0") {
                            a = H.test(o) ? 16 : 8;
                            o = o.slice(a == 8 ? 1 : 2)
                        }
                        if (o === "") r = 0;
                        else {
                            if (!(a == 10 ? W : a == 8 ? j : F).test(o)) return t;
                            r = parseInt(o, a)
                        }
                        n.push(r)
                    }
                    for (s = 0; s < i; s++) {
                        r = n[s];
                        if (s == i - 1) {
                            if (r >= O(256, 5 - i)) return null
                        } else if (r > 255) return null
                    }
                    for (l = n.pop(), s = 0; s < n.length; s++) l += n[s] * O(256, 3 - s);
                    return l
                }(e)) ? L : void(t.host = i);
                if (z.test(e)) return L;
                for (i = "", n = b(e), s = 0; s < n.length; s++) i += G(n[s], $);
                t.host = i
            },
            K = function(t) {
                for (var e = null, i = 1, n = null, s = 0, o = 0; o < 8; o++) 0 !== t[o] ? (i < s && (e = n, i = s), n = null, s = 0) : (null === n && (n = o), ++s);
                return i < s && (e = n, i = s), e
            },
            $ = {},
            Q = _({}, $, {
                " ": 1,
                '"': 1,
                "<": 1,
                ">": 1,
                "`": 1
            }),
            q = _({}, Q, {
                "#": 1,
                "?": 1,
                "{": 1,
                "}": 1
            }),
            Z = _({}, q, {
                "/": 1,
                ":": 1,
                ";": 1,
                "=": 1,
                "@": 1,
                "[": 1,
                "\\": 1,
                "]": 1,
                "^": 1,
                "|": 1
            }),
            G = function(t, e) {
                var i = y(t, 0);
                return 32 < i && i < 127 && !v(e, t) ? t : encodeURIComponent(t)
            },
            J = {
                ftp: 21,
                file: null,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
            },
            tt = function(t) {
                return v(J, t.scheme)
            },
            et = function(t) {
                return "" != t.username || "" != t.password
            },
            it = function(t, e) {
                return 2 == t.length && R.test(t.charAt(0)) && (":" == (t = t.charAt(1)) || !e && "|" == t)
            },
            nt = function(t) {
                var e;
                return 1 < t.length && it(t.slice(0, 2)) && (2 == t.length || "/" === (e = t.charAt(2)) || "\\" === e || "?" === e || "#" === e)
            },
            st = function(t) {
                var e = t.path,
                    i = e.length;
                !i || "file" == t.scheme && 1 == i && it(e[0], !0) || e.pop()
            },
            ot = function(t) {
                return "." === t || "%2e" === t.toLowerCase()
            },
            at = function(t) {
                return ".." === (t = t.toLowerCase()) || "%2e." === t || ".%2e" === t || "%2e%2e" === t
            },
            rt = {},
            lt = {},
            ct = {},
            ht = {},
            dt = {},
            ut = {},
            pt = {},
            ft = {},
            gt = {},
            _t = {},
            mt = {},
            vt = {},
            bt = {},
            yt = {},
            xt = {},
            wt = {},
            Ct = {},
            kt = {},
            Tt = {},
            St = {},
            Et = {},
            i = l.prototype,
            At = function() {
                var t = A(this),
                    e = t.scheme,
                    i = t.username,
                    n = t.password,
                    s = t.host,
                    o = t.port,
                    a = t.path,
                    r = t.query,
                    l = t.fragment,
                    c = e + ":";
                return null !== s ? (c += "//", et(t) && (c += i + (n ? ":" + n : "") + "@"), c += h(s), null !== o && (c += ":" + o)) : "file" == e && (c += "//"), c += t.cannotBeABaseURL ? a[0] : a.length ? "/" + a.join("/") : "", null !== r && (c += "?" + r), null !== l && (c += "#" + l), c
            },
            Mt = function() {
                var t = A(this),
                    e = t.scheme,
                    i = t.port;
                if ("blob" == e) try {
                    return new l(e.path[0]).origin
                } catch (t) {
                    return "null"
                }
                return "file" != e && tt(t) ? e + "://" + h(t.host) + (null !== i ? ":" + i : "") : "null"
            },
            Ot = function() {
                return A(this).scheme + ":"
            },
            It = function() {
                return A(this).username
            },
            Dt = function() {
                return A(this).password
            },
            Lt = function() {
                var t = A(this),
                    e = t.host,
                    t = t.port;
                return null === e ? "" : null === t ? h(e) : h(e) + ":" + t
            },
            Pt = function() {
                var t = A(this).host;
                return null === t ? "" : h(t)
            },
            Rt = function() {
                var t = A(this).port;
                return null === t ? "" : String(t)
            },
            Bt = function() {
                var t = A(this),
                    e = t.path;
                return t.cannotBeABaseURL ? e[0] : e.length ? "/" + e.join("/") : ""
            },
            Nt = function() {
                var t = A(this).query;
                return t ? "?" + t : ""
            },
            Ht = function() {
                return A(this).searchParams
            },
            jt = function() {
                var t = A(this).fragment;
                return t ? "#" + t : ""
            },
            _ = function(t, e) {
                return {
                    get: t,
                    set: e,
                    configurable: !0,
                    enumerable: !0
                }
            };
        c && p(i, {
            href: _(At, function(t) {
                var e = A(this),
                    t = String(t),
                    t = r(e, t);
                if (t) throw TypeError(t);
                S(e.searchParams).updateSearchParams(e.query)
            }),
            origin: _(Mt),
            protocol: _(Ot, function(t) {
                var e = A(this);
                r(e, String(t) + ":", rt)
            }),
            username: _(It, function(t) {
                var e = A(this),
                    i = b(String(t));
                if (!s(e)) {
                    e.username = "";
                    for (var n = 0; n < i.length; n++) e.username += G(i[n], Z)
                }
            }),
            password: _(Dt, function(t) {
                var e = A(this),
                    i = b(String(t));
                if (!s(e)) {
                    e.password = "";
                    for (var n = 0; n < i.length; n++) e.password += G(i[n], Z)
                }
            }),
            host: _(Lt, function(t) {
                var e = A(this);
                e.cannotBeABaseURL || r(e, String(t), mt)
            }),
            hostname: _(Pt, function(t) {
                var e = A(this);
                e.cannotBeABaseURL || r(e, String(t), vt)
            }),
            port: _(Rt, function(t) {
                var e = A(this);
                s(e) || ("" == (t = String(t)) ? e.port = null : r(e, t, bt))
            }),
            pathname: _(Bt, function(t) {
                var e = A(this);
                e.cannotBeABaseURL || (e.path = [], r(e, t + "", Ct))
            }),
            search: _(Nt, function(t) {
                var e = A(this);
                "" == (t = String(t)) ? e.query = null: ("?" == t.charAt(0) && (t = t.slice(1)), e.query = "", r(e, t, St)), S(e.searchParams).updateSearchParams(e.query)
            }),
            searchParams: _(Ht),
            hash: _(jt, function(t) {
                var e = A(this);
                "" != (t = String(t)) ? ("#" == t.charAt(0) && (t = t.slice(1)), e.fragment = "", r(e, t, Et)) : e.fragment = null
            })
        }), f(i, "toJSON", function() {
            return At.call(this)
        }, {
            enumerable: !0
        }), f(i, "toString", function() {
            return At.call(this)
        }, {
            enumerable: !0
        }), k && (n = k.createObjectURL, o = k.revokeObjectURL, n && f(l, "createObjectURL", function(t) {
            return n.apply(k, arguments)
        }), o && f(l, "revokeObjectURL", function(t) {
            return o.apply(k, arguments)
        })), w(l, "URL"), a({
            global: !0,
            forced: !d,
            sham: !c
        }, {
            URL: l
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(50).charAt,
            s = i(15),
            i = i(70),
            o = "String Iterator",
            a = s.set,
            r = s.getterFor(o);
        i(String, "String", function(t) {
            a(this, {
                type: o,
                string: String(t),
                index: 0
            })
        }, function() {
            var t = r(this),
                e = t.string,
                i = t.index;
            return i >= e.length ? {
                value: void 0,
                done: !0
            } : (i = n(e, i), t.index += i.length, {
                value: i,
                done: !1
            })
        })
    }, function(t, e, i) {
        "use strict";
        var u = i(10),
            n = i(4),
            p = i(63),
            f = i(59),
            g = i(54),
            _ = i(16),
            m = i(37),
            s = Object.assign,
            o = Object.defineProperty;
        t.exports = !s || n(function() {
            if (u && 1 !== s({
                    b: 1
                }, s(o({}, "a", {
                    enumerable: !0,
                    get: function() {
                        o(this, "b", {
                            value: 3,
                            enumerable: !1
                        })
                    }
                }), {
                    b: 2
                })).b) return !0;
            var t = {},
                e = {},
                i = Symbol(),
                n = "abcdefghijklmnopqrst";
            return t[i] = 7, n.split("").forEach(function(t) {
                e[t] = t
            }), 7 != s({}, t)[i] || p(s({}, e)).join("") != n
        }) ? function(t, e) {
            for (var i = _(t), n = arguments.length, s = 1, o = f.f, a = g.f; s < n;)
                for (var r, l = m(arguments[s++]), c = o ? p(l).concat(o(l)) : p(l), h = c.length, d = 0; d < h;) r = c[d++], u && !a.call(l, r) || (i[r] = l[r]);
            return i
        } : s
    }, function(t, e, i) {
        "use strict";
        var p = i(33),
            f = i(16),
            g = i(122),
            _ = i(76),
            m = i(19),
            v = i(123),
            b = i(34);
        t.exports = function(t) {
            var e, i, n, s, o, a, r = f(t),
                l = "function" == typeof this ? this : Array,
                c = arguments.length,
                h = 1 < c ? arguments[1] : void 0,
                d = void 0 !== h,
                t = b(r),
                u = 0;
            if (d && (h = p(h, 2 < c ? arguments[2] : void 0, 2)), null == t || l == Array && _(t))
                for (i = new l(e = m(r.length)); u < e; u++) a = d ? h(r[u], u) : r[u], v(i, u, a);
            else
                for (o = (s = t.call(r)).next, i = new l; !(n = o.call(s)).done; u++) a = d ? g(s, h, [n.value, u], !0) : n.value, v(i, u, a);
            return i.length = u, i
        }
    }, function(t, e, i) {
        var s = i(6),
            o = i(78);
        t.exports = function(e, t, i, n) {
            try {
                return n ? t(s(i)[0], i[1]) : t(i)
            } catch (t) {
                throw o(e), t
            }
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(38),
            s = i(13),
            o = i(23);
        t.exports = function(t, e, i) {
            e = n(e);
            e in t ? s.f(t, e, o(0, i)) : t[e] = i
        }
    }, function(t, e, i) {
        "use strict";

        function m(t) {
            return t + 22 + 75 * (t < 26)
        }

        function o(t) {
            var e, i = [],
                n = (t = function(t) {
                    for (var e = [], i = 0, n = t.length; i < n;) {
                        var s, o = t.charCodeAt(i++);
                        55296 <= o && o <= 56319 && i < n ? 56320 == (64512 & (s = t.charCodeAt(i++))) ? e.push(((1023 & o) << 10) + (1023 & s) + 65536) : (e.push(o), i--) : e.push(o)
                    }
                    return e
                }(t)).length,
                s = 128,
                o = 0,
                a = 72;
            for (h = 0; h < t.length; h++)(e = t[h]) < 128 && i.push(S(e));
            var r = i.length,
                l = r;
            for (r && i.push("-"); l < n;) {
                for (var c = v, h = 0; h < t.length; h++) s <= (e = t[h]) && e < c && (c = e);
                var d = l + 1;
                if (c - s > T((v - o) / d)) throw RangeError(C);
                for (o += (c - s) * d, s = c, h = 0; h < t.length; h++) {
                    if ((e = t[h]) < s && ++o > v) throw RangeError(C);
                    if (e == s) {
                        for (var u = o, p = b;; p += b) {
                            var f = p <= a ? 1 : a + y <= p ? y : p - a;
                            if (u < f) break;
                            var g = u - f,
                                _ = b - f;
                            i.push(S(m(f + g % _))), u = T(g / _)
                        }
                        i.push(S(m(u))), a = function(t, e, i) {
                            var n = 0;
                            for (t = i ? T(t / w) : t >> 1, t += T(t / e); k * y >> 1 < t; n += b) t = T(t / k);
                            return T(n + (k + 1) * t / (t + x))
                        }(o, d, l == r), o = 0, ++l
                    }
                }++o, ++s
            }
            return i.join("")
        }
        var v = 2147483647,
            b = 36,
            y = 26,
            x = 38,
            w = 700,
            a = /[^\0-\u007E]/,
            r = /[.\u3002\uFF0E\uFF61]/g,
            C = "Overflow: input needs wider integers to process",
            k = b - 1,
            T = Math.floor,
            S = String.fromCharCode;
        t.exports = function(t) {
            for (var e, i = [], n = t.toLowerCase().replace(r, ".").split("."), s = 0; s < n.length; s++) e = n[s], i.push(a.test(e) ? "xn--" + o(e) : e);
            return i.join(".")
        }
    }, function(t, e, i) {
        "use strict";
        i(0);

        function s(e) {
            try {
                return decodeURIComponent(e)
            } catch (t) {
                return e
            }
        }

        function n(t) {
            return H[t]
        }

        function o(t) {
            return encodeURIComponent(t).replace(N, n)
        }

        function h(t) {
            this.entries.length = 0, j(this.entries, t)
        }

        function c(t, e) {
            if (t < e) throw TypeError("Not enough arguments")
        }

        function d() {
            m(this, d, M);
            var t, e, i, n, s, o, a, r, l = 0 < arguments.length ? arguments[0] : void 0,
                c = [];
            if (I(this, {
                    type: M,
                    entries: c,
                    updateURL: function() {},
                    updateSearchParams: h
                }), void 0 !== l)
                if (w(l))
                    if ("function" == typeof(t = S(l)))
                        for (i = (e = t.call(l)).next; !(o = i.call(e)).done;) {
                            if ((o = (s = (n = T(x(o.value))).next).call(n)).done || (a = s.call(n)).done || !s.call(n).done) throw TypeError("Expected sequence with length 2");
                            c.push({
                                key: o.value + "",
                                value: a.value + ""
                            })
                        } else
                            for (r in l) v(l, r) && c.push({
                                key: r,
                                value: l[r] + ""
                            });
                    else j(c, "string" == typeof l ? "?" === l.charAt(0) ? l.slice(1) : l : l + "")
        }
        var a = i(9),
            r = i(18),
            l = i(83),
            u = i(14),
            p = i(75),
            f = i(28),
            g = i(71),
            _ = i(15),
            m = i(51),
            v = i(7),
            b = i(33),
            y = i(77),
            x = i(6),
            w = i(8),
            C = i(31),
            k = i(23),
            T = i(126),
            S = i(34),
            i = i(5),
            E = r("fetch"),
            A = r("Headers"),
            i = i("iterator"),
            M = "URLSearchParams",
            O = M + "Iterator",
            I = _.set,
            D = _.getterFor(M),
            L = _.getterFor(O),
            P = /\+/g,
            R = Array(4),
            B = function(t) {
                var e, i = t.replace(P, " "),
                    n = 4;
                try {
                    return decodeURIComponent(i)
                } catch (t) {
                    for (; n;) i = i.replace((e = n--, R[e - 1] || (R[e - 1] = RegExp("((?:%[\\da-f]{2}){" + e + "})", "gi"))), s);
                    return i
                }
            },
            N = /[!'()~]|%20/g,
            H = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+"
            },
            j = function(t, e) {
                if (e)
                    for (var i, n = e.split("&"), s = 0; s < n.length;)(i = n[s++]).length && (i = i.split("="), t.push({
                        key: B(i.shift()),
                        value: B(i.join("="))
                    }))
            },
            W = g(function(t, e) {
                I(this, {
                    type: O,
                    iterator: T(D(t).entries),
                    kind: e
                })
            }, "Iterator", function() {
                var t = L(this),
                    e = t.kind,
                    i = t.iterator.next(),
                    t = i.value;
                return i.done || (i.value = "keys" === e ? t.key : "values" === e ? t.value : [t.key, t.value]), i
            }),
            g = d.prototype;
        p(g, {
            append: function(t, e) {
                c(arguments.length, 2);
                var i = D(this);
                i.entries.push({
                    key: t + "",
                    value: e + ""
                }), i.updateURL()
            },
            delete: function(t) {
                c(arguments.length, 1);
                for (var e = D(this), i = e.entries, n = t + "", s = 0; s < i.length;) i[s].key === n ? i.splice(s, 1) : s++;
                e.updateURL()
            },
            get: function(t) {
                c(arguments.length, 1);
                for (var e = D(this).entries, i = t + "", n = 0; n < e.length; n++)
                    if (e[n].key === i) return e[n].value;
                return null
            },
            getAll: function(t) {
                c(arguments.length, 1);
                for (var e = D(this).entries, i = t + "", n = [], s = 0; s < e.length; s++) e[s].key === i && n.push(e[s].value);
                return n
            },
            has: function(t) {
                c(arguments.length, 1);
                for (var e = D(this).entries, i = t + "", n = 0; n < e.length;)
                    if (e[n++].key === i) return !0;
                return !1
            },
            set: function(t, e) {
                c(arguments.length, 1);
                for (var i, n = D(this), s = n.entries, o = !1, a = t + "", r = e + "", l = 0; l < s.length; l++)(i = s[l]).key === a && (o ? s.splice(l--, 1) : (o = !0, i.value = r));
                o || s.push({
                    key: a,
                    value: r
                }), n.updateURL()
            },
            sort: function() {
                for (var t, e, i = D(this), n = i.entries, s = n.slice(), o = n.length = 0; o < s.length; o++) {
                    for (t = s[o], e = 0; e < o; e++)
                        if (n[e].key > t.key) {
                            n.splice(e, 0, t);
                            break
                        }
                    e === o && n.push(t)
                }
                i.updateURL()
            },
            forEach: function(t) {
                for (var e, i = D(this).entries, n = b(t, 1 < arguments.length ? arguments[1] : void 0, 3), s = 0; s < i.length;) n((e = i[s++]).value, e.key, this)
            },
            keys: function() {
                return new W(this, "keys")
            },
            values: function() {
                return new W(this, "values")
            },
            entries: function() {
                return new W(this, "entries")
            }
        }, {
            enumerable: !0
        }), u(g, i, g.entries), u(g, "toString", function() {
            for (var t, e = D(this).entries, i = [], n = 0; n < e.length;) t = e[n++], i.push(o(t.key) + "=" + o(t.value));
            return i.join("&")
        }, {
            enumerable: !0
        }), f(d, M), a({
            global: !0,
            forced: !l
        }, {
            URLSearchParams: d
        }), l || "function" != typeof E || "function" != typeof A || a({
            global: !0,
            enumerable: !0,
            forced: !0
        }, {
            fetch: function(t) {
                var e, i, n = [t];
                return 1 < arguments.length && (w(e = arguments[1]) && (i = e.body, y(i) === M && ((t = e.headers ? new A(e.headers) : new A).has("content-type") || t.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), e = C(e, {
                    body: k(0, String(i)),
                    headers: k(0, t)
                }))), n.push(e)), E.apply(this, n)
            }
        }), t.exports = {
            URLSearchParams: d,
            getState: D
        }
    }, function(t, e, i) {
        var n = i(6),
            s = i(34);
        t.exports = function(t) {
            var e = s(t);
            if ("function" != typeof e) throw TypeError(String(t) + " is not iterable");
            return n(e.call(t))
        }
    }, function(t, e, i) {
        var h = i(22),
            d = i(16),
            u = i(37),
            p = i(19),
            i = function(c) {
                return function(t, e, i, n) {
                    h(e);
                    var s = d(t),
                        o = u(s),
                        a = p(s.length),
                        r = c ? a - 1 : 0,
                        l = c ? -1 : 1;
                    if (i < 2)
                        for (;;) {
                            if (r in o) {
                                n = o[r], r += l;
                                break
                            }
                            if (r += l, c ? r < 0 : a <= r) throw TypeError("Reduce of empty array with no initial value")
                        }
                    for (; c ? 0 <= r : r < a; r += l) r in o && (n = e(n, o[r], r, s));
                    return n
                }
            };
        t.exports = {
            left: i(!1),
            right: i(!0)
        }
    }, function(t, e) {
        function s(t, e) {
            var i = t.length,
                n = o(i / 2);
            return i < 8 ? function(t, e) {
                var i = t.length,
                    n = 1,
                    s, o;
                while (n < i) {
                    o = n;
                    s = t[n];
                    while (o && e(t[o - 1], s) > 0) t[o] = t[--o];
                    if (o !== n++) t[o] = s
                }
                return t
            }(t, e) : function(t, e, i) {
                var n = t.length,
                    s = e.length,
                    o = 0,
                    a = 0,
                    r = [];
                while (o < n || a < s)
                    if (o < n && a < s) r.push(i(t[o], e[a]) <= 0 ? t[o++] : e[a++]);
                    else r.push(o < n ? t[o++] : e[a++]);
                return r
            }(s(t.slice(0, n), e), s(t.slice(n), e), e)
        }
        var o = Math.floor;
        t.exports = s
    }, function(t, e, i) {
        i = i(21).match(/firefox\/(\d+)/i);
        t.exports = !!i && +i[1]
    }, function(t, e, i) {
        i = i(21);
        t.exports = /MSIE|Trident/.test(i)
    }, function(t, e, i) {
        i = i(21).match(/AppleWebKit\/(\d+)\./);
        t.exports = !!i && +i[1]
    }, , , function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "Button", function() {
            return Ut
        }), i.d(e, "Carousel", function() {
            return xi
        }), i.d(e, "Collapse", function() {
            return le
        }), i.d(e, "Offcanvas", function() {
            return We
        }), i.d(e, "Dropdown", function() {
            return Ea
        }), i.d(e, "Input", function() {
            return Xo
        }), i.d(e, "Modal", function() {
            return Cx
        }), i.d(e, "Popover", function() {
            return Ds
        }), i.d(e, "ScrollSpy", function() {
            return $s
        }), i.d(e, "Ripple", function() {
            return Wa
        }), i.d(e, "Tab", function() {
            return vo
        }), i.d(e, "Tooltip", function() {
            return Io
        }), i.d(e, "Range", function() {
            return Ua
        }), i.d(e, "Alert", function() {
            return Vg
        }), i.d(e, "Animate", function() {
            return Ga
        }), i.d(e, "Chart", function() {
            return yf
        }), i.d(e, "Datepicker", function() {
            return sv
        }), i.d(e, "Datatable", function() {
            return Ab
        }), i.d(e, "Lightbox", function() {
            return Of
        }), i.d(e, "Navbar", function() {
            return hm
        }), i.d(e, "Popconfirm", function() {
            return uv
        }), i.d(e, "Rating", function() {
            return Vf
        }), i.d(e, "Sidenav", function() {
            return Eg
        }), i.d(e, "SmoothScroll", function() {
            return s0
        }), i.d(e, "Timepicker", function() {
            return rm
        }), i.d(e, "Toast", function() {
            return h_
        }), i.d(e, "InfiniteScroll", function() {
            return _m
        }), i.d(e, "LazyLoad", function() {
            return Cm
        }), i.d(e, "Stepper", function() {
            return fy
        }), i.d(e, "Sticky", function() {
            return wy
        }), i.d(e, "Select", function() {
            return pb
        }), i.d(e, "Touch", function() {
            return Qy
        }), i.d(e, "PerfectScrollbar", function() {
            return d0
        }), i.d(e, "Loading", function() {
            return m0
        }), i.d(e, "Autocomplete", function() {
            return H0
        }), i.d(e, "Clipboard", function() {
            return Ox
        }), i.d(e, "ChipsInput", function() {
            return Jx
        }), i.d(e, "MultiRangeSlider", function() {
            return cw
        }), i.d(e, "Datetimepicker", function() {
            return Iw
        });
        var n = {};
        i.r(n), i.d(n, "top", function() {
            return wi
        }), i.d(n, "bottom", function() {
            return Ci
        }), i.d(n, "right", function() {
            return ki
        }), i.d(n, "left", function() {
            return Ti
        }), i.d(n, "auto", function() {
            return Si
        }), i.d(n, "basePlacements", function() {
            return Ei
        }), i.d(n, "start", function() {
            return Ai
        }), i.d(n, "end", function() {
            return Mi
        }), i.d(n, "clippingParents", function() {
            return Oi
        }), i.d(n, "viewport", function() {
            return Ii
        }), i.d(n, "popper", function() {
            return Di
        }), i.d(n, "reference", function() {
            return Li
        }), i.d(n, "variationPlacements", function() {
            return Pi
        }), i.d(n, "placements", function() {
            return Ri
        }), i.d(n, "beforeRead", function() {
            return Bi
        }), i.d(n, "read", function() {
            return Ni
        }), i.d(n, "afterRead", function() {
            return Hi
        }), i.d(n, "beforeMain", function() {
            return ji
        }), i.d(n, "main", function() {
            return Wi
        }), i.d(n, "afterMain", function() {
            return Fi
        }), i.d(n, "beforeWrite", function() {
            return Vi
        }), i.d(n, "write", function() {
            return zi
        }), i.d(n, "afterWrite", function() {
            return Yi
        }), i.d(n, "modifierPhases", function() {
            return Xi
        }), i.d(n, "applyStyles", function() {
            return Zi
        }), i.d(n, "arrow", function() {
            return _n
        }), i.d(n, "computeStyles", function() {
            return bn
        }), i.d(n, "eventListeners", function() {
            return xn
        }), i.d(n, "flip", function() {
            return Bn
        }), i.d(n, "hide", function() {
            return jn
        }), i.d(n, "offset", function() {
            return Wn
        }), i.d(n, "popperOffsets", function() {
            return Fn
        }), i.d(n, "preventOverflow", function() {
            return Vn
        }), i.d(n, "popperGenerator", function() {
            return Kn
        }), i.d(n, "detectOverflow", function() {
            return Rn
        }), i.d(n, "createPopperBase", function() {
            return $n
        }), i.d(n, "createPopper", function() {
            return Qn
        }), i.d(n, "createPopperLite", function() {
            return qn
        });
        i(2), i(20), i(17);
        const d = t => {
                for (; t += Math.floor(1e6 * Math.random()), document.getElementById(t););
                return t
            },
            s = t => {
                let e = t.getAttribute("data-mdb-target");
                if (!e || "#" === e) {
                    const i = t.getAttribute("href");
                    e = i && "#" !== i ? i.trim() : null
                }
                return e
            };
        const o = t => {
            t = s(t);
            return t ? document.querySelector(t) : null
        };
        const a = (o, a, r) => {
                Object.keys(r).forEach(t => {
                    var e, i, n = r[t],
                        s = a[t],
                        e = s && ((i = s)[0] || i).nodeType ? "element" : null == (e = s) ? "".concat(e) : {}.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase();
                    if (!new RegExp(n).test(e)) throw new Error("".concat(o.toUpperCase(), ": ") + 'Option "'.concat(t, '" provided type "').concat(e, '" ') + 'but expected type "'.concat(n, '".'))
                })
            },
            r = t => {
                if (!t) return !1;
                if (t.style && t.parentNode && t.parentNode.style) {
                    var e = getComputedStyle(t),
                        t = getComputedStyle(t.parentNode);
                    return "none" !== e.display && "none" !== t.display && "hidden" !== e.visibility
                }
                return !1
            };
        const l = () => {
                var t = window["jQuery"];
                return t && !document.body.hasAttribute("data-mdb-no-jquery") ? t : null
            },
            c = t => {
                "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", t) : t()
            },
            h = "rtl" === document.documentElement.dir,
            y = t => document.createElement(t);
        const u = (() => {
            const n = {};
            let s = 1;
            return {
                set(t, e, i) {
                    void 0 === t[e] && (t[e] = {
                        key: e,
                        id: s
                    }, s++), n[t[e].id] = i
                },
                get(t, e) {
                    if (!t || void 0 === t[e]) return null;
                    t = t[e];
                    return t.key === e ? n[t.id] : null
                },
                delete(t, e) {
                    var i;
                    void 0 === t[e] || (i = t[e]).key === e && (delete n[i.id], delete t[e])
                }
            }
        })();
        var p = {
            setData(t, e, i) {
                u.set(t, e, i)
            },
            getData(t, e) {
                return u.get(t, e)
            },
            removeData(t, e) {
                u.delete(t, e)
            }
        };
        i(12), i(0), i(1);
        const f = l(),
            m = /[^.]*(?=\..*)\.|.*/,
            g = /\..*/,
            _ = /::\d+$/,
            v = {};
        let b = 1;
        const x = {
                mouseenter: "mouseover",
                mouseleave: "mouseout"
            },
            w = ["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"];

        function C(t, e) {
            return e && "".concat(e, "::").concat(b++) || t.uidEvent || b++
        }

        function k(t) {
            var e = C(t);
            return t.uidEvent = e, v[e] = v[e] || {}, v[e]
        }

        function T(i, n, s = null) {
            var o = Object.keys(i);
            for (let t = 0, e = o.length; t < e; t++) {
                var a = i[o[t]];
                if (a.originalHandler === n && a.delegationSelector === s) return a
            }
            return null
        }

        function S(t, e, i) {
            var n = "string" == typeof e,
                i = n ? i : e;
            let s = t.replace(g, "");
            e = x[s];
            return e && (s = e), -1 < w.indexOf(s) || (s = t), [n, i, s]
        }

        function E(t, e, i, n, s) {
            if ("string" == typeof e && t) {
                i || (i = n, n = null);
                var [o, a, r] = S(e, i, n);
                const p = k(t),
                    f = p[r] || (p[r] = {}),
                    g = T(f, a, o ? i : null);
                if (g) g.oneOff = g.oneOff && s;
                else {
                    var l, c, h, d, u, e = C(a, e.replace(m, ""));
                    const _ = o ? (h = t, d = i, u = n, function i(n) {
                        var s = h.querySelectorAll(d);
                        for (let e = n["target"]; e && e !== this; e = e.parentNode)
                            for (let t = s.length; t--;)
                                if (s[t] === e) return n.delegateTarget = e, i.oneOff && M.off(h, n.type, u), u.apply(e, [n]);
                        return null
                    }) : (l = t, c = i, function t(e) {
                        return e.delegateTarget = l, t.oneOff && M.off(l, e.type, c), c.apply(l, [e])
                    });
                    _.delegationSelector = o ? i : null, _.originalHandler = a, _.oneOff = s, _.uidEvent = e, f[e] = _, t.addEventListener(r, _, o)
                }
            }
        }

        function A(t, e, i, n, s) {
            n = T(e[i], n, s);
            n && (t.removeEventListener(i, n, Boolean(s)), delete e[i][n.uidEvent])
        }
        const M = {
                on(t, e, i, n) {
                    E(t, e, i, n, !1)
                },
                one(t, e, i, n) {
                    E(t, e, i, n, !0)
                },
                off(i, n, t, e) {
                    if ("string" == typeof n && i) {
                        const [s, o, a] = S(n, t, e), r = a !== n, l = k(i);
                        e = "." === n.charAt(0);
                        if (void 0 !== o) return l && l[a] ? void A(i, l, a, o, s ? t : null) : void 0;
                        e && Object.keys(l).forEach(t => {
                            ! function(e, i, n, s) {
                                const o = i[n] || {};
                                Object.keys(o).forEach(t => {
                                    -1 < t.indexOf(s) && (t = o[t], A(e, i, n, t.originalHandler, t.delegationSelector))
                                })
                            }(i, l, t, n.slice(1))
                        });
                        const c = l[a] || {};
                        Object.keys(c).forEach(t => {
                            var e = t.replace(_, "");
                            (!r || -1 < n.indexOf(e)) && (t = c[t], A(i, l, a, t.originalHandler, t.delegationSelector))
                        })
                    }
                },
                trigger(t, e, i) {
                    if ("string" != typeof e || !t) return null;
                    var n = e.replace(g, ""),
                        s = e !== n,
                        o = -1 < w.indexOf(n);
                    let a, r = !0,
                        l = !0,
                        c = !1,
                        h = null;
                    return s && f && (a = f.Event(e, i), f(t).trigger(a), r = !a.isPropagationStopped(), l = !a.isImmediatePropagationStopped(), c = a.isDefaultPrevented()), o ? (h = document.createEvent("HTMLEvents"), h.initEvent(n, r, !0)) : h = new CustomEvent(e, {
                        bubbles: r,
                        cancelable: !0
                    }), void 0 !== i && Object.keys(i).forEach(t => {
                        Object.defineProperty(h, t, {
                            get() {
                                return i[t]
                            }
                        })
                    }), c && h.preventDefault(), l && t.dispatchEvent(h), h.defaultPrevented && void 0 !== a && a.preventDefault(), h
                }
            },
            O = {
                on(e, t, i, n) {
                    var s = t.split(" ");
                    for (let t = 0; t < s.length; t++) M.on(e, s[t], i, n)
                },
                off(e, t, i, n) {
                    var s = t.split(" ");
                    for (let t = 0; t < s.length; t++) M.off(e, s[t], i, n)
                }
            };
        var I = M;

        function D(t) {
            return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t)
        }

        function L(t) {
            return t.replace(/[A-Z]/g, t => "-".concat(t.toLowerCase()))
        }
        var P = {
            setDataAttribute(t, e, i) {
                t.setAttribute("data-mdb-".concat(L(e)), i)
            },
            removeDataAttribute(t, e) {
                t.removeAttribute("data-mdb-".concat(L(e)))
            },
            getDataAttributes(t) {
                if (!t) return {};
                const i = { ...t.dataset
                };
                return Object.keys(i).filter(t => t.startsWith("mdb")).forEach(t => {
                    let e = t.replace(/^mdb/, "");
                    e = e.charAt(0).toLowerCase() + e.slice(1, e.length), i[e] = D(i[t])
                }), i
            },
            getDataAttribute(t, e) {
                return D(t.getAttribute("data-mdb-".concat(L(e))))
            },
            offset(t) {
                t = t.getBoundingClientRect();
                return {
                    top: t.top + document.body.scrollTop,
                    left: t.left + document.body.scrollLeft
                }
            },
            position(t) {
                return {
                    top: t.offsetTop,
                    left: t.offsetLeft
                }
            },
            style(t, e) {
                Object.assign(t.style, e)
            },
            toggleClass(t, e) {
                t && (t.classList.contains(e) ? t.classList.remove(e) : t.classList.add(e))
            },
            addClass(t, e) {
                t.classList.contains(e) || t.classList.add(e)
            },
            addStyle(e, i) {
                Object.keys(i).forEach(t => {
                    e.style[t] = i[t]
                })
            },
            removeClass(t, e) {
                t.classList.contains(e) && t.classList.remove(e)
            },
            hasClass(t, e) {
                return t.classList.contains(e)
            }
        };
        var R = {
            closest(t, e) {
                return t.closest(e)
            },
            matches(t, e) {
                return t.matches(e)
            },
            find(t, e = document.documentElement) {
                return [].concat(...Element.prototype.querySelectorAll.call(e, t))
            },
            findOne(t, e = document.documentElement) {
                return Element.prototype.querySelector.call(e, t)
            },
            children(t, e) {
                const i = [].concat(...t.children);
                return i.filter(t => t.matches(e))
            },
            parents(t, e) {
                const i = [];
                let n = t.parentNode;
                for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) this.matches(n, e) && i.push(n), n = n.parentNode;
                return i
            },
            prev(t, e) {
                let i = t.previousElementSibling;
                for (; i;) {
                    if (i.matches(e)) return [i];
                    i = i.previousElementSibling
                }
                return []
            },
            next(t, e) {
                let i = t.nextElementSibling;
                for (; i;) {
                    if (this.matches(i, e)) return [i];
                    i = i.nextElementSibling
                }
                return []
            }
        };
        const B = 1e3,
            N = "transitionend",
            H = e => {
                let i = e.getAttribute("data-mdb-target");
                if (!i || "#" === i) {
                    let t = e.getAttribute("href");
                    if (!t || !t.includes("#") && !t.startsWith(".")) return null;
                    t.includes("#") && !t.startsWith("#") && (t = "#".concat(t.split("#")[1])), i = t && "#" !== t ? t.trim() : null
                }
                return i
            },
            j = t => {
                t = H(t);
                return t && document.querySelector(t) ? t : null
            },
            W = t => {
                t = H(t);
                return t ? document.querySelector(t) : null
            },
            F = t => {
                t.dispatchEvent(new Event(N))
            },
            V = t => !(!t || "object" != typeof t) && void 0 !== (t = void 0 !== t.jquery ? t[0] : t).nodeType,
            z = t => V(t) ? t.jquery ? t[0] : t : "string" == typeof t && 0 < t.length ? document.querySelector(t) : null,
            Y = t => {
                if (!V(t) || 0 === t.getClientRects().length) return !1;
                var e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
                    i = t.closest("details:not([open])");
                if (!i) return e;
                if (i !== t) {
                    t = t.closest("summary");
                    if (t && t.parentNode !== i) return !1;
                    if (null === t) return !1
                }
                return e
            },
            X = t => !t || t.nodeType !== Node.ELEMENT_NODE || (!!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled"))),
            U = t => {
                if (!document.documentElement.attachShadow) return null;
                if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? U(t.parentNode) : null;
                t = t.getRootNode();
                return t instanceof ShadowRoot ? t : null
            },
            K = () => {},
            $ = t => {
                t.offsetHeight
            },
            Q = () => window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null,
            q = [],
            Z = () => "rtl" === document.documentElement.dir;
        var G = n => {
            var t;
            t = () => {
                const t = Q();
                if (t) {
                    const e = n.NAME,
                        i = t.fn[e];
                    t.fn[e] = n.jQueryInterface, t.fn[e].Constructor = n, t.fn[e].noConflict = () => (t.fn[e] = i, n.jQueryInterface)
                }
            }, "loading" === document.readyState ? (q.length || document.addEventListener("DOMContentLoaded", () => {
                for (const t of q) t()
            }), q.push(t)) : t()
        };
        const J = t => {
                "function" == typeof t && t()
            },
            tt = (i, n, t = !0) => {
                if (t) {
                    t = (t => {
                        if (!t) return 0;
                        let {
                            transitionDuration: e,
                            transitionDelay: i
                        } = window.getComputedStyle(t);
                        var n = Number.parseFloat(e),
                            t = Number.parseFloat(i);
                        return n || t ? (e = e.split(",")[0], i = i.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(i)) * B) : 0
                    })(n) + 5;
                    let e = !1;
                    const s = ({
                        target: t
                    }) => {
                        t === n && (e = !0, n.removeEventListener(N, s), J(i))
                    };
                    n.addEventListener(N, s), setTimeout(() => {
                        e || F(n)
                    }, t)
                } else J(i)
            },
            et = (t, e, i, n) => {
                var s = t.length;
                let o = t.indexOf(e);
                return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))])
            },
            it = /[^.]*(?=\..*)\.|.*/,
            nt = /\..*/,
            st = /::\d+$/,
            ot = {};
        let at = 1;
        const rt = {
                mouseenter: "mouseover",
                mouseleave: "mouseout"
            },
            lt = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

        function ct(t, e) {
            return e && "".concat(e, "::").concat(at++) || t.uidEvent || at++
        }

        function ht(t) {
            var e = ct(t);
            return t.uidEvent = e, ot[e] = ot[e] || {}, ot[e]
        }

        function dt(t, e, i = null) {
            return Object.values(t).find(t => t.callable === e && t.delegationSelector === i)
        }

        function ut(t, e, i) {
            var n = "string" == typeof e,
                i = !n && e || i;
            let s = gt(t);
            return lt.has(s) || (s = t), [n, i, s]
        }

        function pt(n, s, o, a, r) {
            if ("string" == typeof s && n) {
                let [t, e, i] = ut(s, o, a);
                var l;
                s in rt && (e = (l = e, function(t) {
                    if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return l.call(this, t)
                }));
                const f = ht(n),
                    g = f[i] || (f[i] = {}),
                    _ = dt(g, e, t ? o : null);
                if (_) _.oneOff = _.oneOff && r;
                else {
                    var c, h, d, u, p, s = ct(e, s.replace(it, ""));
                    const m = t ? (d = n, u = o, p = e, function e(i) {
                        var n = d.querySelectorAll(u);
                        for (let t = i["target"]; t && t !== this; t = t.parentNode)
                            for (const s of n)
                                if (s === t) return mt(i, {
                                    delegateTarget: t
                                }), e.oneOff && _t.off(d, i.type, u, p), p.apply(t, [i])
                    }) : (c = n, h = e, function t(e) {
                        return mt(e, {
                            delegateTarget: c
                        }), t.oneOff && _t.off(c, e.type, h), h.apply(c, [e])
                    });
                    m.delegationSelector = t ? o : null, m.callable = e, m.oneOff = r, m.uidEvent = s, g[s] = m, n.addEventListener(i, m, t)
                }
            }
        }

        function ft(t, e, i, n, s) {
            n = dt(e[i], n, s);
            n && (t.removeEventListener(i, n, Boolean(s)), delete e[i][n.uidEvent])
        }

        function gt(t) {
            return t = t.replace(nt, ""), rt[t] || t
        }
        const _t = {
            on(t, e, i, n) {
                pt(t, e, i, n, !1)
            },
            one(t, e, i, n) {
                pt(t, e, i, n, !0)
            },
            off(t, e, i, n) {
                if ("string" == typeof e && t) {
                    var [s, o, a] = ut(e, i, n), r = a !== e, l = ht(t), c = l[a] || {}, n = e.startsWith(".");
                    if (void 0 !== o) return Object.keys(c).length ? void ft(t, l, a, o, s ? i : null) : void 0;
                    if (n)
                        for (const d of Object.keys(l)) ! function(t, e, i, n) {
                            var s, o = e[i] || {};
                            for (const a of Object.keys(o)) a.includes(n) && ft(t, e, i, (s = o[a]).callable, s.delegationSelector)
                        }(t, l, d, e.slice(1));
                    for (const u of Object.keys(c)) {
                        var h = u.replace(st, "");
                        r && !e.includes(h) || ft(t, l, a, (h = c[u]).callable, h.delegationSelector)
                    }
                }
            },
            trigger(t, e, i) {
                if ("string" != typeof e || !t) return null;
                const n = Q();
                let s = null,
                    o = !0,
                    a = !0,
                    r = !1;
                e !== gt(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), a = !s.isImmediatePropagationStopped(), r = s.isDefaultPrevented());
                let l = new Event(e, {
                    bubbles: o,
                    cancelable: !0
                });
                return l = mt(l, i), r && l.preventDefault(), a && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l
            }
        };

        function mt(e, t) {
            for (const [i, n] of Object.entries(t || {})) try {
                e[i] = n
            } catch (t) {
                Object.defineProperty(e, i, {
                    configurable: !0,
                    get() {
                        return n
                    }
                })
            }
            return e
        }
        var vt = _t;
        const bt = new Map;
        var yt = function(t, e, i) {
                bt.has(t) || bt.set(t, new Map);
                const n = bt.get(t);
                n.has(e) || 0 === n.size ? n.set(e, i) : console.error("Bootstrap doesn't allow more than one instance per element. Bound instance: ".concat(Array.from(n.keys())[0], "."))
            },
            xt = function(t, e) {
                return bt.has(t) && bt.get(t).get(e) || null
            },
            wt = function(t, e) {
                if (bt.has(t)) {
                    const i = bt.get(t);
                    i.delete(e), 0 === i.size && bt.delete(t)
                }
            };

        function Ct(e) {
            if ("true" === e) return !0;
            if ("false" === e) return !1;
            if (e === Number(e).toString()) return Number(e);
            if ("" === e || "null" === e) return null;
            if ("string" != typeof e) return e;
            try {
                return JSON.parse(decodeURIComponent(e))
            } catch (t) {
                return e
            }
        }

        function kt(t) {
            return t.replace(/[A-Z]/g, t => "-".concat(t.toLowerCase()))
        }
        var Tt = {
            setDataAttribute(t, e, i) {
                t.setAttribute("data-mdb-".concat(kt(e)), i)
            },
            removeDataAttribute(t, e) {
                t.removeAttribute("data-mdb-".concat(kt(e)))
            },
            getDataAttributes(e) {
                if (!e) return {};
                const i = {};
                for (const n of Object.keys(e.dataset).filter(t => t.startsWith("mdb") && !t.startsWith("mdbConfig"))) {
                    let t = n.replace(/^mdb/, "");
                    t = t.charAt(0).toLowerCase() + t.slice(1, t.length), i[t] = Ct(e.dataset[n])
                }
                return i
            },
            getDataAttribute(t, e) {
                return Ct(t.getAttribute("data-mdb-".concat(kt(e))))
            }
        };
        var St = class {
            static get Default() {
                return {}
            }
            static get DefaultType() {
                return {}
            }
            static get NAME() {
                throw new Error('You have to implement the static method "NAME", for each component!')
            }
            _getConfig(t) {
                return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
            }
            _configAfterMerge(t) {
                return t
            }
            _mergeConfigObj(t, e) {
                var i = V(e) ? Tt.getDataAttribute(e, "config") : {};
                return { ...this.constructor.Default,
                    ..."object" == typeof i ? i : {},
                    ...V(e) ? Tt.getDataAttributes(e) : {},
                    ..."object" == typeof t ? t : {}
                }
            }
            _typeCheckConfig(t, e = this.constructor.DefaultType) {
                for (const o of Object.keys(e)) {
                    var i = e[o],
                        n = t[o],
                        s = V(n) ? "element" : null == (s = n) ? "".concat(s) : Object.prototype.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase();
                    if (!new RegExp(i).test(s)) throw new TypeError("".concat(this.constructor.NAME.toUpperCase(), ': Option "').concat(o, '" provided type "').concat(s, '" but expected type "').concat(i, '".'))
                }
                var s
            }
        };
        var Et = class extends St {
            constructor(t, e) {
                super(), (t = z(t)) && (this._element = t, this._config = this._getConfig(e), yt(this._element, this.constructor.DATA_KEY, this))
            }
            dispose() {
                wt(this._element, this.constructor.DATA_KEY), vt.off(this._element, this.constructor.EVENT_KEY);
                for (const t of Object.getOwnPropertyNames(this)) this[t] = null
            }
            _queueCallback(t, e, i = !0) {
                tt(t, e, i)
            }
            _getConfig(t) {
                return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
            }
            static getInstance(t) {
                return xt(z(t), this.DATA_KEY)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static get VERSION() {
                return "5.2.2"
            }
            static get DATA_KEY() {
                return "bs.".concat(this.NAME)
            }
            static get EVENT_KEY() {
                return ".".concat(this.DATA_KEY)
            }
            static eventName(t) {
                return "".concat(t).concat(this.EVENT_KEY)
            }
        };
        var At = ".".concat("bs.button");
        const Mt = '[data-mdb-toggle="button"]';
        var Ot = "click".concat(At).concat(".data-api");
        class It extends Et {
            static get NAME() {
                return "button"
            }
            toggle() {
                this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = It.getOrCreateInstance(this);
                    "toggle" === e && t[e]()
                })
            }
        }
        vt.on(document, Ot, Mt, t => {
            t.preventDefault();
            t = t.target.closest(Mt);
            const e = It.getOrCreateInstance(t);
            e.toggle()
        }), G(It);
        var Dt = It;
        const Lt = "button",
            Pt = "mdb.".concat(Lt);
        var Rt = ".".concat(Pt);
        const Bt = "click".concat(Rt),
            Nt = "transitionend",
            Ht = "mouseenter",
            jt = "mouseleave",
            Wt = "hide".concat(Rt),
            Ft = "hidden".concat(Rt),
            Vt = "show".concat(Rt),
            zt = "shown".concat(Rt),
            Yt = "fixed-action-btn";
        class Xt extends Dt {
            constructor(t) {
                super(t), this._fn = {}, this._element && (p.setData(this._element, Pt, this), this._init())
            }
            static get NAME() {
                return Lt
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Pt);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Xt(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            get _actionButton() {
                return R.findOne(".fixed-action-btn:not(.smooth-scroll) > .btn-floating", this._element)
            }
            get _buttonListElements() {
                return R.find("ul .btn", this._element)
            }
            get _buttonList() {
                return R.findOne("ul", this._element)
            }
            get _isTouchDevice() {
                return "ontouchstart" in document.documentElement
            }
            show() {
                P.hasClass(this._element, Yt) && (I.off(this._buttonList, Nt), I.trigger(this._element, Vt), this._bindListOpenTransitionEnd(), P.addStyle(this._element, {
                    height: "".concat(this._fullContainerHeight, "px")
                }), this._toggleVisibility(!0))
            }
            hide() {
                P.hasClass(this._element, Yt) && (I.off(this._buttonList, Nt), I.trigger(this._element, Wt), this._bindListHideTransitionEnd(), this._toggleVisibility(!1))
            }
            dispose() {
                P.hasClass(this._element, Yt) && (I.off(this._actionButton, Bt), this._actionButton.removeEventListener(Ht, this._fn.mouseenter), this._element.removeEventListener(jt, this._fn.mouseleave)), super.dispose()
            }
            _init() {
                P.hasClass(this._element, Yt) && (this._saveInitialHeights(), this._setInitialStyles(), this._bindInitialEvents())
            }
            _bindMouseEnter() {
                this._actionButton.addEventListener(Ht, this._fn.mouseenter = () => {
                    this._isTouchDevice || this.show()
                })
            }
            _bindMouseLeave() {
                this._element.addEventListener(jt, this._fn.mouseleave = () => {
                    this.hide()
                })
            }
            _bindClick() {
                I.on(this._actionButton, Bt, () => {
                    P.hasClass(this._element, "active") ? this.hide() : this.show()
                })
            }
            _bindListHideTransitionEnd() {
                I.on(this._buttonList, Nt, t => {
                    "transform" === t.propertyName && (I.off(this._buttonList, Nt), this._element.style.height = "".concat(this._initialContainerHeight, "px"), I.trigger(this._element, Ft))
                })
            }
            _bindListOpenTransitionEnd() {
                I.on(this._buttonList, Nt, t => {
                    "transform" === t.propertyName && (I.off(this._buttonList, Nt), I.trigger(this._element, zt))
                })
            }
            _toggleVisibility(t) {
                const e = t ? "addClass" : "removeClass";
                t = t ? "translate(0)" : "translateY(".concat(this._fullContainerHeight, "px)");
                P.addStyle(this._buttonList, {
                    transform: t
                }), this._buttonListElements && this._buttonListElements.forEach(t => P[e](t, "shown")), P[e](this._element, "active")
            }
            _getHeight(t) {
                const e = window.getComputedStyle(t);
                return parseFloat(e.getPropertyValue("height"))
            }
            _saveInitialHeights() {
                this._initialContainerHeight = this._getHeight(this._element), this._initialListHeight = this._getHeight(this._buttonList), this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight
            }
            _bindInitialEvents() {
                this._bindClick(), this._bindMouseEnter(), this._bindMouseLeave()
            }
            _setInitialStyles() {
                this._buttonList.style.marginBottom = "".concat(this._initialContainerHeight, "px"), this._buttonList.style.transform = "translateY(".concat(this._fullContainerHeight, "px)"), this._element.style.height = "".concat(this._initialContainerHeight, "px")
            }
        }
        R.find(".fixed-action-btn").forEach(t => {
            let e = Xt.getInstance(t);
            return e = e || new Xt(t), e
        }), R.find('[data-mdb-toggle="button"]').forEach(t => {
            let e = Xt.getInstance(t);
            return e = e || new Xt(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Lt];
                t.fn[Lt] = Xt.jQueryInterface, t.fn[Lt].Constructor = Xt, t.fn[Lt].noConflict = () => (t.fn[Lt] = e, Xt.jQueryInterface)
            }
        });
        var Ut = Xt,
            Kt = {
                find(t, e = document.documentElement) {
                    return [].concat(...Element.prototype.querySelectorAll.call(e, t))
                },
                findOne(t, e = document.documentElement) {
                    return Element.prototype.querySelector.call(e, t)
                },
                children(t, e) {
                    return [].concat(...t.children).filter(t => t.matches(e))
                },
                parents(t, e) {
                    const i = [];
                    let n = t.parentNode.closest(e);
                    for (; n;) i.push(n), n = n.parentNode.closest(e);
                    return i
                },
                prev(t, e) {
                    let i = t.previousElementSibling;
                    for (; i;) {
                        if (i.matches(e)) return [i];
                        i = i.previousElementSibling
                    }
                    return []
                },
                next(t, e) {
                    let i = t.nextElementSibling;
                    for (; i;) {
                        if (i.matches(e)) return [i];
                        i = i.nextElementSibling
                    }
                    return []
                },
                focusableChildren(t) {
                    var e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(t => "".concat(t, ':not([tabindex^="-"])')).join(",");
                    return this.find(e, t).filter(t => !X(t) && Y(t))
                }
            };
        var $t = ".".concat("bs.collapse");
        const Qt = "show".concat($t),
            qt = "shown".concat($t),
            Zt = "hide".concat($t),
            Gt = "hidden".concat($t);
        var Jt = "click".concat($t).concat(".data-api");
        const te = "show",
            ee = "collapse",
            ie = "collapsing",
            ne = ":scope .".concat(ee, " .").concat(ee),
            se = '[data-mdb-toggle="collapse"]',
            oe = {
                parent: null,
                toggle: !0
            },
            ae = {
                parent: "(null|element)",
                toggle: "boolean"
            };
        class re extends Et {
            constructor(t, e) {
                super(t, e), this._isTransitioning = !1, this._triggerArray = [];
                for (const s of Kt.find(se)) {
                    var i = j(s),
                        n = Kt.find(i).filter(t => t === this._element);
                    null !== i && n.length && this._triggerArray.push(s)
                }
                this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
            }
            static get Default() {
                return oe
            }
            static get DefaultType() {
                return ae
            }
            static get NAME() {
                return "collapse"
            }
            toggle() {
                this._isShown() ? this.hide() : this.show()
            }
            show() {
                if (!this._isTransitioning && !this._isShown()) {
                    let t = [];
                    if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(t => t !== this._element).map(t => re.getOrCreateInstance(t, {
                            toggle: !1
                        }))), !t.length || !t[0]._isTransitioning)
                        if (!vt.trigger(this._element, Qt).defaultPrevented) {
                            for (const n of t) n.hide();
                            const i = this._getDimension();
                            this._element.classList.remove(ee), this._element.classList.add(ie), this._element.style[i] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
                            var e = i[0].toUpperCase() + i.slice(1),
                                e = "scroll".concat(e);
                            this._queueCallback(() => {
                                this._isTransitioning = !1, this._element.classList.remove(ie), this._element.classList.add(ee, te), this._element.style[i] = "", vt.trigger(this._element, qt)
                            }, this._element, !0), this._element.style[i] = "".concat(this._element[e], "px")
                        }
                }
            }
            hide() {
                if (!this._isTransitioning && this._isShown() && !vt.trigger(this._element, Zt).defaultPrevented) {
                    var t = this._getDimension();
                    this._element.style[t] = "".concat(this._element.getBoundingClientRect()[t], "px"), $(this._element), this._element.classList.add(ie), this._element.classList.remove(ee, te);
                    for (const i of this._triggerArray) {
                        var e = W(i);
                        e && !this._isShown(e) && this._addAriaAndCollapsedClass([i], !1)
                    }
                    this._isTransitioning = !0;
                    this._element.style[t] = "", this._queueCallback(() => {
                        this._isTransitioning = !1, this._element.classList.remove(ie), this._element.classList.add(ee), vt.trigger(this._element, Gt)
                    }, this._element, !0)
                }
            }
            _isShown(t = this._element) {
                return t.classList.contains(te)
            }
            _configAfterMerge(t) {
                return t.toggle = Boolean(t.toggle), t.parent = z(t.parent), t
            }
            _getDimension() {
                return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
            }
            _initializeChildren() {
                if (this._config.parent)
                    for (const e of this._getFirstLevelChildren(se)) {
                        var t = W(e);
                        t && this._addAriaAndCollapsedClass([e], this._isShown(t))
                    }
            }
            _getFirstLevelChildren(t) {
                const e = Kt.find(ne, this._config.parent);
                return Kt.find(t, this._config.parent).filter(t => !e.includes(t))
            }
            _addAriaAndCollapsedClass(t, e) {
                if (t.length)
                    for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e)
            }
            static jQueryInterface(e) {
                const i = {};
                return "string" == typeof e && /show|hide/.test(e) && (i.toggle = !1), this.each(function() {
                    const t = re.getOrCreateInstance(this, i);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
        }
        vt.on(document, Jt, se, function(t) {
            ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
            t = j(this);
            for (const e of Kt.find(t)) re.getOrCreateInstance(e, {
                toggle: !1
            }).toggle()
        }), G(re);
        var le = re;
        const ce = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
            he = ".sticky-top",
            de = "padding-right",
            ue = "margin-right";
        var pe = class {
            constructor() {
                this._element = document.body
            }
            getWidth() {
                var t = document.documentElement.clientWidth;
                return Math.abs(window.innerWidth - t)
            }
            hide() {
                const e = this.getWidth();
                this._disableOverFlow(), this._setElementAttributes(this._element, de, t => t + e), this._setElementAttributes(ce, de, t => t + e), this._setElementAttributes(he, ue, t => t - e)
            }
            reset() {
                this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, de), this._resetElementAttributes(ce, de), this._resetElementAttributes(he, ue)
            }
            isOverflowing() {
                return 0 < this.getWidth()
            }
            _disableOverFlow() {
                this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
            }
            _setElementAttributes(t, i, n) {
                const s = this.getWidth();
                this._applyManipulationCallback(t, t => {
                    var e;
                    t !== this._element && window.innerWidth > t.clientWidth + s || (this._saveInitialAttribute(t, i), e = window.getComputedStyle(t).getPropertyValue(i), t.style.setProperty(i, "".concat(n(Number.parseFloat(e)), "px")))
                })
            }
            _saveInitialAttribute(t, e) {
                var i = t.style.getPropertyValue(e);
                i && Tt.setDataAttribute(t, e, i)
            }
            _resetElementAttributes(t, i) {
                this._applyManipulationCallback(t, t => {
                    var e = Tt.getDataAttribute(t, i);
                    null !== e ? (Tt.removeDataAttribute(t, i), t.style.setProperty(i, e)) : t.style.removeProperty(i)
                })
            }
            _applyManipulationCallback(t, e) {
                if (V(t)) e(t);
                else
                    for (const i of Kt.find(t, this._element)) e(i)
            }
        };
        const fe = "backdrop",
            ge = "mousedown.bs.".concat(fe),
            _e = {
                className: "modal-backdrop",
                clickCallback: null,
                isAnimated: !1,
                isVisible: !0,
                rootElement: "body"
            },
            me = {
                className: "string",
                clickCallback: "(function|null)",
                isAnimated: "boolean",
                isVisible: "boolean",
                rootElement: "(element|string)"
            };
        var ve = class extends St {
            constructor(t) {
                super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null
            }
            static get Default() {
                return _e
            }
            static get DefaultType() {
                return me
            }
            static get NAME() {
                return fe
            }
            show(t) {
                if (this._config.isVisible) {
                    this._append();
                    const e = this._getElement();
                    this._config.isAnimated && $(e), e.classList.add("show"), this._emulateAnimation(() => {
                        J(t)
                    })
                } else J(t)
            }
            hide(t) {
                this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
                    this.dispose(), J(t)
                })) : J(t)
            }
            dispose() {
                this._isAppended && (vt.off(this._element, ge), this._element.remove(), this._isAppended = !1)
            }
            _getElement() {
                if (!this._element) {
                    const t = document.createElement("div");
                    t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t
                }
                return this._element
            }
            _configAfterMerge(t) {
                return t.rootElement = z(t.rootElement), t
            }
            _append() {
                var t;
                this._isAppended || (t = this._getElement(), this._config.rootElement.append(t), vt.on(t, ge, () => {
                    J(this._config.clickCallback)
                }), this._isAppended = !0)
            }
            _emulateAnimation(t) {
                tt(t, this._getElement(), this._config.isAnimated)
            }
        };
        const be = ".".concat("bs.focustrap"),
            ye = "focusin".concat(be),
            xe = "keydown.tab".concat(be),
            we = "backward",
            Ce = {
                autofocus: !0,
                trapElement: null
            },
            ke = {
                autofocus: "boolean",
                trapElement: "element"
            };
        var Te = class extends St {
                constructor(t) {
                    super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null
                }
                static get Default() {
                    return Ce
                }
                static get DefaultType() {
                    return ke
                }
                static get NAME() {
                    return "focustrap"
                }
                activate() {
                    this._isActive || (this._config.autofocus && this._config.trapElement.focus(), vt.off(document, be), vt.on(document, ye, t => this._handleFocusin(t)), vt.on(document, xe, t => this._handleKeydown(t)), this._isActive = !0)
                }
                deactivate() {
                    this._isActive && (this._isActive = !1, vt.off(document, be))
                }
                _handleFocusin(t) {
                    const e = this._config["trapElement"];
                    if (t.target !== document && t.target !== e && !e.contains(t.target)) {
                        const i = Kt.focusableChildren(e);
                        (0 === i.length ? e : this._lastTabNavDirection === we ? i[i.length - 1] : i[0]).focus()
                    }
                }
                _handleKeydown(t) {
                    "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? we : "forward")
                }
            },
            Se = (i, n = "hide") => {
                var t = "click.dismiss".concat(i.EVENT_KEY);
                const s = i.NAME;
                vt.on(document, t, '[data-mdb-dismiss="'.concat(s, '"]'), function(t) {
                    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), !X(this)) {
                        t = W(this) || this.closest(".".concat(s));
                        const e = i.getOrCreateInstance(t);
                        e[n]()
                    }
                })
            };
        var Ee = ".".concat("bs.offcanvas"),
            Ae = ".data-api",
            e = "load".concat(Ee).concat(Ae);
        const Me = "showing",
            Oe = ".offcanvas.show",
            Ie = "show".concat(Ee),
            De = "shown".concat(Ee),
            Le = "hide".concat(Ee),
            Pe = "hidePrevented".concat(Ee),
            Re = "hidden".concat(Ee);
        At = "resize".concat(Ee), Ot = "click".concat(Ee).concat(Ae);
        const Be = "keydown.dismiss".concat(Ee);
        const Ne = {
                backdrop: !0,
                keyboard: !0,
                scroll: !1
            },
            He = {
                backdrop: "(boolean|string)",
                keyboard: "boolean",
                scroll: "boolean"
            };
        class je extends Et {
            constructor(t, e) {
                super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
            }
            static get Default() {
                return Ne
            }
            static get DefaultType() {
                return He
            }
            static get NAME() {
                return "offcanvas"
            }
            toggle(t) {
                return this._isShown ? this.hide() : this.show(t)
            }
            show(t) {
                this._isShown || vt.trigger(this._element, Ie, {
                    relatedTarget: t
                }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new pe).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Me), this._queueCallback(() => {
                    this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add("show"), this._element.classList.remove(Me), vt.trigger(this._element, De, {
                        relatedTarget: t
                    })
                }, this._element, !0))
            }
            hide() {
                this._isShown && (vt.trigger(this._element, Le).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add("hiding"), this._backdrop.hide(), this._queueCallback(() => {
                    this._element.classList.remove("show", "hiding"), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new pe).reset(), vt.trigger(this._element, Re)
                }, this._element, !0)))
            }
            dispose() {
                this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
            }
            _initializeBackDrop() {
                var t = Boolean(this._config.backdrop);
                return new ve({
                    className: "offcanvas-backdrop",
                    isVisible: t,
                    isAnimated: !0,
                    rootElement: this._element.parentNode,
                    clickCallback: t ? () => {
                        "static" !== this._config.backdrop ? this.hide() : vt.trigger(this._element, Pe)
                    } : null
                })
            }
            _initializeFocusTrap() {
                return new Te({
                    trapElement: this._element
                })
            }
            _addEventListeners() {
                vt.on(this._element, Be, t => {
                    "Escape" === t.key && (this._config.keyboard ? this.hide() : vt.trigger(this._element, Pe))
                })
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = je.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e](this)
                    }
                })
            }
        }
        vt.on(document, Ot, '[data-mdb-toggle="offcanvas"]', function(t) {
            var e = W(this);
            if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), !X(this)) {
                vt.one(e, Re, () => {
                    Y(this) && this.focus()
                });
                t = Kt.findOne(Oe);
                t && t !== e && je.getInstance(t).hide();
                const i = je.getOrCreateInstance(e);
                i.toggle(this)
            }
        }), vt.on(window, e, () => {
            for (const t of Kt.find(Oe)) je.getOrCreateInstance(t).show()
        }), vt.on(window, At, () => {
            for (const t of Kt.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && je.getOrCreateInstance(t).hide()
        }), Se(je), G(je);
        var We = je;
        const Fe = ".bs.swipe",
            Ve = "touchstart".concat(Fe),
            ze = "touchmove".concat(Fe),
            Ye = "touchend".concat(Fe),
            Xe = "pointerdown".concat(Fe),
            Ue = "pointerup".concat(Fe),
            Ke = {
                endCallback: null,
                leftCallback: null,
                rightCallback: null
            },
            $e = {
                endCallback: "(function|null)",
                leftCallback: "(function|null)",
                rightCallback: "(function|null)"
            };
        class Qe extends St {
            constructor(t, e) {
                super(), (this._element = t) && Qe.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
            }
            static get Default() {
                return Ke
            }
            static get DefaultType() {
                return $e
            }
            static get NAME() {
                return "swipe"
            }
            dispose() {
                vt.off(this._element, Fe)
            }
            _start(t) {
                this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
            }
            _end(t) {
                this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), J(this._config.endCallback)
            }
            _move(t) {
                this._deltaX = t.touches && 1 < t.touches.length ? 0 : t.touches[0].clientX - this._deltaX
            }
            _handleSwipe() {
                var t = Math.abs(this._deltaX);
                t <= 40 || (t = t / this._deltaX, this._deltaX = 0, t && J(0 < t ? this._config.rightCallback : this._config.leftCallback))
            }
            _initEvents() {
                this._supportPointerEvents ? (vt.on(this._element, Xe, t => this._start(t)), vt.on(this._element, Ue, t => this._end(t)), this._element.classList.add("pointer-event")) : (vt.on(this._element, Ve, t => this._start(t)), vt.on(this._element, ze, t => this._move(t)), vt.on(this._element, Ye, t => this._end(t)))
            }
            _eventIsPointerPenTouch(t) {
                return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
            }
            static isSupported() {
                return "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints
            }
        }
        var qe = Qe;
        Rt = ".".concat("bs.carousel"), Dt = ".data-api";
        const Ze = "next",
            Ge = "prev",
            Je = "left",
            ti = "right",
            ei = "slide".concat(Rt),
            ii = "slid".concat(Rt),
            ni = "keydown".concat(Rt),
            si = "mouseenter".concat(Rt),
            oi = "mouseleave".concat(Rt),
            ai = "dragstart".concat(Rt);
        $t = "load".concat(Rt).concat(Dt), Jt = "click".concat(Rt).concat(Dt);
        const ri = "carousel",
            li = "active",
            ci = ".active",
            hi = ".carousel-item";
        ci, hi;
        const di = {
                ArrowLeft: ti,
                ArrowRight: Je
            },
            ui = {
                interval: 5e3,
                keyboard: !0,
                pause: "hover",
                ride: !1,
                touch: !0,
                wrap: !0
            },
            pi = {
                interval: "(number|boolean)",
                keyboard: "boolean",
                pause: "(string|boolean)",
                ride: "(boolean|string)",
                touch: "boolean",
                wrap: "boolean"
            };
        class fi extends Et {
            constructor(t, e) {
                super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Kt.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === ri && this.cycle()
            }
            static get Default() {
                return ui
            }
            static get DefaultType() {
                return pi
            }
            static get NAME() {
                return "carousel"
            }
            next() {
                this._slide(Ze)
            }
            nextWhenVisible() {
                !document.hidden && Y(this._element) && this.next()
            }
            prev() {
                this._slide(Ge)
            }
            pause() {
                this._isSliding && F(this._element), this._clearInterval()
            }
            cycle() {
                this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval)
            }
            _maybeEnableCycle() {
                this._config.ride && (this._isSliding ? vt.one(this._element, ii, () => this.cycle()) : this.cycle())
            }
            to(t) {
                var e, i = this._getItems();
                t > i.length - 1 || t < 0 || (this._isSliding ? vt.one(this._element, ii, () => this.to(t)) : (e = this._getItemIndex(this._getActive())) !== t && (e = e < t ? Ze : Ge, this._slide(e, i[t])))
            }
            dispose() {
                this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
            }
            _configAfterMerge(t) {
                return t.defaultInterval = t.interval, t
            }
            _addEventListeners() {
                this._config.keyboard && vt.on(this._element, ni, t => this._keydown(t)), "hover" === this._config.pause && (vt.on(this._element, si, () => this.pause()), vt.on(this._element, oi, () => this._maybeEnableCycle())), this._config.touch && qe.isSupported() && this._addTouchEventListeners()
            }
            _addTouchEventListeners() {
                for (const e of Kt.find(".carousel-item img", this._element)) vt.on(e, ai, t => t.preventDefault());
                var t = {
                    leftCallback: () => this._slide(this._directionToOrder(Je)),
                    rightCallback: () => this._slide(this._directionToOrder(ti)),
                    endCallback: () => {
                        "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval))
                    }
                };
                this._swipeHelper = new qe(this._element, t)
            }
            _keydown(t) {
                var e;
                /input|textarea/i.test(t.target.tagName) || (e = di[t.key]) && (t.preventDefault(), this._slide(this._directionToOrder(e)))
            }
            _getItemIndex(t) {
                return this._getItems().indexOf(t)
            }
            _setActiveIndicatorElement(t) {
                if (this._indicatorsElement) {
                    const e = Kt.findOne(ci, this._indicatorsElement);
                    e.classList.remove(li), e.removeAttribute("aria-current");
                    const i = Kt.findOne('[data-mdb-slide-to="'.concat(t, '"]'), this._indicatorsElement);
                    i && (i.classList.add(li), i.setAttribute("aria-current", "true"))
                }
            }
            _updateInterval() {
                const t = this._activeElement || this._getActive();
                var e;
                t && (e = Number.parseInt(t.getAttribute("data-mdb-interval"), 10), this._config.interval = e || this._config.defaultInterval)
            }
            _slide(e, t = null) {
                if (!this._isSliding) {
                    const n = this._getActive();
                    var i = e === Ze;
                    const s = t || et(this._getItems(), n, i, this._config.wrap);
                    if (s !== n) {
                        const o = this._getItemIndex(s),
                            a = t => vt.trigger(this._element, t, {
                                relatedTarget: s,
                                direction: this._orderToDirection(e),
                                from: this._getItemIndex(n),
                                to: o
                            });
                        t = a(ei);
                        if (!t.defaultPrevented && n && s) {
                            t = Boolean(this._interval);
                            this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
                            const r = i ? "carousel-item-start" : "carousel-item-end",
                                l = i ? "carousel-item-next" : "carousel-item-prev";
                            s.classList.add(l), $(s), n.classList.add(r), s.classList.add(r);
                            this._queueCallback(() => {
                                s.classList.remove(r, l), s.classList.add(li), n.classList.remove(li, l, r), this._isSliding = !1, a(ii)
                            }, n, this._isAnimated()), t && this.cycle()
                        }
                    }
                }
            }
            _isAnimated() {
                return this._element.classList.contains("slide")
            }
            _getActive() {
                return Kt.findOne(".active.carousel-item", this._element)
            }
            _getItems() {
                return Kt.find(hi, this._element)
            }
            _clearInterval() {
                this._interval && (clearInterval(this._interval), this._interval = null)
            }
            _directionToOrder(t) {
                return Z() ? t === Je ? Ge : Ze : t === Je ? Ze : Ge
            }
            _orderToDirection(t) {
                return Z() ? t === Ge ? Je : ti : t === Ge ? ti : Je
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = fi.getOrCreateInstance(this, e);
                    if ("number" != typeof e) {
                        if ("string" == typeof e) {
                            if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError('No method named "'.concat(e, '"'));
                            t[e]()
                        }
                    } else t.to(e)
                })
            }
        }
        vt.on(document, Jt, "[data-mdb-slide], [data-mdb-slide-to]", function(t) {
            const e = W(this);
            if (e && e.classList.contains(ri)) {
                t.preventDefault();
                const i = fi.getOrCreateInstance(e);
                t = this.getAttribute("data-mdb-slide-to");
                return t ? (i.to(t), void i._maybeEnableCycle()) : ("next" === Tt.getDataAttribute(this, "slide") ? i.next() : i.prev(), void i._maybeEnableCycle())
            }
        }), vt.on(window, $t, () => {
            for (const t of Kt.find('[data-mdb-ride="carousel"]')) fi.getOrCreateInstance(t)
        }), G(fi);
        Ae = fi;
        const gi = "carousel";
        Ee = "mdb.".concat(gi), Ot = ".".concat(Ee);
        const _i = "slide.bs.carousel",
            mi = "slid.bs.carousel",
            vi = "slide".concat(Ot),
            bi = "slid".concat(Ot);
        class yi extends Ae {
            constructor(t, e) {
                super(t, e), this._init()
            }
            dispose() {
                I.off(this._element, _i), I.off(this._element, mi), super.dispose()
            }
            static get NAME() {
                return gi
            }
            _init() {
                this._bindSlideEvent(), this._bindSlidEvent()
            }
            _bindSlideEvent() {
                I.on(this._element, _i, t => {
                    I.trigger(this._element, vi, {
                        relatedTarget: t.relatedTarget,
                        direction: t.direction,
                        from: t.from,
                        to: t.to
                    })
                })
            }
            _bindSlidEvent() {
                I.on(this._element, mi, t => {
                    I.trigger(this._element, bi, {
                        relatedTarget: t.relatedTarget,
                        direction: t.direction,
                        from: t.from,
                        to: t.to
                    })
                })
            }
        }
        R.find('[data-mdb-ride="carousel"]').forEach(t => {
            var e = yi.getInstance(t);
            e || new yi(t, P.getDataAttributes(t))
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[gi];
                t.fn[gi] = yi.jQueryInterface, t.fn[gi].Constructor = yi, t.fn[gi].noConflict = () => (t.fn[gi] = e, yi.jQueryInterface)
            }
        });
        var xi = yi,
            wi = "top",
            Ci = "bottom",
            ki = "right",
            Ti = "left",
            Si = "auto",
            Ei = [wi, Ci, ki, Ti],
            Ai = "start",
            Mi = "end",
            Oi = "clippingParents",
            Ii = "viewport",
            Di = "popper",
            Li = "reference",
            Pi = Ei.reduce(function(t, e) {
                return t.concat([e + "-" + Ai, e + "-" + Mi])
            }, []),
            Ri = [].concat(Ei, [Si]).reduce(function(t, e) {
                return t.concat([e, e + "-" + Ai, e + "-" + Mi])
            }, []),
            Bi = "beforeRead",
            Ni = "read",
            Hi = "afterRead",
            ji = "beforeMain",
            Wi = "main",
            Fi = "afterMain",
            Vi = "beforeWrite",
            zi = "write",
            Yi = "afterWrite",
            Xi = [Bi, Ni, Hi, ji, Wi, Fi, Vi, zi, Yi];

        function Ui(t) {
            return t ? (t.nodeName || "").toLowerCase() : null
        }

        function Ki(t) {
            if (null == t) return window;
            if ("[object Window]" === t.toString()) return t;
            t = t.ownerDocument;
            return t && t.defaultView || window
        }

        function $i(t) {
            return t instanceof Ki(t).Element || t instanceof Element
        }

        function Qi(t) {
            return t instanceof Ki(t).HTMLElement || t instanceof HTMLElement
        }

        function qi(t) {
            return "undefined" != typeof ShadowRoot && (t instanceof Ki(t).ShadowRoot || t instanceof ShadowRoot)
        }
        var Zi = {
            name: "applyStyles",
            enabled: !0,
            phase: "write",
            fn: function(t) {
                var s = t.state;
                Object.keys(s.elements).forEach(function(t) {
                    var e = s.styles[t] || {},
                        i = s.attributes[t] || {},
                        n = s.elements[t];
                    Qi(n) && Ui(n) && (Object.assign(n.style, e), Object.keys(i).forEach(function(t) {
                        var e = i[t];
                        !1 === e ? n.removeAttribute(t) : n.setAttribute(t, !0 === e ? "" : e)
                    }))
                })
            },
            effect: function(t) {
                var n = t.state,
                    s = {
                        popper: {
                            position: n.options.strategy,
                            left: "0",
                            top: "0",
                            margin: "0"
                        },
                        arrow: {
                            position: "absolute"
                        },
                        reference: {}
                    };
                return Object.assign(n.elements.popper.style, s.popper), n.styles = s, n.elements.arrow && Object.assign(n.elements.arrow.style, s.arrow),
                    function() {
                        Object.keys(n.elements).forEach(function(t) {
                            var e = n.elements[t],
                                i = n.attributes[t] || {},
                                t = Object.keys((n.styles.hasOwnProperty(t) ? n.styles : s)[t]).reduce(function(t, e) {
                                    return t[e] = "", t
                                }, {});
                            Qi(e) && Ui(e) && (Object.assign(e.style, t), Object.keys(i).forEach(function(t) {
                                e.removeAttribute(t)
                            }))
                        })
                    }
            },
            requires: ["computeStyles"]
        };

        function Gi(t) {
            return t.split("-")[0]
        }

        function Ji(t) {
            t = t.getBoundingClientRect();
            return {
                width: t.width,
                height: t.height,
                top: t.top,
                right: t.right,
                bottom: t.bottom,
                left: t.left,
                x: t.left,
                y: t.top
            }
        }

        function tn(t) {
            var e = Ji(t),
                i = t.offsetWidth,
                n = t.offsetHeight;
            return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
                x: t.offsetLeft,
                y: t.offsetTop,
                width: i,
                height: n
            }
        }

        function en(t, e) {
            var i = e.getRootNode && e.getRootNode();
            if (t.contains(e)) return !0;
            if (i && qi(i)) {
                var n = e;
                do {
                    if (n && t.isSameNode(n)) return !0
                } while (n = n.parentNode || n.host)
            }
            return !1
        }

        function nn(t) {
            return Ki(t).getComputedStyle(t)
        }

        function sn(t) {
            return (($i(t) ? t.ownerDocument : t.document) || window.document).documentElement
        }

        function on(t) {
            return "html" === Ui(t) ? t : t.assignedSlot || t.parentNode || (qi(t) ? t.host : null) || sn(t)
        }

        function an(t) {
            return Qi(t) && "fixed" !== nn(t).position ? t.offsetParent : null
        }

        function rn(t) {
            for (var e, i = Ki(t), n = an(t); n && (e = n, 0 <= ["table", "td", "th"].indexOf(Ui(e))) && "static" === nn(n).position;) n = an(n);
            return (!n || "html" !== Ui(n) && ("body" !== Ui(n) || "static" !== nn(n).position)) && (n || function(t) {
                var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"),
                    i = -1 !== navigator.userAgent.indexOf("Trident");
                if (i && Qi(t) && "fixed" === nn(t).position) return null;
                for (var n = on(t); Qi(n) && ["html", "body"].indexOf(Ui(n)) < 0;) {
                    var s = nn(n);
                    if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || e && "filter" === s.willChange || e && s.filter && "none" !== s.filter) return n;
                    n = n.parentNode
                }
                return null
            }(t)) || i
        }

        function ln(t) {
            return 0 <= ["top", "bottom"].indexOf(t) ? "x" : "y"
        }
        var cn = Math.max,
            hn = Math.min,
            dn = Math.round;

        function un(t, e, i) {
            return cn(t, hn(e, i))
        }

        function pn() {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }
        }

        function fn(t) {
            return Object.assign({}, pn(), t)
        }

        function gn(i, t) {
            return t.reduce(function(t, e) {
                return t[e] = i, t
            }, {})
        }
        var _n = {
                name: "arrow",
                enabled: !0,
                phase: "main",
                fn: function(t) {
                    var e, i, n = t.state,
                        s = t.name,
                        o = t.options,
                        a = n.elements.arrow,
                        r = n.modifiersData.popperOffsets,
                        l = Gi(n.placement),
                        c = ln(l),
                        h = 0 <= [Ti, ki].indexOf(l) ? "height" : "width";
                    a && r && (e = o.padding, i = n, t = fn("number" != typeof(e = "function" == typeof e ? e(Object.assign({}, i.rects, {
                        placement: i.placement
                    })) : e) ? e : gn(e, Ei)), l = tn(a), o = "y" === c ? wi : Ti, i = "y" === c ? Ci : ki, e = n.rects.reference[h] + n.rects.reference[c] - r[c] - n.rects.popper[h], r = r[c] - n.rects.reference[c], a = (a = rn(a)) ? "y" === c ? a.clientHeight || 0 : a.clientWidth || 0 : 0, o = t[o], i = a - l[h] - t[i], i = un(o, r = a / 2 - l[h] / 2 + (e / 2 - r / 2), i), n.modifiersData[s] = ((s = {})[c] = i, s.centerOffset = i - r, s))
                },
                effect: function(t) {
                    var e = t.state;
                    null != (t = void 0 === (t = t.options.element) ? "[data-popper-arrow]" : t) && ("string" != typeof t || (t = e.elements.popper.querySelector(t))) && en(e.elements.popper, t) && (e.elements.arrow = t)
                },
                requires: ["popperOffsets"],
                requiresIfExists: ["preventOverflow"]
            },
            mn = {
                top: "auto",
                right: "auto",
                bottom: "auto",
                left: "auto"
            };

        function vn(t) {
            var e = t.popper,
                i = t.popperRect,
                n = t.placement,
                s = t.offsets,
                o = t.position,
                a = t.gpuAcceleration,
                r = t.adaptive,
                l = t.roundOffsets,
                c = !0 === l ? (p = (g = s).x, f = g.y, g = window.devicePixelRatio || 1, {
                    x: dn(dn(p * g) / g) || 0,
                    y: dn(dn(f * g) / g) || 0
                }) : "function" == typeof l ? l(s) : s,
                h = c.x,
                d = void 0 === h ? 0 : h,
                u = c.y,
                t = void 0 === u ? 0 : u,
                p = s.hasOwnProperty("x"),
                f = s.hasOwnProperty("y"),
                g = Ti,
                l = wi,
                h = window;
            r && (c = "clientHeight", u = "clientWidth", (s = rn(e)) === Ki(e) && "static" !== nn(s = sn(e)).position && (c = "scrollHeight", u = "scrollWidth"), n === wi && (l = Ci, t -= s[c] - i.height, t *= a ? 1 : -1), n === Ti && (g = ki, d -= s[u] - i.width, d *= a ? 1 : -1));
            var r = Object.assign({
                position: o
            }, r && mn);
            return a ? Object.assign({}, r, ((a = {})[l] = f ? "0" : "", a[g] = p ? "0" : "", a.transform = (h.devicePixelRatio || 1) < 2 ? "translate(" + d + "px, " + t + "px)" : "translate3d(" + d + "px, " + t + "px, 0)", a)) : Object.assign({}, r, ((r = {})[l] = f ? t + "px" : "", r[g] = p ? d + "px" : "", r.transform = "", r))
        }
        var bn = {
                name: "computeStyles",
                enabled: !0,
                phase: "beforeWrite",
                fn: function(t) {
                    var e = t.state,
                        i = t.options,
                        t = void 0 === (n = i.gpuAcceleration) || n,
                        n = void 0 === (n = i.adaptive) || n,
                        i = void 0 === (i = i.roundOffsets) || i,
                        t = {
                            placement: Gi(e.placement),
                            popper: e.elements.popper,
                            popperRect: e.rects.popper,
                            gpuAcceleration: t
                        };
                    null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, vn(Object.assign({}, t, {
                        offsets: e.modifiersData.popperOffsets,
                        position: e.options.strategy,
                        adaptive: n,
                        roundOffsets: i
                    })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, vn(Object.assign({}, t, {
                        offsets: e.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1,
                        roundOffsets: i
                    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
                        "data-popper-placement": e.placement
                    })
                },
                data: {}
            },
            yn = {
                passive: !0
            };
        var xn = {
                name: "eventListeners",
                enabled: !0,
                phase: "write",
                fn: function() {},
                effect: function(t) {
                    var e = t.state,
                        i = t.instance,
                        n = t.options,
                        s = void 0 === (t = n.scroll) || t,
                        o = void 0 === (n = n.resize) || n,
                        a = Ki(e.elements.popper),
                        r = [].concat(e.scrollParents.reference, e.scrollParents.popper);
                    return s && r.forEach(function(t) {
                            t.addEventListener("scroll", i.update, yn)
                        }), o && a.addEventListener("resize", i.update, yn),
                        function() {
                            s && r.forEach(function(t) {
                                t.removeEventListener("scroll", i.update, yn)
                            }), o && a.removeEventListener("resize", i.update, yn)
                        }
                },
                data: {}
            },
            wn = {
                left: "right",
                right: "left",
                bottom: "top",
                top: "bottom"
            };

        function Cn(t) {
            return t.replace(/left|right|bottom|top/g, function(t) {
                return wn[t]
            })
        }
        var kn = {
            start: "end",
            end: "start"
        };

        function Tn(t) {
            return t.replace(/start|end/g, function(t) {
                return kn[t]
            })
        }

        function Sn(t) {
            t = Ki(t);
            return {
                scrollLeft: t.pageXOffset,
                scrollTop: t.pageYOffset
            }
        }

        function En(t) {
            return Ji(sn(t)).left + Sn(t).scrollLeft
        }

        function An(t) {
            var e = nn(t),
                i = e.overflow,
                t = e.overflowX,
                e = e.overflowY;
            return /auto|scroll|overlay|hidden/.test(i + e + t)
        }

        function Mn(t, e) {
            void 0 === e && (e = []);
            var i = function t(e) {
                    return 0 <= ["html", "body", "#document"].indexOf(Ui(e)) ? e.ownerDocument.body : Qi(e) && An(e) ? e : t(on(e))
                }(t),
                t = i === (null == (n = t.ownerDocument) ? void 0 : n.body),
                n = Ki(i),
                i = t ? [n].concat(n.visualViewport || [], An(i) ? i : []) : i,
                e = e.concat(i);
            return t ? e : e.concat(Mn(on(i)))
        }

        function On(t) {
            return Object.assign({}, t, {
                left: t.x,
                top: t.y,
                right: t.x + t.width,
                bottom: t.y + t.height
            })
        }

        function In(t, e) {
            return e === Ii ? On((o = Ki(s = t), a = sn(s), r = o.visualViewport, l = a.clientWidth, c = a.clientHeight, a = o = 0, r && (l = r.width, c = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
                width: l,
                height: c,
                x: o + En(s),
                y: a
            })) : Qi(e) ? ((n = Ji(i = e)).top = n.top + i.clientTop, n.left = n.left + i.clientLeft, n.bottom = n.top + i.clientHeight, n.right = n.left + i.clientWidth, n.width = i.clientWidth, n.height = i.clientHeight, n.x = n.left, n.y = n.top, n) : On((s = sn(t), a = sn(s), e = Sn(s), n = null == (i = s.ownerDocument) ? void 0 : i.body, t = cn(a.scrollWidth, a.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), i = cn(a.scrollHeight, a.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), s = -e.scrollLeft + En(s), e = -e.scrollTop, "rtl" === nn(n || a).direction && (s += cn(a.clientWidth, n ? n.clientWidth : 0) - t), {
                width: t,
                height: i,
                x: s,
                y: e
            }));
            var i, n, s, o, a, r, l, c
        }

        function Dn(i, t, e) {
            var n, s, o, t = "clippingParents" === t ? (s = Mn(on(n = i)), $i(o = 0 <= ["absolute", "fixed"].indexOf(nn(n).position) && Qi(n) ? rn(n) : n) ? s.filter(function(t) {
                    return $i(t) && en(t, o) && "body" !== Ui(t)
                }) : []) : [].concat(t),
                t = [].concat(t, [e]),
                e = t[0],
                e = t.reduce(function(t, e) {
                    e = In(i, e);
                    return t.top = cn(e.top, t.top), t.right = hn(e.right, t.right), t.bottom = hn(e.bottom, t.bottom), t.left = cn(e.left, t.left), t
                }, In(i, e));
            return e.width = e.right - e.left, e.height = e.bottom - e.top, e.x = e.left, e.y = e.top, e
        }

        function Ln(t) {
            return t.split("-")[1]
        }

        function Pn(t) {
            var e, i = t.reference,
                n = t.element,
                s = t.placement,
                t = s ? Gi(s) : null,
                s = s ? Ln(s) : null,
                o = i.x + i.width / 2 - n.width / 2,
                a = i.y + i.height / 2 - n.height / 2;
            switch (t) {
                case wi:
                    e = {
                        x: o,
                        y: i.y - n.height
                    };
                    break;
                case Ci:
                    e = {
                        x: o,
                        y: i.y + i.height
                    };
                    break;
                case ki:
                    e = {
                        x: i.x + i.width,
                        y: a
                    };
                    break;
                case Ti:
                    e = {
                        x: i.x - n.width,
                        y: a
                    };
                    break;
                default:
                    e = {
                        x: i.x,
                        y: i.y
                    }
            }
            var r = t ? ln(t) : null;
            if (null != r) {
                var l = "y" === r ? "height" : "width";
                switch (s) {
                    case Ai:
                        e[r] = e[r] - (i[l] / 2 - n[l] / 2);
                        break;
                    case Mi:
                        e[r] = e[r] + (i[l] / 2 - n[l] / 2)
                }
            }
            return e
        }

        function Rn(t, e) {
            var n, i = e = void 0 === e ? {} : e,
                s = i.placement,
                o = void 0 === s ? t.placement : s,
                a = i.boundary,
                r = void 0 === a ? Oi : a,
                l = i.rootBoundary,
                c = void 0 === l ? Ii : l,
                e = i.elementContext,
                s = void 0 === e ? Di : e,
                a = i.altBoundary,
                l = void 0 !== a && a,
                e = i.padding,
                a = void 0 === e ? 0 : e,
                i = fn("number" != typeof a ? a : gn(a, Ei)),
                e = t.elements.reference,
                a = t.rects.popper,
                l = t.elements[l ? s === Di ? Li : Di : s],
                r = Dn($i(l) ? l : l.contextElement || sn(t.elements.popper), r, c),
                c = Ji(e),
                e = Pn({
                    reference: c,
                    element: a,
                    strategy: "absolute",
                    placement: o
                }),
                e = On(Object.assign({}, a, e)),
                c = s === Di ? e : c,
                h = {
                    top: r.top - c.top + i.top,
                    bottom: c.bottom - r.bottom + i.bottom,
                    left: r.left - c.left + i.left,
                    right: c.right - r.right + i.right
                },
                t = t.modifiersData.offset;
            return s === Di && t && (n = t[o], Object.keys(h).forEach(function(t) {
                var e = 0 <= [ki, Ci].indexOf(t) ? 1 : -1,
                    i = 0 <= [wi, Ci].indexOf(t) ? "y" : "x";
                h[t] += n[i] * e
            })), h
        }
        var Bn = {
            name: "flip",
            enabled: !0,
            phase: "main",
            fn: function(t) {
                var d = t.state,
                    e = t.options,
                    i = t.name;
                if (!d.modifiersData[i]._skip) {
                    for (var n = e.mainAxis, s = void 0 === n || n, t = e.altAxis, o = void 0 === t || t, n = e.fallbackPlacements, u = e.padding, p = e.boundary, f = e.rootBoundary, a = e.altBoundary, t = e.flipVariations, g = void 0 === t || t, _ = e.allowedAutoPlacements, t = d.options.placement, e = Gi(t), e = n || (e === t || !g ? [Cn(t)] : function(t) {
                            if (Gi(t) === Si) return [];
                            var e = Cn(t);
                            return [Tn(t), e, Tn(e)]
                        }(t)), r = [t].concat(e).reduce(function(t, e) {
                            return t.concat(Gi(e) === Si ? (i = d, s = n = void 0 === (n = {
                                placement: e,
                                boundary: p,
                                rootBoundary: f,
                                padding: u,
                                flipVariations: g,
                                allowedAutoPlacements: _
                            }) ? {} : n, t = s.placement, o = s.boundary, a = s.rootBoundary, r = s.padding, n = s.flipVariations, l = void 0 === (s = s.allowedAutoPlacements) ? Ri : s, c = Ln(t), t = c ? n ? Pi : Pi.filter(function(t) {
                                return Ln(t) === c
                            }) : Ei, h = (n = 0 === (n = t.filter(function(t) {
                                return 0 <= l.indexOf(t)
                            })).length ? t : n).reduce(function(t, e) {
                                return t[e] = Rn(i, {
                                    placement: e,
                                    boundary: o,
                                    rootBoundary: a,
                                    padding: r
                                })[Gi(e)], t
                            }, {}), Object.keys(h).sort(function(t, e) {
                                return h[t] - h[e]
                            })) : e);
                            var i, n, s, o, a, r, l, c, h
                        }, []), l = d.rects.reference, c = d.rects.popper, h = new Map, m = !0, v = r[0], b = 0; b < r.length; b++) {
                        var y = r[b],
                            x = Gi(y),
                            w = Ln(y) === Ai,
                            C = 0 <= [wi, Ci].indexOf(x),
                            k = C ? "width" : "height",
                            T = Rn(d, {
                                placement: y,
                                boundary: p,
                                rootBoundary: f,
                                altBoundary: a,
                                padding: u
                            }),
                            C = C ? w ? ki : Ti : w ? Ci : wi;
                        l[k] > c[k] && (C = Cn(C));
                        w = Cn(C), k = [];
                        if (s && k.push(T[x] <= 0), o && k.push(T[C] <= 0, T[w] <= 0), k.every(function(t) {
                                return t
                            })) {
                            v = y, m = !1;
                            break
                        }
                        h.set(y, k)
                    }
                    if (m)
                        for (var S = g ? 3 : 1; 0 < S; S--)
                            if ("break" === function(e) {
                                    var t = r.find(function(t) {
                                        t = h.get(t);
                                        if (t) return t.slice(0, e).every(function(t) {
                                            return t
                                        })
                                    });
                                    if (t) return v = t, "break"
                                }(S)) break;
                    d.placement !== v && (d.modifiersData[i]._skip = !0, d.placement = v, d.reset = !0)
                }
            },
            requiresIfExists: ["offset"],
            data: {
                _skip: !1
            }
        };

        function Nn(t, e, i) {
            return {
                top: t.top - e.height - (i = void 0 === i ? {
                    x: 0,
                    y: 0
                } : i).y,
                right: t.right - e.width + i.x,
                bottom: t.bottom - e.height + i.y,
                left: t.left - e.width - i.x
            }
        }

        function Hn(e) {
            return [wi, ki, Ci, Ti].some(function(t) {
                return 0 <= e[t]
            })
        }
        var jn = {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function(t) {
                var e = t.state,
                    i = t.name,
                    n = e.rects.reference,
                    s = e.rects.popper,
                    o = e.modifiersData.preventOverflow,
                    a = Rn(e, {
                        elementContext: "reference"
                    }),
                    t = Rn(e, {
                        altBoundary: !0
                    }),
                    n = Nn(a, n),
                    t = Nn(t, s, o),
                    s = Hn(n),
                    o = Hn(t);
                e.modifiersData[i] = {
                    referenceClippingOffsets: n,
                    popperEscapeOffsets: t,
                    isReferenceHidden: s,
                    hasPopperEscaped: o
                }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
                    "data-popper-reference-hidden": s,
                    "data-popper-escaped": o
                })
            }
        };
        var Wn = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(t) {
                var a = t.state,
                    e = t.options,
                    i = t.name,
                    r = void 0 === (n = e.offset) ? [0, 0] : n,
                    t = Ri.reduce(function(t, e) {
                        var i, n, s, o;
                        return t[e] = (i = e, n = a.rects, s = r, o = Gi(i), e = 0 <= [Ti, wi].indexOf(o) ? -1 : 1, s = (s = (i = "function" == typeof s ? s(Object.assign({}, n, {
                            placement: i
                        })) : s)[0]) || 0, i = ((i = i[1]) || 0) * e, 0 <= [Ti, ki].indexOf(o) ? {
                            x: i,
                            y: s
                        } : {
                            x: s,
                            y: i
                        }), t
                    }, {}),
                    n = (e = t[a.placement]).x,
                    e = e.y;
                null != a.modifiersData.popperOffsets && (a.modifiersData.popperOffsets.x += n, a.modifiersData.popperOffsets.y += e), a.modifiersData[i] = t
            }
        };
        var Fn = {
            name: "popperOffsets",
            enabled: !0,
            phase: "read",
            fn: function(t) {
                var e = t.state,
                    t = t.name;
                e.modifiersData[t] = Pn({
                    reference: e.rects.reference,
                    element: e.rects.popper,
                    strategy: "absolute",
                    placement: e.placement
                })
            },
            data: {}
        };
        var Vn = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(t) {
                var e = t.state,
                    i = t.options,
                    n = t.name,
                    s = void 0 === (w = i.mainAxis) || w,
                    o = void 0 !== (C = i.altAxis) && C,
                    a = i.boundary,
                    r = i.rootBoundary,
                    l = i.altBoundary,
                    c = i.padding,
                    h = i.tether,
                    d = void 0 === h || h,
                    u = i.tetherOffset,
                    p = void 0 === u ? 0 : u,
                    f = Rn(e, {
                        boundary: a,
                        rootBoundary: r,
                        padding: c,
                        altBoundary: l
                    }),
                    g = Gi(e.placement),
                    _ = Ln(e.placement),
                    m = !_,
                    v = ln(g),
                    b = "x" === v ? "y" : "x",
                    y = e.modifiersData.popperOffsets,
                    x = e.rects.reference,
                    t = e.rects.popper,
                    w = "function" == typeof p ? p(Object.assign({}, e.rects, {
                        placement: e.placement
                    })) : p,
                    C = {
                        x: 0,
                        y: 0
                    };
                y && ((s || o) && (h = "y" === v ? "height" : "width", i = y[v], a = y[v] + f[u = "y" === v ? wi : Ti], c = y[v] - f[r = "y" === v ? Ci : ki], l = d ? -t[h] / 2 : 0, g = (_ === Ai ? x : t)[h], p = _ === Ai ? -t[h] : -x[h], _ = e.elements.arrow, t = d && _ ? tn(_) : {
                    width: 0,
                    height: 0
                }, u = (_ = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : pn())[u], r = _[r], t = un(0, x[h], t[h]), u = m ? x[h] / 2 - l - t - u - w : g - t - u - w, t = m ? -x[h] / 2 + l + t + r + w : p + t + r + w, w = (r = e.elements.arrow && rn(e.elements.arrow)) ? "y" === v ? r.clientTop || 0 : r.clientLeft || 0 : 0, r = e.modifiersData.offset ? e.modifiersData.offset[e.placement][v] : 0, w = y[v] + u - r - w, r = y[v] + t - r, s && (c = un(d ? hn(a, w) : a, i, d ? cn(c, r) : c), y[v] = c, C[v] = c - i), o && (o = (i = y[b]) + f["x" === v ? wi : Ti], v = i - f["x" === v ? Ci : ki], v = un(d ? hn(o, w) : o, i, d ? cn(v, r) : v), y[b] = v, C[b] = v - i)), e.modifiersData[n] = C)
            },
            requiresIfExists: ["offset"]
        };

        function zn(t, e, i) {
            void 0 === i && (i = !1);
            var n = sn(e),
                s = Ji(t),
                o = Qi(e),
                a = {
                    scrollLeft: 0,
                    scrollTop: 0
                },
                t = {
                    x: 0,
                    y: 0
                };
            return !o && i || ("body" === Ui(e) && !An(n) || (a = (i = e) !== Ki(i) && Qi(i) ? {
                scrollLeft: i.scrollLeft,
                scrollTop: i.scrollTop
            } : Sn(i)), Qi(e) ? ((t = Ji(e)).x += e.clientLeft, t.y += e.clientTop) : n && (t.x = En(n))), {
                x: s.left + a.scrollLeft - t.x,
                y: s.top + a.scrollTop - t.y,
                width: s.width,
                height: s.height
            }
        }

        function Yn(t) {
            var i = new Map,
                n = new Set,
                s = [];
            return t.forEach(function(t) {
                i.set(t.name, t)
            }), t.forEach(function(t) {
                n.has(t.name) || ! function e(t) {
                    n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function(t) {
                        n.has(t) || (t = i.get(t)) && e(t)
                    }), s.push(t)
                }(t)
            }), s
        }
        var Xn = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };

        function Un() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
            return !e.some(function(t) {
                return !(t && "function" == typeof t.getBoundingClientRect)
            })
        }

        function Kn(t) {
            var e = t = void 0 === t ? {} : t,
                t = e.defaultModifiers,
                d = void 0 === t ? [] : t,
                e = e.defaultOptions,
                u = void 0 === e ? Xn : e;
            return function(n, s, e) {
                void 0 === e && (e = u);
                var i, o, a = {
                        placement: "bottom",
                        orderedModifiers: [],
                        options: Object.assign({}, Xn, u),
                        modifiersData: {},
                        elements: {
                            reference: n,
                            popper: s
                        },
                        attributes: {},
                        styles: {}
                    },
                    r = [],
                    l = !1,
                    c = {
                        state: a,
                        setOptions: function(t) {
                            h(), a.options = Object.assign({}, u, a.options, t), a.scrollParents = {
                                reference: $i(n) ? Mn(n) : n.contextElement ? Mn(n.contextElement) : [],
                                popper: Mn(s)
                            };
                            var i, e, t = (t = [].concat(d, a.options.modifiers), e = t.reduce(function(t, e) {
                                var i = t[e.name];
                                return t[e.name] = i ? Object.assign({}, i, e, {
                                    options: Object.assign({}, i.options, e.options),
                                    data: Object.assign({}, i.data, e.data)
                                }) : e, t
                            }, {}), t = Object.keys(e).map(function(t) {
                                return e[t]
                            }), i = Yn(t), Xi.reduce(function(t, e) {
                                return t.concat(i.filter(function(t) {
                                    return t.phase === e
                                }))
                            }, []));
                            return a.orderedModifiers = t.filter(function(t) {
                                return t.enabled
                            }), a.orderedModifiers.forEach(function(t) {
                                var e = t.name,
                                    i = t.options,
                                    t = t.effect;
                                "function" == typeof t && (i = t({
                                    state: a,
                                    name: e,
                                    instance: c,
                                    options: void 0 === i ? {} : i
                                }), r.push(i || function() {}))
                            }), c.update()
                        },
                        forceUpdate: function() {
                            if (!l) {
                                var t = a.elements,
                                    e = t.reference,
                                    t = t.popper;
                                if (Un(e, t)) {
                                    a.rects = {
                                        reference: zn(e, rn(t), "fixed" === a.options.strategy),
                                        popper: tn(t)
                                    }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function(t) {
                                        return a.modifiersData[t.name] = Object.assign({}, t.data)
                                    });
                                    for (var i, n, s, o = 0; o < a.orderedModifiers.length; o++) 0, !0 !== a.reset ? (i = (s = a.orderedModifiers[o]).fn, n = s.options, s = s.name, "function" == typeof i && (a = i({
                                        state: a,
                                        options: void 0 === n ? {} : n,
                                        name: s,
                                        instance: c
                                    }) || a)) : (a.reset = !1, o = -1)
                                }
                            }
                        },
                        update: (i = function() {
                            return new Promise(function(t) {
                                c.forceUpdate(), t(a)
                            })
                        }, function() {
                            return o = o || new Promise(function(t) {
                                Promise.resolve().then(function() {
                                    o = void 0, t(i())
                                })
                            })
                        }),
                        destroy: function() {
                            h(), l = !0
                        }
                    };
                return Un(n, s) && c.setOptions(e).then(function(t) {
                    !l && e.onFirstUpdate && e.onFirstUpdate(t)
                }), c;

                function h() {
                    r.forEach(function(t) {
                        return t()
                    }), r = []
                }
            }
        }
        var $n = Kn(),
            Qn = Kn({
                defaultModifiers: [xn, Fn, bn, Zi, Wn, Bn, Vn, _n, jn]
            }),
            qn = Kn({
                defaultModifiers: [xn, Fn, bn, Zi]
            });
        const Zn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
        const Gn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
            Jn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
        e = {
            "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
            a: ["target", "href", "title", "rel"],
            area: [],
            b: [],
            br: [],
            col: [],
            code: [],
            div: [],
            em: [],
            hr: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            i: [],
            img: ["src", "srcset", "alt", "title", "width", "height"],
            li: [],
            ol: [],
            p: [],
            pre: [],
            s: [],
            small: [],
            span: [],
            sub: [],
            sup: [],
            strong: [],
            u: [],
            ul: []
        };

        function ts(t, e, i) {
            if (!t.length) return t;
            if (i && "function" == typeof i) return i(t);
            const n = new window.DOMParser,
                s = n.parseFromString(t, "text/html");
            for (const l of [].concat(...s.body.querySelectorAll("*"))) {
                var o = l.nodeName.toLowerCase();
                if (Object.keys(e).includes(o)) {
                    var a = [].concat(...l.attributes),
                        r = [].concat(e["*"] || [], e[o] || []);
                    for (const c of a)((t, e) => {
                        const i = t.nodeName.toLowerCase();
                        return e.includes(i) ? !Zn.has(i) || Boolean(Gn.test(t.nodeValue) || Jn.test(t.nodeValue)) : e.filter(t => t instanceof RegExp).some(t => t.test(i))
                    })(c, r) || l.removeAttribute(c.nodeName)
                } else l.remove()
            }
            return s.body.innerHTML
        }
        const es = {
                allowList: e,
                content: {},
                extraClass: "",
                html: !1,
                sanitize: !0,
                sanitizeFn: null,
                template: "<div></div>"
            },
            is = {
                allowList: "object",
                content: "object",
                extraClass: "(string|function)",
                html: "boolean",
                sanitize: "boolean",
                sanitizeFn: "(null|function)",
                template: "string"
            },
            ns = {
                entry: "(string|element|function|null)",
                selector: "(string|element)"
            };
        var ss = class extends St {
            constructor(t) {
                super(), this._config = this._getConfig(t)
            }
            static get Default() {
                return es
            }
            static get DefaultType() {
                return is
            }
            static get NAME() {
                return "TemplateFactory"
            }
            getContent() {
                return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean)
            }
            hasContent() {
                return 0 < this.getContent().length
            }
            changeContent(t) {
                return this._checkContent(t), this._config.content = { ...this._config.content,
                    ...t
                }, this
            }
            toHtml() {
                const t = document.createElement("div");
                t.innerHTML = this._maybeSanitize(this._config.template);
                for (var [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
                const n = t.children[0],
                    s = this._resolvePossibleFunction(this._config.extraClass);
                return s && n.classList.add(...s.split(" ")), n
            }
            _typeCheckConfig(t) {
                super._typeCheckConfig(t), this._checkContent(t.content)
            }
            _checkContent(t) {
                for (var [e, i] of Object.entries(t)) super._typeCheckConfig({
                    selector: e,
                    entry: i
                }, ns)
            }
            _setContent(t, e, i) {
                const n = Kt.findOne(i, t);
                n && ((e = this._resolvePossibleFunction(e)) ? V(e) ? this._putElementInTemplate(z(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove())
            }
            _maybeSanitize(t) {
                return this._config.sanitize ? ts(t, this._config.allowList, this._config.sanitizeFn) : t
            }
            _resolvePossibleFunction(t) {
                return "function" == typeof t ? t(this) : t
            }
            _putElementInTemplate(t, e) {
                if (this._config.html) return e.innerHTML = "", void e.append(t);
                e.textContent = t.textContent
            }
        };
        const os = new Set(["sanitize", "allowList", "sanitizeFn"]),
            as = "fade";
        const rs = "show",
            ls = ".".concat("modal"),
            cs = "hide.bs.modal",
            hs = "hover",
            ds = "focus",
            us = {
                AUTO: "auto",
                TOP: "top",
                RIGHT: Z() ? "left" : "right",
                BOTTOM: "bottom",
                LEFT: Z() ? "right" : "left"
            },
            ps = {
                allowList: e,
                animation: !0,
                boundary: "clippingParents",
                container: !1,
                customClass: "",
                delay: 0,
                fallbackPlacements: ["top", "right", "bottom", "left"],
                html: !1,
                offset: [0, 0],
                placement: "top",
                popperConfig: null,
                sanitize: !0,
                sanitizeFn: null,
                selector: !1,
                template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                title: "",
                trigger: "hover focus"
            },
            fs = {
                allowList: "object",
                animation: "boolean",
                boundary: "(string|element)",
                container: "(string|element|boolean)",
                customClass: "(string|function)",
                delay: "(number|object)",
                fallbackPlacements: "array",
                html: "boolean",
                offset: "(array|string|function)",
                placement: "(string|function)",
                popperConfig: "(null|object|function)",
                sanitize: "boolean",
                sanitizeFn: "(null|function)",
                selector: "(string|boolean)",
                template: "string",
                title: "(string|element|function)",
                trigger: "string"
            };
        class gs extends Et {
            constructor(t, e) {
                if (void 0 === n) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()
            }
            static get Default() {
                return ps
            }
            static get DefaultType() {
                return fs
            }
            static get NAME() {
                return "tooltip"
            }
            enable() {
                this._isEnabled = !0
            }
            disable() {
                this._isEnabled = !1
            }
            toggleEnabled() {
                this._isEnabled = !this._isEnabled
            }
            toggle() {
                this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter())
            }
            dispose() {
                clearTimeout(this._timeout), vt.off(this._element.closest(ls), cs, this._hideModalHandler), this.tip && this.tip.remove(), this._element.getAttribute("data-mdb-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-mdb-original-title")), this._disposePopper(), super.dispose()
            }
            show() {
                if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                if (this._isWithContent() && this._isEnabled) {
                    var t = vt.trigger(this._element, this.constructor.eventName("show"));
                    const i = U(this._element);
                    var e = (i || this._element.ownerDocument.documentElement).contains(this._element);
                    if (!t.defaultPrevented && e) {
                        this.tip && (this.tip.remove(), this.tip = null);
                        const n = this._getTipElement();
                        this._element.setAttribute("aria-describedby", n.getAttribute("id"));
                        const s = this._config["container"];
                        if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(n), vt.trigger(this._element, this.constructor.eventName("inserted"))), this._popper ? this._popper.update() : this._popper = this._createPopper(n), n.classList.add(rs), "ontouchstart" in document.documentElement)
                            for (const o of [].concat(...document.body.children)) vt.on(o, "mouseover", K);
                        this._queueCallback(() => {
                            vt.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1
                        }, this.tip, this._isAnimated())
                    }
                }
            }
            hide() {
                if (this._isShown() && !vt.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                    const t = this._getTipElement();
                    if (t.classList.remove(rs), "ontouchstart" in document.documentElement)
                        for (const e of [].concat(...document.body.children)) vt.off(e, "mouseover", K);
                    this._activeTrigger.click = !1, this._activeTrigger[ds] = !1, this._activeTrigger[hs] = !1, this._isHovered = null;
                    this._queueCallback(() => {
                        this._isWithActiveTrigger() || (this._isHovered || t.remove(), this._element.removeAttribute("aria-describedby"), vt.trigger(this._element, this.constructor.eventName("hidden")), this._disposePopper())
                    }, this.tip, this._isAnimated())
                }
            }
            update() {
                this._popper && this._popper.update()
            }
            _isWithContent() {
                return Boolean(this._getTitle())
            }
            _getTipElement() {
                return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
            }
            _createTipElement(t) {
                const e = this._getTemplateFactory(t).toHtml();
                if (!e) return null;
                e.classList.remove(as, rs), e.classList.add("bs-".concat(this.constructor.NAME, "-auto"));
                t = (t => {
                    for (; t += Math.floor(1e6 * Math.random()), document.getElementById(t););
                    return t
                })(this.constructor.NAME).toString();
                return e.setAttribute("id", t), this._isAnimated() && e.classList.add(as), e
            }
            setContent(t) {
                this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
            }
            _getTemplateFactory(t) {
                return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new ss({ ...this._config,
                    content: t,
                    extraClass: this._resolvePossibleFunction(this._config.customClass)
                }), this._templateFactory
            }
            _getContentForTemplate() {
                return {
                    ".tooltip-inner": this._getTitle()
                }
            }
            _getTitle() {
                return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-mdb-original-title")
            }
            _initializeOnDelegatedTarget(t) {
                return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
            }
            _isAnimated() {
                return this._config.animation || this.tip && this.tip.classList.contains(as)
            }
            _isShown() {
                return this.tip && this.tip.classList.contains(rs)
            }
            _createPopper(t) {
                const e = "function" == typeof this._config.placement ? this._config.placement.call(this, t, this._element) : this._config.placement;
                var i = us[e.toUpperCase()];
                return Qn(this._element, t, this._getPopperConfig(i))
            }
            _getOffset() {
                const e = this._config["offset"];
                return "string" == typeof e ? e.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof e ? t => e(t, this._element) : e
            }
            _resolvePossibleFunction(t) {
                return "function" == typeof t ? t.call(this._element) : t
            }
            _getPopperConfig(t) {
                t = {
                    placement: t,
                    modifiers: [{
                        name: "flip",
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }, {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: ".".concat(this.constructor.NAME, "-arrow")
                        }
                    }, {
                        name: "preSetPlacement",
                        enabled: !0,
                        phase: "beforeMain",
                        fn: t => {
                            this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
                        }
                    }]
                };
                return { ...t,
                    ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
                }
            }
            _setListeners() {
                var t, e;
                for (const i of this._config.trigger.split(" ")) "click" === i ? vt.on(this._element, this.constructor.eventName("click"), this._config.selector, t => {
                    const e = this._initializeOnDelegatedTarget(t);
                    e.toggle()
                }) : "manual" !== i && (t = i === hs ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), e = i === hs ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"), vt.on(this._element, t, this._config.selector, t => {
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusin" === t.type ? ds : hs] = !0, e._enter()
                }), vt.on(this._element, e, this._config.selector, t => {
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusout" === t.type ? ds : hs] = e._element.contains(t.relatedTarget), e._leave()
                }));
                this._hideModalHandler = () => {
                    this._element && this.hide()
                }, vt.on(this._element.closest(ls), cs, this._hideModalHandler)
            }
            _fixTitle() {
                var t = this._element.getAttribute("title");
                t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-mdb-original-title", t), this._element.removeAttribute("title"))
            }
            _enter() {
                this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => {
                    this._isHovered && this.show()
                }, this._config.delay.show))
            }
            _leave() {
                this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
                    this._isHovered || this.hide()
                }, this._config.delay.hide))
            }
            _setTimeout(t, e) {
                clearTimeout(this._timeout), this._timeout = setTimeout(t, e)
            }
            _isWithActiveTrigger() {
                return Object.values(this._activeTrigger).includes(!0)
            }
            _getConfig(t) {
                const e = Tt.getDataAttributes(this._element);
                for (const i of Object.keys(e)) os.has(i) && delete e[i];
                return t = { ...e,
                    ..."object" == typeof t && t ? t : {}
                }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
            }
            _configAfterMerge(t) {
                return t.container = !1 === t.container ? document.body : z(t.container), "number" == typeof t.delay && (t.delay = {
                    show: t.delay,
                    hide: t.delay
                }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t
            }
            _getDelegateConfig() {
                const t = {};
                for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
                return t.selector = !1, t.trigger = "manual", t
            }
            _disposePopper() {
                this._popper && (this._popper.destroy(), this._popper = null)
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = gs.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
        }
        G(gs);
        var _s = gs;
        const ms = { ..._s.Default,
                content: "",
                offset: [0, 8],
                placement: "right",
                template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
                trigger: "click"
            },
            vs = { ..._s.DefaultType,
                content: "(null|string|element|function)"
            };
        class bs extends _s {
            static get Default() {
                return ms
            }
            static get DefaultType() {
                return vs
            }
            static get NAME() {
                return "popover"
            }
            _isWithContent() {
                return this._getTitle() || this._getContent()
            }
            _getContentForTemplate() {
                return {
                    ".popover-header": this._getTitle(),
                    ".popover-body": this._getContent()
                }
            }
            _getContent() {
                return this._resolvePossibleFunction(this._config.content)
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = bs.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
        }
        G(bs);
        At = bs;
        const ys = "popover";
        Rt = "mdb.".concat(ys), Dt = ".".concat(Rt);
        const xs = "show.bs.popover",
            ws = "shown.bs.popover",
            Cs = "hide.bs.popover",
            ks = "hidden.bs.popover",
            Ts = "inserted.bs.popover",
            Ss = "show".concat(Dt),
            Es = "shown".concat(Dt),
            As = "hide".concat(Dt),
            Ms = "hidden".concat(Dt),
            Os = "inserted".concat(Dt);
        class Is extends At {
            constructor(t, e) {
                super(t, e), this._init()
            }
            dispose() {
                I.off(this.element, xs), I.off(this.element, ws), I.off(this.element, Cs), I.off(this.element, ks), I.off(this.element, Ts), super.dispose()
            }
            static get NAME() {
                return ys
            }
            _init() {
                this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent(), this._bindInsertedEvent()
            }
            _bindShowEvent() {
                I.on(this.element, xs, () => {
                    I.trigger(this.element, Ss)
                })
            }
            _bindShownEvent() {
                I.on(this.element, ws, () => {
                    I.trigger(this.element, Es)
                })
            }
            _bindHideEvent() {
                I.on(this.element, Cs, () => {
                    I.trigger(this.element, As)
                })
            }
            _bindHiddenEvent() {
                I.on(this.element, ks, () => {
                    I.trigger(this.element, Ms)
                })
            }
            _bindInsertedEvent() {
                I.on(this.element, Ts, () => {
                    I.trigger(this.element, Os)
                })
            }
        }
        R.find('[data-mdb-toggle="popover"]').forEach(t => {
            var e = Is.getInstance(t);
            e || new Is(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[ys];
                t.fn[ys] = Is.jQueryInterface, t.fn[ys].Constructor = Is, t.fn[ys].noConflict = () => (t.fn[ys] = e, Is.jQueryInterface)
            }
        });
        var Ds = Is;
        Jt = ".".concat("bs.scrollspy");
        const Ls = "activate".concat(Jt),
            Ps = "click".concat(Jt);
        $t = "load".concat(Jt).concat(".data-api");
        const Rs = "active",
            Bs = "[href]";
        Ee = ".nav-link";
        const Ns = "".concat(Ee, ", ").concat(".nav-item", " > ").concat(Ee, ", ").concat(".list-group-item"),
            Hs = {
                offset: null,
                rootMargin: "0px 0px -25%",
                smoothScroll: !1,
                target: null,
                threshold: [.1, .5, 1]
            },
            js = {
                offset: "(number|null)",
                rootMargin: "string",
                smoothScroll: "boolean",
                target: "element",
                threshold: "array"
            };
        class Ws extends Et {
            constructor(t, e) {
                super(t, e), j(t) && (this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
                    visibleEntryTop: 0,
                    parentScrollTop: 0
                }, this.refresh())
            }
            static get Default() {
                return Hs
            }
            static get DefaultType() {
                return js
            }
            static get NAME() {
                return "scrollspy"
            }
            refresh() {
                this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
                for (const t of this._observableSections.values()) this._observer.observe(t)
            }
            dispose() {
                this._observer && this._observer.disconnect(), super.dispose()
            }
            _configAfterMerge(t) {
                return t.target = z(t.target) || document.body, t.rootMargin = t.offset ? "".concat(t.offset, "px 0px -30%") : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map(t => Number.parseFloat(t))), t
            }
            _maybeEnableSmoothScroll() {
                this._config.smoothScroll && (vt.off(this._config.target, Ps), vt.on(this._config.target, Ps, Bs, t => {
                    var e = this._observableSections.get(t.target.hash);
                    if (e) {
                        t.preventDefault();
                        const i = this._rootElement || window;
                        e = e.offsetTop - this._element.offsetTop;
                        i.scrollTo ? i.scrollTo({
                            top: e,
                            behavior: "smooth"
                        }) : i.scrollTop = e
                    }
                }))
            }
            _getNewObserver() {
                var t = {
                    root: this._rootElement,
                    threshold: this._config.threshold,
                    rootMargin: this._config.rootMargin
                };
                return new IntersectionObserver(t => this._observerCallback(t), t)
            }
            _observerCallback(t) {
                const e = t => this._targetLinks.get("#".concat(t.target.id));
                var i = t => {
                        this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t))
                    },
                    n = (this._rootElement || document.documentElement).scrollTop,
                    s = n >= this._previousScrollData.parentScrollTop;
                this._previousScrollData.parentScrollTop = n;
                for (const a of t)
                    if (a.isIntersecting) {
                        var o = a.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                        if (s && o) {
                            if (i(a), !n) return
                        } else s || o || i(a)
                    } else this._activeTarget = null, this._clearActiveClass(e(a))
            }
            _initializeTargetsAndObservables() {
                var t;
                this._targetLinks = new Map, this._observableSections = new Map;
                for (const e of Kt.find(Bs, this._config.target)) e.hash && !X(e) && (t = Kt.findOne(e.hash, this._element), Y(t) && (this._targetLinks.set(e.hash, e), this._observableSections.set(e.hash, t)))
            }
            _process(t) {
                this._activeTarget !== t && (this._clearActiveClass(this._config.target), (this._activeTarget = t).classList.add(Rs), this._activateParents(t), vt.trigger(this._element, Ls, {
                    relatedTarget: t
                }))
            }
            _activateParents(t) {
                if (t.classList.contains("dropdown-item")) Kt.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(Rs);
                else
                    for (const e of Kt.parents(t, ".nav, .list-group"))
                        for (const i of Kt.prev(e, Ns)) i.classList.add(Rs)
            }
            _clearActiveClass(t) {
                t.classList.remove(Rs);
                for (const e of Kt.find("".concat(Bs, ".").concat(Rs), t)) e.classList.remove(Rs)
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = Ws.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
        }
        vt.on(window, $t, () => {
            for (const t of Kt.find('[data-mdb-spy="scroll"]')) Ws.getOrCreateInstance(t)
        }), G(Ws);
        Ot = Ws;
        const Fs = "scrollspy";
        Ae = "mdb.".concat(Fs), St = ".".concat(Ae);
        const Vs = "activate.bs.scrollspy",
            zs = "activate".concat(St);
        e = "load".concat(St).concat(".data-api");
        const Ys = "collapsible-scrollspy";
        const Xs = ".".concat("active"),
            Us = ".".concat(Ys);
        class Ks extends Ot {
            constructor(t, e) {
                super(t, e), this._collapsibles = [], this._init()
            }
            dispose() {
                I.off(this._scrollElement, Vs), super.dispose()
            }
            static get NAME() {
                return Fs
            }
            _init() {
                this._bindActivateEvent(), this._getCollapsibles(), 0 !== this._collapsibles.length && (this._showSubsection(), this._hideSubsection())
            }
            _getHeight(t) {
                return t.offsetHeight
            }
            _hide(t) {
                const e = R.findOne("ul", t.parentNode);
                e.style.overflow = "hidden", e.style.height = "".concat(0, "px")
            }
            _show(t, e) {
                t.style.height = e
            }
            _getCollapsibles() {
                const t = R.find(Us);
                t && t.forEach(t => {
                    var e = t.parentNode,
                        i = R.findOne("ul", e),
                        e = i.offsetHeight;
                    this._collapsibles.push({
                        element: i,
                        relatedTarget: t.getAttribute("href"),
                        height: "".concat(e, "px")
                    })
                })
            }
            _showSubsection() {
                const t = R.find(Xs),
                    e = t.filter(t => P.hasClass(t, Ys));
                e.forEach(e => {
                    var t = R.findOne("ul", e.parentNode),
                        i = this._collapsibles.find(t => t.relatedTarget = e.getAttribute("href")).height;
                    this._show(t, i)
                })
            }
            _hideSubsection() {
                const t = R.find(Us).filter(t => !1 === P.hasClass(t, "active"));
                t.forEach(t => {
                    this._hide(t)
                })
            }
            _bindActivateEvent() {
                I.on(this._scrollElement, Vs, t => {
                    this._showSubsection(), this._hideSubsection(), I.trigger(this._scrollElement, zs, {
                        relatedTarget: t.relatedTarget
                    })
                })
            }
        }
        I.on(window, e, () => {
            R.find('[data-mdb-spy="scroll"]').forEach(t => {
                var e = Ks.getInstance(t);
                e || new Ks(t, P.getDataAttributes(t))
            })
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Fs];
                t.fn[Fs] = Ks.jQueryInterface, t.fn[Fs].Constructor = Ks, t.fn[Fs].noConflict = () => (t.fn[Fs] = e, Ks.jQueryInterface)
            }
        });
        var $s = Ks;
        Rt = ".".concat("bs.tab");
        const Qs = "hide".concat(Rt),
            qs = "hidden".concat(Rt),
            Zs = "show".concat(Rt),
            Gs = "shown".concat(Rt);
        Dt = "click".concat(Rt);
        const Js = "keydown".concat(Rt);
        At = "load".concat(Rt);
        const to = "ArrowLeft",
            eo = "ArrowRight",
            io = "ArrowUp",
            no = "ArrowDown",
            so = "active",
            oo = "show";
        Jt = ":not(.dropdown-toggle)";
        Ee = ".nav-link".concat(Jt, ", .list-group-item").concat(Jt, ', [role="tab"]').concat(Jt), $t = '[data-mdb-toggle="tab"], [data-mdb-toggle="pill"], [data-mdb-toggle="list"]';
        const ao = "".concat(Ee, ", ").concat($t),
            ro = ".".concat(so, '[data-mdb-toggle="tab"], .').concat(so, '[data-mdb-toggle="pill"], .').concat(so, '[data-mdb-toggle="list"]');
        class lo extends Et {
            constructor(t) {
                super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), vt.on(this._element, Js, t => this._keydown(t)))
            }
            static get NAME() {
                return "tab"
            }
            show() {
                var t, e, i = this._element;
                this._elemIsActive(i) || (e = (t = this._getActiveElem()) ? vt.trigger(t, Qs, {
                    relatedTarget: i
                }) : null, vt.trigger(i, Zs, {
                    relatedTarget: t
                }).defaultPrevented || e && e.defaultPrevented || (this._deactivate(t, i), this._activate(i, t)))
            }
            _activate(t, e) {
                t && (t.classList.add(so), this._activate(W(t)), this._queueCallback(() => {
                    "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), vt.trigger(t, Gs, {
                        relatedTarget: e
                    })) : t.classList.add(oo)
                }, t, t.classList.contains("fade")))
            }
            _deactivate(t, e) {
                t && (t.classList.remove(so), t.blur(), this._deactivate(W(t)), this._queueCallback(() => {
                    "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), vt.trigger(t, qs, {
                        relatedTarget: e
                    })) : t.classList.remove(oo)
                }, t, t.classList.contains("fade")))
            }
            _keydown(t) {
                if ([to, eo, io, no].includes(t.key)) {
                    t.stopPropagation(), t.preventDefault();
                    var e = [eo, no].includes(t.key);
                    const i = et(this._getChildren().filter(t => !X(t)), t.target, e, !0);
                    i && (i.focus({
                        preventScroll: !0
                    }), lo.getOrCreateInstance(i).show())
                }
            }
            _getChildren() {
                return Kt.find(ao, this._parent)
            }
            _getActiveElem() {
                return this._getChildren().find(t => this._elemIsActive(t)) || null
            }
            _setInitialAttributes(t, e) {
                this._setAttributeIfNotExists(t, "role", "tablist");
                for (const i of e) this._setInitialAttributesOnChild(i)
            }
            _setInitialAttributesOnChild(t) {
                t = this._getInnerElement(t);
                var e = this._elemIsActive(t),
                    i = this._getOuterElement(t);
                t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
            }
            _setInitialAttributesOnTargetPanel(t) {
                var e = W(t);
                e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", "#".concat(t.id)))
            }
            _toggleDropDown(t, n) {
                const s = this._getOuterElement(t);
                s.classList.contains("dropdown") && ((t = (t, e) => {
                    const i = Kt.findOne(t, s);
                    i && i.classList.toggle(e, n)
                })(".dropdown-toggle", so), t(".dropdown-menu", oo), s.setAttribute("aria-expanded", n))
            }
            _setAttributeIfNotExists(t, e, i) {
                t.hasAttribute(e) || t.setAttribute(e, i)
            }
            _elemIsActive(t) {
                return t.classList.contains(so)
            }
            _getInnerElement(t) {
                return t.matches(ao) ? t : Kt.findOne(ao, t)
            }
            _getOuterElement(t) {
                return t.closest(".nav-item, .list-group-item") || t
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = lo.getOrCreateInstance(this);
                    if ("string" == typeof e) {
                        if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
        }
        vt.on(document, Dt, $t, function(t) {
            ["A", "AREA"].includes(this.tagName) && t.preventDefault(), X(this) || lo.getOrCreateInstance(this).show()
        }), vt.on(window, At, () => {
            for (const t of Kt.find(ro)) lo.getOrCreateInstance(t)
        }), G(lo);
        Ae = lo;
        const co = "tab";
        St = "mdb.".concat(co), Ot = ".".concat(St);
        const ho = "show.bs.tab",
            uo = "shown.bs.tab",
            po = "show".concat(Ot),
            fo = "shown".concat(Ot),
            go = "hide".concat(Ot),
            _o = "hidden".concat(Ot);
        class mo extends Ae {
            dispose() {
                I.off(this._element, ho), I.off(this._element, uo), super.dispose()
            }
            static get NAME() {
                return co
            }
            show() {
                var i = this._element;
                if (!this._elemIsActive(i)) {
                    var n = this._getActiveElem();
                    let t = null,
                        e = null;
                    n && (t = I.trigger(n, "hide.bs.tab", {
                        relatedTarget: i
                    }), e = I.trigger(n, go, {
                        relatedTarget: i
                    }));
                    var s = I.trigger(i, ho, {
                            relatedTarget: n
                        }),
                        o = I.trigger(i, po, {
                            relatedTarget: n
                        });
                    s.defaultPrevented && o.defaultPrevented || t && t.defaultPrevented && e && e.defaultPrevented || (this._deactivate(n, i), this._activate(i, n))
                }
            }
            _activate(t, e) {
                t && (t.classList.add("active"), this._activate(o(t)), this._queueCallback(() => {
                    "tab" === t.getAttribute("role") ? (t.focus(), t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), I.trigger(t, uo, {
                        relatedTarget: e
                    }), I.trigger(t, fo, {
                        relatedTarget: e
                    })) : t.classList.add("show")
                }, t, t.classList.contains("fade")))
            }
            _deactivate(t, e) {
                t && (t.classList.remove("active"), t.blur(), this._deactivate(o(t)), this._queueCallback(() => {
                    "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), I.trigger(t, "hidden.bs.tab", {
                        relatedTarget: e
                    }), I.trigger(t, _o, {
                        relatedTarget: e
                    })) : t.classList.remove("show")
                }, t, t.classList.contains("fade")))
            }
        }
        R.find('[data-mdb-toggle="tab"], [data-mdb-toggle="pill"], [data-mdb-toggle="list"]').forEach(t => {
            var e = mo.getInstance(t);
            e || new mo(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn.tab;
                t.fn.tab = mo.jQueryInterface, t.fn.tab.Constructor = mo, t.fn.tab.noConflict = () => (t.fn.tab = e, mo.jQueryInterface)
            }
        });
        var vo = mo;
        const bo = "tooltip";
        e = "mdb.".concat(bo), Rt = ".".concat(e);
        const yo = "hide.bs.tooltip",
            xo = "hidden.bs.tooltip",
            wo = "show.bs.tooltip",
            Co = "shown.bs.tooltip",
            ko = "inserted.bs.tooltip",
            To = "hide".concat(Rt),
            So = "hidden".concat(Rt),
            Eo = "show".concat(Rt),
            Ao = "shown".concat(Rt),
            Mo = "inserted".concat(Rt);
        class Oo extends _s {
            constructor(t, e) {
                super(t, e), this._init()
            }
            dispose() {
                I.off(this._element, wo), I.off(this._element, Co), I.off(this._element, yo), I.off(this._element, xo), I.off(this._element, ko), super.dispose()
            }
            static get NAME() {
                return bo
            }
            _init() {
                this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent(), this._bindHidePreventedEvent()
            }
            _bindShowEvent() {
                I.on(this.element, wo, () => {
                    I.trigger(this.element, Eo)
                })
            }
            _bindShownEvent() {
                I.on(this.element, Co, () => {
                    I.trigger(this.element, Ao)
                })
            }
            _bindHideEvent() {
                I.on(this.element, yo, () => {
                    I.trigger(this.element, To)
                })
            }
            _bindHiddenEvent() {
                I.on(this.element, xo, () => {
                    I.trigger(this.element, So)
                })
            }
            _bindHidePreventedEvent() {
                I.on(this.element, ko, () => {
                    I.trigger(this.element, Mo)
                })
            }
        }
        R.find('[data-mdb-toggle="tooltip"]').forEach(t => {
            var e = Oo.getInstance(t);
            e || new Oo(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[bo];
                t.fn[bo] = Oo.jQueryInterface, t.fn[bo].Constructor = Oo, t.fn[bo].noConflict = () => (t.fn[bo] = e, Oo.jQueryInterface)
            }
        });
        var Io = Oo;
        i(105);
        const Do = "input",
            Lo = "mdb.input";
        Jt = "form-outline";
        const Po = "active",
            Ro = "form-notch",
            Bo = "form-notch-leading",
            No = "form-notch-middle";
        const Ho = ".".concat(Jt, " input"),
            jo = ".".concat(Jt, " textarea"),
            Wo = ".".concat(Ro),
            Fo = ".".concat(Bo),
            Vo = ".".concat(No),
            zo = ".".concat("form-helper");
        class Yo {
            constructor(t) {
                this._element = t, this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (p.setData(t, Lo, this), this.init())
            }
            static get NAME() {
                return Do
            }
            get input() {
                return R.findOne("input", this._element) || R.findOne("textarea", this._element)
            }
            init() {
                this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._initiated = !0)
            }
            update() {
                this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter()
            }
            forceActive() {
                P.addClass(this.input, Po)
            }
            forceInactive() {
                P.removeClass(this.input, Po)
            }
            dispose() {
                this._removeBorder(), p.removeData(this._element, Lo), this._element = null
            }
            _getLabelData() {
                this._label = R.findOne("label", this._element), null === this._label ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder())
            }
            _getHelper() {
                this._helper = R.findOne(zo, this._element)
            }
            _getCounter() {
                this._counter = P.getDataAttribute(this.input, "showcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter())
            }
            _showCounter() {
                var t;
                0 < R.find(".form-counter", this._element).length || (this._counterElement = document.createElement("div"), P.addClass(this._counterElement, "form-counter"), t = this.input.value.length, this._counterElement.innerHTML = "".concat(t, " / ").concat(this._maxLength), this._helper.appendChild(this._counterElement), this._bindCounter())
            }
            _bindCounter() {
                I.on(this.input, "input", () => {
                    var t = this.input.value.length;
                    this._counterElement.innerHTML = "".concat(t, " / ").concat(this._maxLength)
                })
            }
            _toggleDefaultDatePlaceholder(t = this.input) {
                "date" === t.getAttribute("type") && (document.activeElement === t || t.value ? t.style.opacity = 1 : t.style.opacity = 0)
            }
            _showPlaceholder() {
                P.addClass(this.input, "placeholder-active")
            }
            _getNotchData() {
                this._notchMiddle = R.findOne(Vo, this._element), this._notchLeading = R.findOne(Fo, this._element)
            }
            _getLabelWidth() {
                this._labelWidth = .8 * this._label.clientWidth + 8
            }
            _getLabelPositionInInputGroup() {
                var t;
                this._labelMarginLeft = 0, this._element.classList.contains("input-group") && (t = this.input, t = R.prev(t, ".input-group-text")[0], this._labelMarginLeft = void 0 === t ? 0 : t.offsetWidth - 1)
            }
            _applyDivs() {
                var t = R.find(Wo, this._element);
                const e = y("div");
                P.addClass(e, Ro), this._notchLeading = y("div"), P.addClass(this._notchLeading, Bo), this._notchMiddle = y("div"), P.addClass(this._notchMiddle, No), this._notchTrailing = y("div"), P.addClass(this._notchTrailing, "form-notch-trailing"), 1 <= t.length || (e.append(this._notchLeading), e.append(this._notchMiddle), e.append(this._notchTrailing), this._element.append(e))
            }
            _applyNotch() {
                this._notchMiddle.style.width = "".concat(this._labelWidth, "px"), this._notchLeading.style.width = "".concat(this._labelMarginLeft + 9, "px"), null !== this._label && (this._label.style.marginLeft = "".concat(this._labelMarginLeft, "px"))
            }
            _removeBorder() {
                const t = R.findOne(Wo, this._element);
                t && t.remove()
            }
            _activate(e) {
                c(() => {
                    this._getElements(e);
                    var t = e ? e.target : this.input;
                    "" !== t.value && P.addClass(t, Po), this._toggleDefaultDatePlaceholder(t)
                })
            }
            _getElements(t) {
                var e;
                t && (this._element = t.target.parentNode, this._label = R.findOne("label", this._element)), t && this._label && (e = this._labelWidth, this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = R.findOne(".form-notch-middle", t.target.parentNode), this._notchLeading = R.findOne(Fo, t.target.parentNode), this._applyNotch()))
            }
            _deactivate(t) {
                const e = t ? t.target : this.input;
                "" === e.value && e.classList.remove(Po), this._toggleDefaultDatePlaceholder(e)
            }
            static activate(e) {
                return function(t) {
                    e._activate(t)
                }
            }
            static deactivate(e) {
                return function(t) {
                    e._deactivate(t)
                }
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Lo);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Yo(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Lo)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        I.on(document, "focus", Ho, Yo.activate(new Yo)), I.on(document, "input", Ho, Yo.activate(new Yo)), I.on(document, "blur", Ho, Yo.deactivate(new Yo)), I.on(document, "focus", jo, Yo.activate(new Yo)), I.on(document, "input", jo, Yo.activate(new Yo)), I.on(document, "blur", jo, Yo.deactivate(new Yo)), I.on(window, "shown.bs.modal", t => {
            R.find(Ho, t.target).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            }), R.find(jo, t.target).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            })
        }), I.on(window, "shown.bs.dropdown", t => {
            t = t.target.parentNode.querySelector(".dropdown-menu");
            t && (R.find(Ho, t).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            }), R.find(jo, t).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            }))
        }), I.on(window, "shown.bs.tab", t => {
            let e;
            e = (t.target.href || P.getDataAttribute(t.target, "target")).split("#")[1];
            t = R.findOne("#".concat(e));
            R.find(Ho, t).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            }), R.find(jo, t).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.update()
            })
        }), R.find(".".concat(Jt)).map(t => new Yo(t)), I.on(window, "reset", t => {
            R.find(Ho, t.target).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.forceInactive()
            }), R.find(jo, t.target).forEach(t => {
                const e = Yo.getInstance(t.parentNode);
                e && e.forceInactive()
            })
        }), I.on(window, "onautocomplete", t => {
            const e = Yo.getInstance(t.target.parentNode);
            e && t.cancelable && e.forceActive()
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Do];
                t.fn[Do] = Yo.jQueryInterface, t.fn[Do].Constructor = Yo, t.fn[Do].noConflict = () => (t.fn[Do] = e, Yo.jQueryInterface)
            }
        });
        var Xo = Yo;
        const Uo = "dropdown";
        Ee = ".".concat("bs.dropdown"), Dt = ".data-api";
        const Ko = "ArrowUp",
            $o = "ArrowDown",
            Qo = "hide".concat(Ee),
            qo = "hidden".concat(Ee),
            Zo = "show".concat(Ee),
            Go = "shown".concat(Ee);
        $t = "click".concat(Ee).concat(Dt), At = "keydown".concat(Ee).concat(Dt), St = "keyup".concat(Ee).concat(Dt);
        const Jo = "show",
            ta = '[data-mdb-toggle="dropdown"]:not(.disabled):not(:disabled)',
            ea = "".concat(ta, ".").concat(Jo),
            ia = ".dropdown-menu",
            na = Z() ? "top-end" : "top-start",
            sa = Z() ? "top-start" : "top-end",
            oa = Z() ? "bottom-end" : "bottom-start",
            aa = Z() ? "bottom-start" : "bottom-end",
            ra = Z() ? "left-start" : "right-start",
            la = Z() ? "right-start" : "left-start",
            ca = {
                autoClose: !0,
                boundary: "clippingParents",
                display: "dynamic",
                offset: [0, 2],
                popperConfig: null,
                reference: "toggle"
            },
            ha = {
                autoClose: "(boolean|string)",
                boundary: "(string|element)",
                display: "string",
                offset: "(array|string|function)",
                popperConfig: "(null|object|function)",
                reference: "(string|element|object)"
            };
        class da extends Et {
            constructor(t, e) {
                super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = Kt.next(this._element, ia)[0] || Kt.prev(this._element, ia)[0] || Kt.findOne(ia, this._parent), this._inNavbar = this._detectNavbar()
            }
            static get Default() {
                return ca
            }
            static get DefaultType() {
                return ha
            }
            static get NAME() {
                return Uo
            }
            toggle() {
                return this._isShown() ? this.hide() : this.show()
            }
            show() {
                if (!X(this._element) && !this._isShown()) {
                    var t = {
                        relatedTarget: this._element
                    };
                    if (!vt.trigger(this._element, Zo, t).defaultPrevented) {
                        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
                            for (const e of [].concat(...document.body.children)) vt.on(e, "mouseover", K);
                        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Jo), this._element.classList.add(Jo), vt.trigger(this._element, Go, t)
                    }
                }
            }
            hide() {
                var t;
                !X(this._element) && this._isShown() && (t = {
                    relatedTarget: this._element
                }, this._completeHide(t))
            }
            dispose() {
                this._popper && this._popper.destroy(), super.dispose()
            }
            update() {
                this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
            }
            _completeHide(t) {
                if (!vt.trigger(this._element, Qo, t).defaultPrevented) {
                    if ("ontouchstart" in document.documentElement)
                        for (const e of [].concat(...document.body.children)) vt.off(e, "mouseover", K);
                    this._popper && this._popper.destroy(), this._menu.classList.remove(Jo), this._element.classList.remove(Jo), this._element.setAttribute("aria-expanded", "false"), Tt.removeDataAttribute(this._menu, "popper"), vt.trigger(this._element, qo, t)
                }
            }
            _getConfig(t) {
                if ("object" == typeof(t = super._getConfig(t)).reference && !V(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError("".concat(Uo.toUpperCase(), ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.'));
                return t
            }
            _createPopper() {
                if (void 0 === n) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                let t = this._element;
                "parent" === this._config.reference ? t = this._parent : V(this._config.reference) ? t = z(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
                var e = this._getPopperConfig();
                this._popper = Qn(t, this._menu, e)
            }
            _isShown() {
                return this._menu.classList.contains(Jo)
            }
            _getPlacement() {
                const t = this._parent;
                if (t.classList.contains("dropend")) return ra;
                if (t.classList.contains("dropstart")) return la;
                if (t.classList.contains("dropup-center")) return "top";
                if (t.classList.contains("dropdown-center")) return "bottom";
                var e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                return t.classList.contains("dropup") ? e ? sa : na : e ? aa : oa
            }
            _detectNavbar() {
                return null !== this._element.closest(".navbar")
            }
            _getOffset() {
                const e = this._config["offset"];
                return "string" == typeof e ? e.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof e ? t => e(t, this._element) : e
            }
            _getPopperConfig() {
                const t = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }]
                };
                return !this._inNavbar && "static" !== this._config.display || (Tt.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]), { ...t,
                    ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
                }
            }
            _selectMenuItem({
                key: t,
                target: e
            }) {
                const i = Kt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(t => Y(t));
                i.length && et(i, e, t === $o, !i.includes(e)).focus()
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = da.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e]()
                    }
                })
            }
            static clearMenus(t) {
                if (2 !== t.button && ("keyup" !== t.type || "Tab" === t.key))
                    for (const i of Kt.find(ea)) {
                        const n = da.getInstance(i);
                        if (n && !1 !== n._config.autoClose) {
                            const s = t.composedPath();
                            var e = s.includes(n._menu);
                            if (!(s.includes(n._element) || "inside" === n._config.autoClose && !e || "outside" === n._config.autoClose && e || n._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName)))) {
                                const o = {
                                    relatedTarget: n._element
                                };
                                "click" === t.type && (o.clickEvent = t), n._completeHide(o)
                            }
                        }
                    }
            }
            static dataApiKeydownHandler(t) {
                var e = /input|textarea/i.test(t.target.tagName),
                    i = "Escape" === t.key,
                    n = [Ko, $o].includes(t.key);
                if ((n || i) && (!e || i)) {
                    t.preventDefault();
                    const s = this.matches(ta) ? this : Kt.prev(this, ta)[0] || Kt.next(this, ta)[0] || Kt.findOne(ta, t.delegateTarget.parentNode),
                        o = da.getOrCreateInstance(s);
                    if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
                    o._isShown() && (t.stopPropagation(), o.hide(), s.focus())
                }
            }
        }
        vt.on(document, At, ta, da.dataApiKeydownHandler), vt.on(document, At, ia, da.dataApiKeydownHandler), vt.on(document, $t, da.clearMenus), vt.on(document, St, da.clearMenus), vt.on(document, $t, ta, function(t) {
            t.preventDefault(), da.getOrCreateInstance(this).toggle()
        }), G(da);
        Ot = da;
        const ua = "dropdown";
        Ae = "mdb.".concat(ua), e = ".".concat(Ae);
        const pa = {
                offset: [0, 2],
                flip: !0,
                boundary: "clippingParents",
                reference: "toggle",
                display: "dynamic",
                popperConfig: null,
                dropdownAnimation: "on"
            },
            fa = {
                offset: "(array|string|function)",
                flip: "boolean",
                boundary: "(string|element)",
                reference: "(string|element|object)",
                display: "string",
                popperConfig: "(null|object|function)",
                dropdownAnimation: "string"
            },
            ga = "hide.bs.dropdown",
            _a = "hidden.bs.dropdown",
            ma = "show.bs.dropdown",
            va = "shown.bs.dropdown",
            ba = "hide".concat(e),
            ya = "hidden".concat(e),
            xa = "show".concat(e),
            wa = "shown".concat(e),
            Ca = "animation",
            ka = "fade-in",
            Ta = "fade-out";
        class Sa extends Ot {
            constructor(t, e) {
                super(t, e), this._config = this._getConfig(e), this._menuStyle = "", this._popperPlacement = "", this._mdbPopperConfig = "";
                e = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
                "on" !== this._config.dropdownAnimation || e || this._init()
            }
            dispose() {
                I.off(this._element, ma), I.off(this._parent, va), I.off(this._parent, ga), I.off(this._parent, _a), super.dispose()
            }
            static get NAME() {
                return ua
            }
            _init() {
                this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent()
            }
            _getConfig(t) {
                t = { ...pa,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(ua, t, fa), t
            }
            _getOffset() {
                const e = this._config["offset"];
                return "string" == typeof e ? e.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof e ? t => e(t, this._element) : e
            }
            _getPopperConfig() {
                const t = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            altBoundary: this._config.flip,
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }]
                };
                return "static" === this._config.display && (t.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]), { ...t,
                    ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
                }
            }
            _bindShowEvent() {
                I.on(this._element, ma, t => {
                    I.trigger(this._element, xa, {
                        relatedTarget: t.relatedTarget
                    }).defaultPrevented ? t.preventDefault() : this._dropdownAnimationStart("show")
                })
            }
            _bindShownEvent() {
                I.on(this._parent, va, t => {
                    I.trigger(this._parent, wa, {
                        relatedTarget: t.relatedTarget
                    }).defaultPrevented && t.preventDefault()
                })
            }
            _bindHideEvent() {
                I.on(this._parent, ga, t => {
                    I.trigger(this._parent, ba, {
                        relatedTarget: t.relatedTarget
                    }).defaultPrevented ? t.preventDefault() : (this._menuStyle = this._menu.style.cssText, this._popperPlacement = this._menu.getAttribute("data-popper-placement"), this._mdbPopperConfig = this._menu.getAttribute("data-mdb-popper"))
                })
            }
            _bindHiddenEvent() {
                I.on(this._parent, _a, t => {
                    I.trigger(this._parent, ya, {
                        relatedTarget: t.relatedTarget
                    }).defaultPrevented ? t.preventDefault() : ("static" !== this._config.display && "" !== this._menuStyle && (this._menu.style.cssText = this._menuStyle), this._menu.setAttribute("data-popper-placement", this._popperPlacement), this._menu.setAttribute("data-mdb-popper", this._mdbPopperConfig), this._dropdownAnimationStart("hide"))
                })
            }
            _dropdownAnimationStart(t) {
                "show" === t ? (this._menu.classList.add(Ca, ka), this._menu.classList.remove(Ta)) : (this._menu.classList.add(Ca, Ta), this._menu.classList.remove(ka)), this._bindAnimationEnd()
            }
            _bindAnimationEnd() {
                I.one(this._menu, "animationend", () => {
                    this._menu.classList.remove(Ca, Ta, ka)
                })
            }
        }
        R.find('[data-mdb-toggle="dropdown"]').forEach(t => {
            var e = Sa.getInstance(t);
            e || new Sa(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[ua];
                t.fn[ua] = Sa.jQueryInterface, t.fn[ua].Constructor = Sa, t.fn[ua].noConflict = () => (t.fn[ua] = e, Sa.jQueryInterface)
            }
        });
        var Ea = Sa;
        const Aa = "ripple",
            Ma = "mdb.ripple",
            Oa = "ripple-surface",
            Ia = "ripple-wave",
            Da = "input-wrapper",
            La = [".btn", ".ripple"],
            Pa = "ripple-surface-unbound",
            Ra = [0, 0, 0],
            Ba = ["primary", "secondary", "success", "danger", "warning", "info", "light", "dark"],
            Na = {
                rippleCentered: !1,
                rippleColor: "",
                rippleDuration: "500ms",
                rippleRadius: 0,
                rippleUnbound: !1
            },
            Ha = {
                rippleCentered: "boolean",
                rippleColor: "string",
                rippleDuration: "string",
                rippleRadius: "number",
                rippleUnbound: "boolean"
            };
        class ja {
            constructor(t, e) {
                this._element = t, this._options = this._getConfig(e), this._element && (p.setData(t, Ma, this), P.addClass(this._element, Oa)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._rippleInSpan = !1, this.init()
            }
            static get NAME() {
                return Aa
            }
            init() {
                this._addClickEvent(this._element)
            }
            dispose() {
                p.removeData(this._element, Ma), I.off(this._element, "click", this._clickHandler), this._element = null, this._options = null
            }
            _autoInit(e) {
                if (La.forEach(t => {
                        R.closest(e.target, t) && (this._element = R.closest(e.target, t))
                    }), this._options = this._getConfig(), "input" === this._element.tagName.toLowerCase()) {
                    const i = this._element.parentNode;
                    if (this._rippleInSpan = !0, "span" === i.tagName.toLowerCase() && i.classList.contains(Oa)) this._element = i;
                    else {
                        var t = getComputedStyle(this._element).boxShadow;
                        const n = this._element,
                            s = document.createElement("span");
                        I.one(s, "mouseup", () => {
                            n.click()
                        }), s.classList.add(Oa, Da), P.addStyle(s, {
                            border: 0,
                            "box-shadow": t
                        }), i.replaceChild(s, this._element), s.appendChild(this._element), this._element = s
                    }
                    this._element.focus()
                }
                this._element.style.minWidth || (P.style(this._element, {
                    "min-width": "".concat(getComputedStyle(this._element).width)
                }), this._isMinWidthSet = !0), P.addClass(this._element, Oa), this._createRipple(e)
            }
            _addClickEvent(t) {
                I.on(t, "mousedown", this._clickHandler)
            }
            _getEventLayer(t) {
                return {
                    layerX: Math.round(t.clientX - t.target.getBoundingClientRect().x),
                    layerY: Math.round(t.clientY - t.target.getBoundingClientRect().y)
                }
            }
            _createRipple(t) {
                P.hasClass(this._element, Oa) || P.addClass(this._element, Oa);
                var {
                    layerX: e,
                    layerY: i
                } = this._getEventLayer(t), n = e, s = i, o = this._element.offsetHeight, a = this._element.offsetWidth, r = this._durationToMsNumber(this._options.rippleDuration), t = {
                    offsetX: this._options.rippleCentered ? o / 2 : n,
                    offsetY: this._options.rippleCentered ? a / 2 : s,
                    height: o,
                    width: a
                }, e = this._getDiameter(t), i = this._options.rippleRadius || e / 2, t = {
                    delay: .5 * r,
                    duration: r - .5 * r
                }, e = {
                    left: this._options.rippleCentered ? "".concat(a / 2 - i, "px") : "".concat(n - i, "px"),
                    top: this._options.rippleCentered ? "".concat(o / 2 - i, "px") : "".concat(s - i, "px"),
                    height: "".concat(2 * this._options.rippleRadius || e, "px"),
                    width: "".concat(2 * this._options.rippleRadius || e, "px"),
                    transitionDelay: "0s, ".concat(t.delay, "ms"),
                    transitionDuration: "".concat(r, "ms, ").concat(t.duration, "ms")
                }, t = y("div");
                this._createHTMLRipple({
                    wrapper: this._element,
                    ripple: t,
                    styles: e
                }), this._removeHTMLRipple({
                    ripple: t,
                    duration: r
                })
            }
            _createHTMLRipple({
                wrapper: t,
                ripple: e,
                styles: i
            }) {
                Object.keys(i).forEach(t => e.style[t] = i[t]), e.classList.add(Ia), "" !== this._options.rippleColor && (this._removeOldColorClasses(t), this._addColor(e, t)), this._toggleUnbound(t), this._appendRipple(e, t)
            }
            _removeHTMLRipple({
                ripple: t,
                duration: e
            }) {
                this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), this._rippleTimer = setTimeout(() => {
                    t && (t.remove(), this._element && (R.find(".".concat(Ia), this._element).forEach(t => {
                        t.remove()
                    }), this._isMinWidthSet && (P.style(this._element, {
                        "min-width": ""
                    }), this._isMinWidthSet = !1), this._rippleInSpan && this._element.classList.contains(Da) ? this._removeWrapperSpan() : P.removeClass(this._element, Oa)))
                }, e)
            }
            _removeWrapperSpan() {
                var t = this._element.firstChild;
                this._element.replaceWith(t), this._element = t, this._element.focus(), this._rippleInSpan = !1
            }
            _durationToMsNumber(t) {
                return Number(t.replace("ms", "").replace("s", "000"))
            }
            _getConfig(t = {}) {
                var e = P.getDataAttributes(this._element);
                return t = { ...Na,
                    ...e,
                    ...t
                }, a(Aa, t, Ha), t
            }
            _getDiameter({
                offsetX: t,
                offsetY: e,
                height: i,
                width: n
            }) {
                var s = e <= i / 2,
                    o = t <= n / 2,
                    a = (t, e) => Math.sqrt(t ** 2 + e ** 2),
                    r = e === i / 2 && t === n / 2;
                const l = !0 == s && !1 == o,
                    c = !0 == s && !0 == o,
                    h = !1 == s && !0 == o,
                    d = !1 == s && !1 == o;
                e = {
                    topLeft: a(t, e),
                    topRight: a(n - t, e),
                    bottomLeft: a(t, i - e),
                    bottomRight: a(n - t, i - e)
                };
                let u = 0;
                return r || d ? u = e.topLeft : h ? u = e.topRight : c ? u = e.bottomRight : l && (u = e.bottomLeft), 2 * u
            }
            _appendRipple(t, e) {
                e.appendChild(t), setTimeout(() => {
                    P.addClass(t, "active")
                }, 50)
            }
            _toggleUnbound(t) {
                !0 === this._options.rippleUnbound ? P.addClass(t, Pa) : t.classList.remove(Pa)
            }
            _addColor(t, e) {
                Ba.find(t => t === this._options.rippleColor.toLowerCase()) ? P.addClass(e, "".concat(Oa, "-").concat(this._options.rippleColor.toLowerCase())) : (e = this._colorToRGB(this._options.rippleColor).join(","), e = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%".split("{{color}}").join("".concat(e)), t.style.backgroundImage = "radial-gradient(circle, ".concat(e, ")"))
            }
            _removeOldColorClasses(e) {
                var t = new RegExp("".concat(Oa, "-[a-z]+"), "gi");
                const i = e.classList.value.match(t) || [];
                i.forEach(t => {
                    e.classList.remove(t)
                })
            }
            _colorToRGB(t) {
                return "transparent" === t.toLowerCase() ? Ra : "#" === t[0] ? ((e = t).length < 7 && (e = "#".concat(e[1]).concat(e[1]).concat(e[2]).concat(e[2]).concat(e[3]).concat(e[3])), [parseInt(e.substr(1, 2), 16), parseInt(e.substr(3, 2), 16), parseInt(e.substr(5, 2), 16)]) : 0 === (t = -1 === t.indexOf("rgb") ? function(t) {
                    const e = document.body.appendChild(document.createElement("fictum"));
                    var i = "rgb(1, 2, 3)";
                    return e.style.color = i, e.style.color !== i ? Ra : (e.style.color = t, e.style.color === i || "" === e.style.color ? Ra : (t = getComputedStyle(e).color, document.body.removeChild(e), t))
                }(t) : t).indexOf("rgb") ? ((i = (i = t).match(/[.\d]+/g).map(t => +Number(t))).length = 3, i) : Ra;
                var e, i
            }
            static autoInitial(e) {
                return function(t) {
                    e._autoInit(t)
                }
            }
            static jQueryInterface(t) {
                return this.each(function() {
                    return p.getData(this, Ma) ? null : new ja(this, t)
                })
            }
            static getInstance(t) {
                return p.getData(t, Ma)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        La.forEach(t => {
            I.one(document, "mousedown", t, ja.autoInitial(new ja))
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Aa];
                t.fn[Aa] = ja.jQueryInterface, t.fn[Aa].Constructor = ja, t.fn[Aa].noConflict = () => (t.fn[Aa] = e, ja.jQueryInterface)
            }
        });
        var Wa = ja;
        const Fa = "range",
            Va = "mdb.range";
        const za = "thumb-active";
        const Ya = ".".concat("thumb-value");
        Rt = ".".concat("range");
        class Xa {
            constructor(t) {
                this._element = t, this._initiated = !1, this._element && (p.setData(t, Va, this), this.init())
            }
            static get NAME() {
                return Fa
            }
            get rangeInput() {
                return R.findOne("input[type=range]", this._element)
            }
            init() {
                this._initiated || (this._addThumb(), this._updateValue(), this._thumbPositionUpdate(), this._handleEvents(), this._initiated = !0)
            }
            dispose() {
                this._disposeEvents(), p.removeData(this._element, Va), this._element = null
            }
            _addThumb() {
                const t = y("span");
                P.addClass(t, "thumb"), t.innerHTML = '<span class="thumb-value"></span>', this._element.append(t)
            }
            _updateValue() {
                const t = R.findOne(Ya, this._element);
                t.textContent = this.rangeInput.value, this.rangeInput.oninput = () => t.textContent = this.rangeInput.value
            }
            _handleEvents() {
                I.on(this.rangeInput, "mousedown", () => this._showThumb()), I.on(this.rangeInput, "mouseup", () => this._hideThumb()), I.on(this.rangeInput, "touchstart", () => this._showThumb()), I.on(this.rangeInput, "touchend", () => this._hideThumb()), I.on(this.rangeInput, "input", () => this._thumbPositionUpdate())
            }
            _disposeEvents() {
                I.off(this.rangeInput, "mousedown", this._showThumb), I.off(this.rangeInput, "mouseup", this._hideThumb), I.off(this.rangeInput, "touchstart", this._showThumb), I.off(this.rangeInput, "touchend", this._hideThumb), I.off(this.rangeInput, "input", this._thumbPositionUpdate)
            }
            _showThumb() {
                P.addClass(this._element.lastElementChild, za)
            }
            _hideThumb() {
                P.removeClass(this._element.lastElementChild, za)
            }
            _thumbPositionUpdate() {
                var t = this.rangeInput,
                    e = t.value,
                    i = t.min || 0,
                    t = t.max || 100;
                const n = this._element.lastElementChild;
                i = Number(100 * (e - i) / (t - i));
                n.firstElementChild.textContent = e, P.style(n, {
                    left: "calc(".concat(i, "% + (").concat(8 - .15 * i, "px))")
                })
            }
            static getInstance(t) {
                return p.getData(t, Va)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Va);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Xa(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
        }
        R.find(Rt).map(t => new Xa(t)), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Fa];
                t.fn[Fa] = Xa.jQueryInterface, t.fn[Fa].Constructor = Xa, t.fn[Fa].noConflict = () => (t.fn[Fa] = e, Xa.jQueryInterface)
            }
        });
        var Ua = Xa;
        const Ka = "animation",
            $a = "mdb.animation";
        const Qa = {
                animation: "string",
                animationStart: "string",
                animationShowOnLoad: "boolean",
                onStart: "(null|function)",
                onEnd: "(null|function)",
                onHide: "(null|function)",
                onShow: "(null|function)",
                animationOnScroll: "(string)",
                animationWindowHeight: "number",
                animationOffset: "(number|string)",
                animationDelay: "(number|string)",
                animationDuration: "(number|string)",
                animationReverse: "boolean",
                animationInterval: "(number|string)",
                animationRepeat: "(number|boolean)",
                animationReset: "boolean"
            },
            qa = {
                animation: "fade",
                animationStart: "onClick",
                animationShowOnLoad: !0,
                onStart: null,
                onEnd: null,
                onHide: null,
                onShow: null,
                animationOnScroll: "once",
                animationWindowHeight: 0,
                animationOffset: 0,
                animationDelay: 0,
                animationDuration: 500,
                animationReverse: !1,
                animationInterval: 0,
                animationRepeat: !1,
                animationReset: !1
            };
        class Za {
            constructor(t, e) {
                this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && p.setData(t, $a, this)
            }
            static get NAME() {
                return Ka
            }
            init() {
                this._init()
            }
            startAnimation() {
                this._startAnimation()
            }
            stopAnimation() {
                this._clearAnimationClass()
            }
            changeAnimationType(t) {
                this._options.animation = t
            }
            dispose() {
                I.off(this._element, "mousedown"), I.off(this._animateElement, "animationend"), I.off(window, "scroll"), I.off(this._element, "mouseover"), p.removeData(this._element, $a), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null
            }
            _init() {
                switch (this._options.animationStart) {
                    case "onHover":
                        this._bindHoverEvents();
                        break;
                    case "onLoad":
                        this._startAnimation();
                        break;
                    case "onScroll":
                        this._bindScrollEvents();
                        break;
                    case "onClick":
                        this._bindClickEvents()
                }
                this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish()
            }
            _getAnimateElement() {
                var t = P.getDataAttribute(this._element, "animation-target");
                return t ? R.find(t)[0] : this._element
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._animateElement);
                return t = { ...qa,
                    ...e,
                    ...t
                }, a(Ka, t, Qa), t
            }
            _animateOnScroll() {
                var t = P.offset(this._animateElement).top,
                    e = this._animateElement.offsetHeight,
                    i = window.innerHeight,
                    t = t + this._options.animationOffset <= i && 0 <= t + this._options.animationOffset + e,
                    e = "visible" === this._animateElement.style.visibility;
                switch (!0) {
                    case t && this._isFirstScroll:
                        this._isFirstScroll = !1, this._startAnimation();
                        break;
                    case !t && this._isFirstScroll:
                        this._isFirstScroll = !1, this._hideAnimateElement();
                        break;
                    case t && !e && this._repeatAnimateOnScroll:
                        "repeat" !== this._options.animationOnScroll && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
                        break;
                    case !t && e && this._repeatAnimateOnScroll:
                        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide)
                }
            }
            _addAnimatedClass() {
                P.addClass(this._animateElement, "animation"), P.addClass(this._animateElement, this._options.animation)
            }
            _clearAnimationClass() {
                this._animateElement.classList.remove(this._options.animation, "animation")
            }
            _startAnimation() {
                this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval()
            }
            _setAnimationReverse() {
                P.style(this._animateElement, {
                    animationIterationCount: !0 === this._options.animationRepeat ? "infinite" : "2",
                    animationDirection: "alternate"
                })
            }
            _setAnimationDuration() {
                P.style(this._animateElement, {
                    animationDuration: "".concat(this._options.animationDuration, "ms")
                })
            }
            _setAnimationDelay() {
                P.style(this._animateElement, {
                    animationDelay: "".concat(this._options.animationDelay, "ms")
                })
            }
            _setAnimationRepeat() {
                P.style(this._animateElement, {
                    animationIterationCount: !0 === this._options.animationRepeat ? "infinite" : this._options.animationRepeat
                })
            }
            _setAnimationInterval() {
                I.on(this._animateElement, "animationend", () => {
                    this._clearAnimationClass(), setTimeout(() => {
                        this._addAnimatedClass()
                    }, this._options.animationInterval)
                })
            }
            _hideAnimateElement() {
                P.style(this._animateElement, {
                    visibility: "hidden"
                })
            }
            _showAnimateElement() {
                P.style(this._animateElement, {
                    visibility: "visible"
                })
            }
            _bindResetAnimationAfterFinish() {
                I.on(this._animateElement, "animationend", () => {
                    this._clearAnimationClass()
                })
            }
            _bindTriggerOnEndCallback() {
                I.on(this._animateElement, "animationend", () => {
                    this._callback(this._options.onEnd)
                })
            }
            _bindScrollEvents() {
                this._options.animationShowOnLoad || this._animateOnScroll(), I.on(window, "scroll", () => {
                    this._animateOnScroll()
                })
            }
            _bindClickEvents() {
                I.on(this._element, "mousedown", () => {
                    this._startAnimation()
                })
            }
            _bindHoverEvents() {
                I.one(this._element, "mouseover", () => {
                    this._startAnimation()
                }), I.one(this._animateElement, "animationend", () => {
                    setTimeout(() => {
                        this._bindHoverEvents()
                    }, 100)
                })
            }
            _callback(t) {
                t instanceof Function && t()
            }
            static autoInit(t) {
                t._init()
            }
            static jQueryInterface(t) {
                const e = new Za(this[0], t);
                e.init()
            }
            static getInstance(t) {
                return p.getData(t, $a)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find('[data-mdb-toggle="animation"]').forEach(t => {
            Za.autoInit(new Za(t))
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Ka];
                t.fn[Ka] = Za.jQueryInterface, t.fn[Ka].Constructor = Za, t.fn[Ka].noConflict = () => (t.fn[Ka] = e, Za.jQueryInterface)
            }
        });
        var Ga = Za;
        /*!
         * Chart.js v3.7.1
         * https://www.chartjs.org
         * (c) 2022 Chart.js Contributors
         * Released under the MIT License
         */
        const Ja = "undefined" == typeof window ? function(t) {
            return t()
        } : window.requestAnimationFrame;

        function tr(e, i, t) {
            const n = t || (t => Array.prototype.slice.call(t));
            let s = !1,
                o;
            return function(...t) {
                o = n(t), s || (s = !0, Ja.call(window, () => {
                    s = !1, e.apply(i, o)
                }))
            }
        }
        const er = t => "start" === t ? "left" : "end" === t ? "right" : "center",
            ir = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2;

        function nr() {}
        const sr = function() {
            let t = 0;
            return function() {
                return t++
            }
        }();

        function or(t) {
            return null == t
        }

        function ar(t) {
            if (Array.isArray && Array.isArray(t)) return !0;
            const e = Object.prototype.toString.call(t);
            return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6)
        }

        function rr(t) {
            return null !== t && "[object Object]" === Object.prototype.toString.call(t)
        }
        const lr = t => ("number" == typeof t || t instanceof Number) && isFinite(+t);

        function cr(t, e) {
            return lr(t) ? t : e
        }

        function hr(t, e) {
            return void 0 === t ? e : t
        }
        const dr = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

        function ur(t, e, i) {
            if (t && "function" == typeof t.call) return t.apply(i, e)
        }

        function pr(t, e, i, n) {
            let s, o, a;
            if (ar(t))
                if (o = t.length, n)
                    for (s = o - 1; 0 <= s; s--) e.call(i, t[s], s);
                else
                    for (s = 0; s < o; s++) e.call(i, t[s], s);
            else if (rr(t))
                for (a = Object.keys(t), o = a.length, s = 0; s < o; s++) e.call(i, t[a[s]], a[s])
        }

        function fr(t, e) {
            let i, n, s, o;
            if (t && e && t.length === e.length) {
                for (i = 0, n = t.length; i < n; ++i)
                    if (s = t[i], o = e[i], s.datasetIndex !== o.datasetIndex || s.index !== o.index) return;
                return 1
            }
        }

        function gr(e) {
            if (ar(e)) return e.map(gr);
            if (rr(e)) {
                const s = Object.create(null);
                var i = Object.keys(e),
                    n = i.length;
                let t = 0;
                for (; t < n; ++t) s[i[t]] = gr(e[i[t]]);
                return s
            }
            return e
        }

        function _r(t) {
            return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
        }

        function mr(t, e, i, n) {
            var s;
            _r(t) && (s = e[t], i = i[t], rr(s) && rr(i) ? vr(s, i, n) : e[t] = gr(i))
        }

        function vr(i, n, s) {
            var e = ar(n) ? n : [n],
                o = e.length;
            if (!rr(i)) return i;
            const a = (s = s || {}).merger || mr;
            for (let t = 0; t < o; ++t)
                if (rr(n = e[t])) {
                    var r = Object.keys(n);
                    for (let t = 0, e = r.length; t < e; ++t) a(r[t], i, n, s)
                }
            return i
        }

        function br(t, e) {
            return vr(t, e, {
                merger: yr
            })
        }

        function yr(t, e, i) {
            var n;
            _r(t) && (n = e[t], i = i[t], rr(n) && rr(i) ? br(n, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = gr(i)))
        }
        const xr = "",
            wr = ".";

        function Cr(t, e) {
            e = t.indexOf(wr, e);
            return -1 === e ? t.length : e
        }

        function kr(t, e) {
            if (e === xr) return t;
            let i = 0,
                n = Cr(e, i);
            for (; t && n > i;) t = t[e.substr(i, n - i)], i = n + 1, n = Cr(e, i);
            return t
        }

        function Tr(t) {
            return t.charAt(0).toUpperCase() + t.slice(1)
        }
        const Sr = t => void 0 !== t,
            Er = t => "function" == typeof t,
            Ar = (t, e) => {
                if (t.size !== e.size) return !1;
                for (const i of t)
                    if (!e.has(i)) return !1;
                return !0
            };
        const Mr = Math.PI,
            Or = 2 * Mr,
            Ir = Or + Mr,
            Dr = Number.POSITIVE_INFINITY,
            Lr = Mr / 180,
            Pr = Mr / 2,
            Rr = Mr / 4,
            Br = 2 * Mr / 3,
            Nr = Math.log10,
            Hr = Math.sign;

        function jr(t) {
            var e = Math.round(t);
            t = Fr(t, e, t / 1e3) ? e : t;
            e = Math.pow(10, Math.floor(Nr(t))), t /= e;
            return (t <= 1 ? 1 : t <= 2 ? 2 : t <= 5 ? 5 : 10) * e
        }

        function Wr(t) {
            return !isNaN(parseFloat(t)) && isFinite(t)
        }

        function Fr(t, e, i) {
            return Math.abs(t - e) < i
        }

        function Vr(t, e, i) {
            let n, s, o;
            for (n = 0, s = t.length; n < s; n++) o = t[n][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))
        }

        function zr(t) {
            return t * (Mr / 180)
        }

        function Yr(t) {
            return t * (180 / Mr)
        }

        function Xr(i) {
            if (lr(i)) {
                let t = 1,
                    e = 0;
                for (; Math.round(i * t) / t !== i;) t *= 10, e++;
                return e
            }
        }

        function Ur(t, e) {
            var i = e.x - t.x,
                e = e.y - t.y,
                t = Math.sqrt(i * i + e * e);
            let n = Math.atan2(e, i);
            return n < -.5 * Mr && (n += Or), {
                angle: n,
                distance: t
            }
        }

        function Kr(t, e) {
            return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
        }

        function $r(t, e) {
            return (t - e + Ir) % Or - Mr
        }

        function Qr(t) {
            return (t % Or + Or) % Or
        }

        function qr(t, e, i, n) {
            var s = Qr(t),
                o = Qr(e),
                a = Qr(i),
                r = Qr(o - s),
                t = Qr(a - s),
                e = Qr(s - o),
                i = Qr(s - a);
            return s === o || s === a || n && o === a || t < r && e < i
        }

        function Zr(t, e, i) {
            return Math.max(e, Math.min(i, t))
        }

        function Gr(t, e, i, n = 1e-6) {
            return t >= Math.min(e, i) - n && t <= Math.max(e, i) + n
        }
        const Jr = t => 0 === t || 1 === t,
            tl = (t, e, i) => -(Math.pow(2, 10 * --t) * Math.sin((t - e) * Or / i)),
            el = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * Or / i) + 1,
            il = {
                linear: t => t,
                easeInQuad: t => t * t,
                easeOutQuad: t => -t * (t - 2),
                easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
                easeInCubic: t => t * t * t,
                easeOutCubic: t => --t * t * t + 1,
                easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
                easeInQuart: t => t * t * t * t,
                easeOutQuart: t => -(--t * t * t * t - 1),
                easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
                easeInQuint: t => t * t * t * t * t,
                easeOutQuint: t => --t * t * t * t * t + 1,
                easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
                easeInSine: t => 1 - Math.cos(t * Pr),
                easeOutSine: t => Math.sin(t * Pr),
                easeInOutSine: t => -.5 * (Math.cos(Mr * t) - 1),
                easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
                easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
                easeInOutExpo: t => Jr(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
                easeInCirc: t => 1 <= t ? t : -(Math.sqrt(1 - t * t) - 1),
                easeOutCirc: t => Math.sqrt(1 - --t * t),
                easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
                easeInElastic: t => Jr(t) ? t : tl(t, .075, .3),
                easeOutElastic: t => Jr(t) ? t : el(t, .075, .3),
                easeInOutElastic(t) {
                    return Jr(t) ? t : t < .5 ? .5 * tl(2 * t, .1125, .45) : .5 + .5 * el(2 * t - 1, .1125, .45)
                },
                easeInBack(t) {
                    return t * t * (2.70158 * t - 1.70158)
                },
                easeOutBack(t) {
                    return --t * t * (2.70158 * t + 1.70158) + 1
                },
                easeInOutBack(t) {
                    let e = 1.70158;
                    return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
                },
                easeInBounce: t => 1 - il.easeOutBounce(1 - t),
                easeOutBounce(t) {
                    var e = 7.5625;
                    return t < 1 / 2.75 ? e * t * t : t < 2 / 2.75 ? e * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? e * (t -= 2.25 / 2.75) * t + .9375 : e * (t -= 2.625 / 2.75) * t + .984375
                },
                easeInOutBounce: t => t < .5 ? .5 * il.easeInBounce(2 * t) : .5 * il.easeOutBounce(2 * t - 1) + .5
            },
            nl = {
                0: 0,
                1: 1,
                2: 2,
                3: 3,
                4: 4,
                5: 5,
                6: 6,
                7: 7,
                8: 8,
                9: 9,
                A: 10,
                B: 11,
                C: 12,
                D: 13,
                E: 14,
                F: 15,
                a: 10,
                b: 11,
                c: 12,
                d: 13,
                e: 14,
                f: 15
            },
            sl = "0123456789ABCDEF",
            ol = t => sl[15 & t],
            al = t => sl[(240 & t) >> 4] + sl[15 & t],
            rl = t => (240 & t) >> 4 == (15 & t);

        function ll(t) {
            var e, e = (e = t, rl(e.r) && rl(e.g) && rl(e.b) && rl(e.a) ? ol : al);
            return t && "#" + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : "")
        }

        function cl(t) {
            return t + .5 | 0
        }
        const hl = (t, e, i) => Math.max(Math.min(t, i), e);

        function dl(t) {
            return hl(cl(2.55 * t), 0, 255)
        }

        function ul(t) {
            return hl(cl(255 * t), 0, 255)
        }

        function pl(t) {
            return hl(cl(t / 2.55) / 100, 0, 1)
        }

        function fl(t) {
            return hl(cl(100 * t), 0, 100)
        }
        const gl = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        const _l = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

        function ml(i, t, n) {
            const s = t * Math.min(n, 1 - n);
            i = (t, e = (t + i / 30) % 12) => n - s * Math.max(Math.min(e - 3, 9 - e, 1), -1);
            return [i(0), i(8), i(4)]
        }

        function vl(i, n, s) {
            i = (t, e = (t + i / 60) % 6) => s - s * n * Math.max(Math.min(e, 4 - e, 1), 0);
            return [i(5), i(3), i(1)]
        }

        function bl(t, e, i) {
            const n = ml(t, 1, .5);
            let s;
            for (1 < e + i && (s = 1 / (e + i), e *= s, i *= s), s = 0; s < 3; s++) n[s] *= 1 - e - i, n[s] += e;
            return n
        }

        function yl(t) {
            var e = t.r / 255,
                i = t.g / 255,
                n = t.b / 255,
                s = Math.max(e, i, n),
                o = Math.min(e, i, n),
                t = (s + o) / 2;
            let a, r, l;
            return s !== o && (l = s - o, r = .5 < t ? l / (2 - s - o) : l / (s + o), a = s === e ? (i - n) / l + (i < n ? 6 : 0) : s === i ? (n - e) / l + 2 : (e - i) / l + 4, a = 60 * a + .5), [0 | a, r || 0, t]
        }

        function xl(t, e, i, n) {
            return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(ul)
        }

        function wl(t, e, i) {
            return xl(ml, t, e, i)
        }

        function Cl(t) {
            return (t % 360 + 360) % 360
        }

        function kl(t) {
            var e = _l.exec(t);
            let i = 255,
                n;
            if (e) {
                e[5] !== n && (i = (e[6] ? dl : ul)(+e[5]));
                var s = Cl(+e[2]),
                    o = +e[3] / 100,
                    t = +e[4] / 100;
                return n = "hwb" === e[1] ? xl(bl, s, o, t) : "hsv" === e[1] ? xl(vl, s, o, t) : wl(s, o, t), {
                    r: n[0],
                    g: n[1],
                    b: n[2],
                    a: i
                }
            }
        }
        const Tl = {
                x: "dark",
                Z: "light",
                Y: "re",
                X: "blu",
                W: "gr",
                V: "medium",
                U: "slate",
                A: "ee",
                T: "ol",
                S: "or",
                B: "ra",
                C: "lateg",
                D: "ights",
                R: "in",
                Q: "turquois",
                E: "hi",
                P: "ro",
                O: "al",
                N: "le",
                M: "de",
                L: "yello",
                F: "en",
                K: "ch",
                G: "arks",
                H: "ea",
                I: "ightg",
                J: "wh"
            },
            Sl = {
                OiceXe: "f0f8ff",
                antiquewEte: "faebd7",
                aqua: "ffff",
                aquamarRe: "7fffd4",
                azuY: "f0ffff",
                beige: "f5f5dc",
                bisque: "ffe4c4",
                black: "0",
                blanKedOmond: "ffebcd",
                Xe: "ff",
                XeviTet: "8a2be2",
                bPwn: "a52a2a",
                burlywood: "deb887",
                caMtXe: "5f9ea0",
                KartYuse: "7fff00",
                KocTate: "d2691e",
                cSO: "ff7f50",
                cSnflowerXe: "6495ed",
                cSnsilk: "fff8dc",
                crimson: "dc143c",
                cyan: "ffff",
                xXe: "8b",
                xcyan: "8b8b",
                xgTMnPd: "b8860b",
                xWay: "a9a9a9",
                xgYF: "6400",
                xgYy: "a9a9a9",
                xkhaki: "bdb76b",
                xmagFta: "8b008b",
                xTivegYF: "556b2f",
                xSange: "ff8c00",
                xScEd: "9932cc",
                xYd: "8b0000",
                xsOmon: "e9967a",
                xsHgYF: "8fbc8f",
                xUXe: "483d8b",
                xUWay: "2f4f4f",
                xUgYy: "2f4f4f",
                xQe: "ced1",
                xviTet: "9400d3",
                dAppRk: "ff1493",
                dApskyXe: "bfff",
                dimWay: "696969",
                dimgYy: "696969",
                dodgerXe: "1e90ff",
                fiYbrick: "b22222",
                flSOwEte: "fffaf0",
                foYstWAn: "228b22",
                fuKsia: "ff00ff",
                gaRsbSo: "dcdcdc",
                ghostwEte: "f8f8ff",
                gTd: "ffd700",
                gTMnPd: "daa520",
                Way: "808080",
                gYF: "8000",
                gYFLw: "adff2f",
                gYy: "808080",
                honeyMw: "f0fff0",
                hotpRk: "ff69b4",
                RdianYd: "cd5c5c",
                Rdigo: "4b0082",
                ivSy: "fffff0",
                khaki: "f0e68c",
                lavFMr: "e6e6fa",
                lavFMrXsh: "fff0f5",
                lawngYF: "7cfc00",
                NmoncEffon: "fffacd",
                ZXe: "add8e6",
                ZcSO: "f08080",
                Zcyan: "e0ffff",
                ZgTMnPdLw: "fafad2",
                ZWay: "d3d3d3",
                ZgYF: "90ee90",
                ZgYy: "d3d3d3",
                ZpRk: "ffb6c1",
                ZsOmon: "ffa07a",
                ZsHgYF: "20b2aa",
                ZskyXe: "87cefa",
                ZUWay: "778899",
                ZUgYy: "778899",
                ZstAlXe: "b0c4de",
                ZLw: "ffffe0",
                lime: "ff00",
                limegYF: "32cd32",
                lRF: "faf0e6",
                magFta: "ff00ff",
                maPon: "800000",
                VaquamarRe: "66cdaa",
                VXe: "cd",
                VScEd: "ba55d3",
                VpurpN: "9370db",
                VsHgYF: "3cb371",
                VUXe: "7b68ee",
                VsprRggYF: "fa9a",
                VQe: "48d1cc",
                VviTetYd: "c71585",
                midnightXe: "191970",
                mRtcYam: "f5fffa",
                mistyPse: "ffe4e1",
                moccasR: "ffe4b5",
                navajowEte: "ffdead",
                navy: "80",
                Tdlace: "fdf5e6",
                Tive: "808000",
                TivedBb: "6b8e23",
                Sange: "ffa500",
                SangeYd: "ff4500",
                ScEd: "da70d6",
                pOegTMnPd: "eee8aa",
                pOegYF: "98fb98",
                pOeQe: "afeeee",
                pOeviTetYd: "db7093",
                papayawEp: "ffefd5",
                pHKpuff: "ffdab9",
                peru: "cd853f",
                pRk: "ffc0cb",
                plum: "dda0dd",
                powMrXe: "b0e0e6",
                purpN: "800080",
                YbeccapurpN: "663399",
                Yd: "ff0000",
                Psybrown: "bc8f8f",
                PyOXe: "4169e1",
                saddNbPwn: "8b4513",
                sOmon: "fa8072",
                sandybPwn: "f4a460",
                sHgYF: "2e8b57",
                sHshell: "fff5ee",
                siFna: "a0522d",
                silver: "c0c0c0",
                skyXe: "87ceeb",
                UXe: "6a5acd",
                UWay: "708090",
                UgYy: "708090",
                snow: "fffafa",
                sprRggYF: "ff7f",
                stAlXe: "4682b4",
                tan: "d2b48c",
                teO: "8080",
                tEstN: "d8bfd8",
                tomato: "ff6347",
                Qe: "40e0d0",
                viTet: "ee82ee",
                JHt: "f5deb3",
                wEte: "ffffff",
                wEtesmoke: "f5f5f5",
                Lw: "ffff00",
                LwgYF: "9acd32"
            };
        let El;

        function Al(t) {
            El || (El = function() {
                const t = {};
                var e = Object.keys(Sl),
                    i = Object.keys(Tl);
                let n, s, o, a, r;
                for (n = 0; n < e.length; n++) {
                    for (a = r = e[n], s = 0; s < i.length; s++) o = i[s], r = r.replace(o, Tl[o]);
                    o = parseInt(Sl[a], 16), t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
                }
                return t
            }(), El.transparent = [0, 0, 0, 0]);
            t = El[t.toLowerCase()];
            return t && {
                r: t[0],
                g: t[1],
                b: t[2],
                a: 4 === t.length ? t[3] : 255
            }
        }

        function Ml(e, i, n) {
            if (e) {
                let t = yl(e);
                t[i] = Math.max(0, Math.min(t[i] + t[i] * n, 0 === i ? 360 : 1)), t = wl(t), e.r = t[0], e.g = t[1], e.b = t[2]
            }
        }

        function Ol(t, e) {
            return t && Object.assign(e || {}, t)
        }

        function Il(t) {
            var e = {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            };
            return Array.isArray(t) ? 3 <= t.length && (e = {
                r: t[0],
                g: t[1],
                b: t[2],
                a: 255
            }, 3 < t.length && (e.a = ul(t[3]))) : (e = Ol(t, {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            })).a = ul(e.a), e
        }

        function Dl(t) {
            return ("r" === t.charAt(0) ? function(t) {
                var e = gl.exec(t);
                let i = 255,
                    n, s, o;
                if (e) return e[7] !== n && (t = +e[7], i = 255 & (e[8] ? dl(t) : 255 * t)), n = +e[1], s = +e[3], o = +e[5], n = 255 & (e[2] ? dl(n) : n), s = 255 & (e[4] ? dl(s) : s), o = 255 & (e[6] ? dl(o) : o), {
                    r: n,
                    g: s,
                    b: o,
                    a: i
                }
            } : kl)(t)
        }
        class Ll {
            constructor(t) {
                if (t instanceof Ll) return t;
                var e, i, n = typeof t;
                let s;
                "object" == n ? s = Il(t) : "string" == n && (s = (n = (e = t).length, "#" === e[0] && (4 === n || 5 === n ? i = {
                    r: 255 & 17 * nl[e[1]],
                    g: 255 & 17 * nl[e[2]],
                    b: 255 & 17 * nl[e[3]],
                    a: 5 === n ? 17 * nl[e[4]] : 255
                } : 7 !== n && 9 !== n || (i = {
                    r: nl[e[1]] << 4 | nl[e[2]],
                    g: nl[e[3]] << 4 | nl[e[4]],
                    b: nl[e[5]] << 4 | nl[e[6]],
                    a: 9 === n ? nl[e[7]] << 4 | nl[e[8]] : 255
                })), i || Al(t) || Dl(t))), this._rgb = s, this._valid = !!s
            }
            get valid() {
                return this._valid
            }
            get rgb() {
                var t = Ol(this._rgb);
                return t && (t.a = pl(t.a)), t
            }
            set rgb(t) {
                this._rgb = Il(t)
            }
            rgbString() {
                return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${pl(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : this._rgb;
                var t
            }
            hexString() {
                return this._valid ? ll(this._rgb) : this._rgb
            }
            hslString() {
                return this._valid ? function(t) {
                    if (t) {
                        var e = yl(t),
                            i = e[0],
                            n = fl(e[1]),
                            e = fl(e[2]);
                        return t.a < 255 ? `hsla(${i}, ${n}%, ${e}%, ${pl(t.a)})` : `hsl(${i}, ${n}%, ${e}%)`
                    }
                }(this._rgb) : this._rgb
            }
            mix(t, e) {
                if (t) {
                    const s = this.rgb;
                    var i = t.rgb,
                        n = void 0 === e ? .5 : e,
                        t = 2 * n - 1,
                        e = s.a - i.a,
                        t = (1 + (t * e == -1 ? t : (t + e) / (1 + t * e))) / 2,
                        e = 1 - t;
                    s.r = 255 & t * s.r + e * i.r + .5, s.g = 255 & t * s.g + e * i.g + .5, s.b = 255 & t * s.b + e * i.b + .5, s.a = n * s.a + (1 - n) * i.a, this.rgb = s
                }
                return this
            }
            clone() {
                return new Ll(this.rgb)
            }
            alpha(t) {
                return this._rgb.a = ul(t), this
            }
            clearer(t) {
                const e = this._rgb;
                return e.a *= 1 - t, this
            }
            greyscale() {
                const t = this._rgb;
                var e = cl(.3 * t.r + .59 * t.g + .11 * t.b);
                return t.r = t.g = t.b = e, this
            }
            opaquer(t) {
                const e = this._rgb;
                return e.a *= 1 + t, this
            }
            negate() {
                const t = this._rgb;
                return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
            }
            lighten(t) {
                return Ml(this._rgb, 2, t), this
            }
            darken(t) {
                return Ml(this._rgb, 2, -t), this
            }
            saturate(t) {
                return Ml(this._rgb, 1, t), this
            }
            desaturate(t) {
                return Ml(this._rgb, 1, -t), this
            }
            rotate(t) {
                var e, i;
                return e = this._rgb, i = t, (t = yl(e))[0] = Cl(t[0] + i), t = wl(t), e.r = t[0], e.g = t[1], e.b = t[2], this
            }
        }

        function Pl(t) {
            return new Ll(t)
        }
        const Rl = t => t instanceof CanvasGradient || t instanceof CanvasPattern;

        function Bl(t) {
            return Rl(t) ? t : Pl(t)
        }

        function Nl(t) {
            return Rl(t) ? t : Pl(t).saturate(.5).darken(.1).hexString()
        }
        const Hl = Object.create(null),
            jl = Object.create(null);

        function Wl(i, t) {
            if (!t) return i;
            var n = t.split(".");
            for (let t = 0, e = n.length; t < e; ++t) {
                var s = n[t];
                i = i[s] || (i[s] = Object.create(null))
            }
            return i
        }

        function Fl(t, e, i) {
            return "string" == typeof e ? vr(Wl(t, e), i) : vr(Wl(t, ""), e)
        }
        var Vl = new class {
            constructor(t) {
                this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
                    family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    size: 12,
                    style: "normal",
                    lineHeight: 1.2,
                    weight: null
                }, this.hover = {}, this.hoverBackgroundColor = (t, e) => Nl(e.backgroundColor), this.hoverBorderColor = (t, e) => Nl(e.borderColor), this.hoverColor = (t, e) => Nl(e.color), this.indexAxis = "x", this.interaction = {
                    mode: "nearest",
                    intersect: !0
                }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t)
            }
            set(t, e) {
                return Fl(this, t, e)
            }
            get(t) {
                return Wl(this, t)
            }
            describe(t, e) {
                return Fl(jl, t, e)
            }
            override(t, e) {
                return Fl(Hl, t, e)
            }
            route(t, e, i, n) {
                t = Wl(this, t);
                const s = Wl(this, i),
                    o = "_" + e;
                Object.defineProperties(t, {
                    [o]: {
                        value: t[e],
                        writable: !0
                    },
                    [e]: {
                        enumerable: !0,
                        get() {
                            var t = this[o],
                                e = s[n];
                            return rr(t) ? Object.assign({}, e, t) : hr(t, e)
                        },
                        set(t) {
                            this[o] = t
                        }
                    }
                })
            }
        }({
            _scriptable: t => !t.startsWith("on"),
            _indexable: t => "events" !== t,
            hover: {
                _fallback: "interaction"
            },
            interaction: {
                _scriptable: !1,
                _indexable: !1
            }
        });

        function zl(t, e, i, n, s) {
            let o = e[s];
            return o || (o = e[s] = t.measureText(s).width, i.push(s)), n = o > n ? o : n
        }

        function Yl(t, e, i) {
            t = t.currentDevicePixelRatio, i = 0 !== i ? Math.max(i / 2, .5) : 0;
            return Math.round((e - i) * t) / t + i
        }

        function Xl(t, e) {
            (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
        }

        function Ul(t, e, i, n) {
            let s, o, a, r, l;
            const c = e.pointStyle;
            var h = e.rotation,
                d = e.radius;
            let u = (h || 0) * Lr;
            if (c && "object" == typeof c && ("[object HTMLImageElement]" === (s = c.toString()) || "[object HTMLCanvasElement]" === s)) return t.save(), t.translate(i, n), t.rotate(u), t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void t.restore();
            if (!(isNaN(d) || d <= 0)) {
                switch (t.beginPath(), c) {
                    default: t.arc(i, n, d, 0, Or),
                    t.closePath();
                    break;
                    case "triangle":
                            t.moveTo(i + Math.sin(u) * d, n - Math.cos(u) * d),
                        u += Br,
                        t.lineTo(i + Math.sin(u) * d, n - Math.cos(u) * d),
                        u += Br,
                        t.lineTo(i + Math.sin(u) * d, n - Math.cos(u) * d),
                        t.closePath();
                        break;
                    case "rectRounded":
                            l = .516 * d,
                        r = d - l,
                        o = Math.cos(u + Rr) * r,
                        a = Math.sin(u + Rr) * r,
                        t.arc(i - o, n - a, l, u - Mr, u - Pr),
                        t.arc(i + a, n - o, l, u - Pr, u),
                        t.arc(i + o, n + a, l, u, u + Pr),
                        t.arc(i - a, n + o, l, u + Pr, u + Mr),
                        t.closePath();
                        break;
                    case "rect":
                            if (!h) {
                            r = Math.SQRT1_2 * d, t.rect(i - r, n - r, 2 * r, 2 * r);
                            break
                        }u += Rr;
                    case "rectRot":
                            o = Math.cos(u) * d,
                        a = Math.sin(u) * d,
                        t.moveTo(i - o, n - a),
                        t.lineTo(i + a, n - o),
                        t.lineTo(i + o, n + a),
                        t.lineTo(i - a, n + o),
                        t.closePath();
                        break;
                    case "crossRot":
                            u += Rr;
                    case "cross":
                            o = Math.cos(u) * d,
                        a = Math.sin(u) * d,
                        t.moveTo(i - o, n - a),
                        t.lineTo(i + o, n + a),
                        t.moveTo(i + a, n - o),
                        t.lineTo(i - a, n + o);
                        break;
                    case "star":
                            o = Math.cos(u) * d,
                        a = Math.sin(u) * d,
                        t.moveTo(i - o, n - a),
                        t.lineTo(i + o, n + a),
                        t.moveTo(i + a, n - o),
                        t.lineTo(i - a, n + o),
                        u += Rr,
                        o = Math.cos(u) * d,
                        a = Math.sin(u) * d,
                        t.moveTo(i - o, n - a),
                        t.lineTo(i + o, n + a),
                        t.moveTo(i + a, n - o),
                        t.lineTo(i - a, n + o);
                        break;
                    case "line":
                            o = Math.cos(u) * d,
                        a = Math.sin(u) * d,
                        t.moveTo(i - o, n - a),
                        t.lineTo(i + o, n + a);
                        break;
                    case "dash":
                            t.moveTo(i, n),
                        t.lineTo(i + Math.cos(u) * d, n + Math.sin(u) * d)
                }
                t.fill(), 0 < e.borderWidth && t.stroke()
            }
        }

        function Kl(t, e, i) {
            return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
        }

        function $l(t, e) {
            t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
        }

        function Ql(t) {
            t.restore()
        }

        function ql(t, e, i, n, s) {
            if (!e) return t.lineTo(i.x, i.y);
            var o;
            "middle" === s ? (o = (e.x + i.x) / 2, t.lineTo(o, e.y), t.lineTo(o, i.y)) : "after" === s != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y), t.lineTo(i.x, i.y)
        }

        function Zl(t, e, i, n) {
            if (!e) return t.lineTo(i.x, i.y);
            t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y)
        }

        function Gl(t, e, i, n, s, o = {}) {
            var a = ar(e) ? e : [e],
                r = 0 < o.strokeWidth && "" !== o.strokeColor;
            let l, c;
            for (t.save(), t.font = s.string, function(t, e) {
                    e.translation && t.translate(e.translation[0], e.translation[1]);
                    or(e.rotation) || t.rotate(e.rotation);
                    e.color && (t.fillStyle = e.color);
                    e.textAlign && (t.textAlign = e.textAlign);
                    e.textBaseline && (t.textBaseline = e.textBaseline)
                }(t, o), l = 0; l < a.length; ++l) c = a[l], r && (o.strokeColor && (t.strokeStyle = o.strokeColor), or(o.strokeWidth) || (t.lineWidth = o.strokeWidth), t.strokeText(c, i, n, o.maxWidth)), t.fillText(c, i, n, o.maxWidth),
                function(t, e, i, n, s) {
                    {
                        var o, a;
                        (s.strikethrough || s.underline) && (a = t.measureText(n), o = e - a.actualBoundingBoxLeft, n = e + a.actualBoundingBoxRight, e = i - a.actualBoundingBoxAscent, a = i + a.actualBoundingBoxDescent, a = s.strikethrough ? (e + a) / 2 : a, t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = s.decorationWidth || 2, t.moveTo(o, a), t.lineTo(n, a), t.stroke())
                    }
                }(t, i, n, c, o), n += s.lineHeight;
            t.restore()
        }

        function Jl(t, e) {
            var {
                x: i,
                y: n,
                w: s,
                h: o,
                radius: e
            } = e;
            t.arc(i + e.topLeft, n + e.topLeft, e.topLeft, -Pr, Mr, !0), t.lineTo(i, n + o - e.bottomLeft), t.arc(i + e.bottomLeft, n + o - e.bottomLeft, e.bottomLeft, Mr, Pr, !0), t.lineTo(i + s - e.bottomRight, n + o), t.arc(i + s - e.bottomRight, n + o - e.bottomRight, e.bottomRight, Pr, 0, !0), t.lineTo(i + s, n + e.topRight), t.arc(i + s - e.topRight, n + e.topRight, e.topRight, 0, -Pr, !0), t.lineTo(i + e.topLeft, n)
        }
        const tc = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),
            ec = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        const ic = t => +t || 0;

        function nc(e, i) {
            const t = {};
            var n = rr(i),
                s = n ? Object.keys(i) : i;
            const o = rr(e) ? n ? t => hr(e[t], e[i[t]]) : t => e[t] : () => e;
            for (const a of s) t[a] = ic(o(a));
            return t
        }

        function sc(t) {
            return nc(t, {
                top: "y",
                right: "x",
                bottom: "y",
                left: "x"
            })
        }

        function oc(t) {
            return nc(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
        }

        function ac(t) {
            const e = sc(t);
            return e.width = e.left + e.right, e.height = e.top + e.bottom, e
        }

        function rc(t, e) {
            e = e || Vl.font;
            let i = hr((t = t || {}).size, e.size);
            "string" == typeof i && (i = parseInt(i, 10));
            let n = hr(t.style, e.style);
            n && !("" + n).match(ec) && (console.warn('Invalid font style specified: "' + n + '"'), n = "");
            const s = {
                family: hr(t.family, e.family),
                lineHeight: function(t, e) {
                    var i = ("" + t).match(tc);
                    if (!i || "normal" === i[1]) return 1.2 * e;
                    switch (t = +i[2], i[3]) {
                        case "px":
                            return t;
                        case "%":
                            t /= 100
                    }
                    return e * t
                }(hr(t.lineHeight, e.lineHeight), i),
                size: i,
                style: n,
                weight: hr(t.weight, e.weight),
                string: ""
            };
            return s.string = !(e = s) || or(e.size) || or(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family, s
        }

        function lc(t, e, i, n) {
            let s = !0,
                o, a, r;
            for (o = 0, a = t.length; o < a; ++o)
                if (r = t[o], void 0 !== r && (void 0 !== e && "function" == typeof r && (r = r(e), s = !1), void 0 !== i && ar(r) && (r = r[i % r.length], s = !1), void 0 !== r)) return n && !s && (n.cacheable = !1), r
        }

        function cc(t, e) {
            return Object.assign(Object.create(t), e)
        }

        function hc(e, i, t) {
            t = t || (t => e[t] < i);
            let n = e.length - 1,
                s = 0;
            for (var o; 1 < n - s;) t(o = s + n >> 1) ? s = o : n = o;
            return {
                lo: s,
                hi: n
            }
        }
        const dc = (e, i, n) => hc(e, n, t => e[t][i] < n),
            uc = (e, i, n) => hc(e, n, t => e[t][i] >= n);
        const pc = ["push", "pop", "shift", "splice", "unshift"];

        function fc(e, t) {
            var i = e._chartjs;
            if (i) {
                const n = i.listeners;
                t = n.indexOf(t); - 1 !== t && n.splice(t, 1), 0 < n.length || (pc.forEach(t => {
                    delete e[t]
                }), delete e._chartjs)
            }
        }

        function gc(t) {
            const e = new Set;
            let i, n;
            for (i = 0, n = t.length; i < n; ++i) e.add(t[i]);
            return e.size === n ? t : Array.from(e)
        }

        function _c(i, n = [""], e = i, s, o = () => i[0]) {
            Sr(s) || (s = Sc("_fallback", i));
            var t = {
                [Symbol.toStringTag]: "Object",
                _cacheable: !0,
                _scopes: i,
                _rootScopes: e,
                _fallback: s,
                _getTarget: o,
                override: t => _c([t, ...i], n, e, s)
            };
            return new Proxy(t, {
                deleteProperty(t, e) {
                    return delete t[e], delete t._keys, delete i[0][e], !0
                },
                get(t, e) {
                    return xc(t, e, () => function(t, e, i, n) {
                        var s;
                        for (const o of e)
                            if (s = Sc(bc(o, t), i), Sr(s)) return yc(t, s) ? kc(i, n, t, s) : s
                    }(e, n, i, t))
                },
                getOwnPropertyDescriptor(t, e) {
                    return Reflect.getOwnPropertyDescriptor(t._scopes[0], e)
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(i[0])
                },
                has(t, e) {
                    return Ec(t).includes(e)
                },
                ownKeys(t) {
                    return Ec(t)
                },
                set(t, e, i) {
                    const n = t._storage || (t._storage = o());
                    return t[e] = n[e] = i, delete t._keys, !0
                }
            })
        }

        function mc(n, e, i, s) {
            var t = {
                _cacheable: !1,
                _proxy: n,
                _context: e,
                _subProxy: i,
                _stack: new Set,
                _descriptors: vc(n, s),
                setContext: t => mc(n, t, i, s),
                override: t => mc(n.override(t), e, i, s)
            };
            return new Proxy(t, {
                deleteProperty(t, e) {
                    return delete t[e], delete n[e], !0
                },
                get(t, e, i) {
                    return xc(t, e, () => function(t, e, i) {
                        const {
                            _proxy: n,
                            _context: s,
                            _subProxy: o,
                            _descriptors: a
                        } = t;
                        let r = n[e];
                        Er(r) && a.isScriptable(e) && (r = function(t, e, i, n) {
                            const {
                                _proxy: s,
                                _context: o,
                                _subProxy: a,
                                _stack: r
                            } = i;
                            if (r.has(t)) throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + t);
                            r.add(t), e = e(o, a || n), r.delete(t), yc(t, e) && (e = kc(s._scopes, s, t, e));
                            return e
                        }(e, r, t, i));
                        ar(r) && r.length && (r = function(t, e, i, n) {
                            const {
                                _proxy: s,
                                _context: o,
                                _subProxy: a,
                                _descriptors: r
                            } = i;
                            if (Sr(o.index) && n(t)) e = e[o.index % e.length];
                            else if (rr(e[0])) {
                                const h = e;
                                var l = s._scopes.filter(t => t !== h);
                                e = [];
                                for (const d of h) {
                                    var c = kc(l, s, t, d);
                                    e.push(mc(c, o, a && a[t], r))
                                }
                            }
                            return e
                        }(e, r, t, a.isIndexable));
                        yc(e, r) && (r = mc(r, s, o && o[e], a));
                        return r
                    }(t, e, i))
                },
                getOwnPropertyDescriptor(t, e) {
                    return t._descriptors.allKeys ? Reflect.has(n, e) ? {
                        enumerable: !0,
                        configurable: !0
                    } : void 0 : Reflect.getOwnPropertyDescriptor(n, e)
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(n)
                },
                has(t, e) {
                    return Reflect.has(n, e)
                },
                ownKeys() {
                    return Reflect.ownKeys(n)
                },
                set(t, e, i) {
                    return n[e] = i, delete t[e], !0
                }
            })
        }

        function vc(t, e = {
            scriptable: !0,
            indexable: !0
        }) {
            const {
                _scriptable: i = e.scriptable,
                _indexable: n = e.indexable,
                _allKeys: s = e.allKeys
            } = t;
            return {
                allKeys: s,
                scriptable: i,
                indexable: n,
                isScriptable: Er(i) ? i : () => i,
                isIndexable: Er(n) ? n : () => n
            }
        }
        const bc = (t, e) => t ? t + Tr(e) : e,
            yc = (t, e) => rr(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);

        function xc(t, e, i) {
            if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];
            i = i();
            return t[e] = i
        }

        function wc(t, e, i) {
            return Er(t) ? t(e, i) : t
        }

        function Cc(t, e, i, n, s) {
            for (const r of e) {
                a = (o = i, a = r, !0 === o ? a : "string" == typeof o ? kr(a, o) : void 0);
                if (a) {
                    t.add(a);
                    o = wc(a._fallback, i, s);
                    if (Sr(o) && o !== i && o !== n) return o
                } else if (!1 === a && Sr(n) && i !== n) return null
            }
            var o, a;
            return !1
        }

        function kc(t, e, i, n) {
            var s = e._rootScopes,
                o = wc(e._fallback, i, n),
                a = [...t, ...s];
            const r = new Set;
            r.add(n);
            t = Tc(r, a, i, o || i, n);
            return null !== t && ((!Sr(o) || o === i || null !== (t = Tc(r, a, o, t, n))) && _c(Array.from(r), [""], s, o, () => function(t, e, i) {
                const n = t._getTarget();
                e in n || (n[e] = {});
                e = n[e];
                if (ar(e) && rr(i)) return i;
                return e
            }(e, i, n)))
        }

        function Tc(t, e, i, n, s) {
            for (; i;) i = Cc(t, e, i, n, s);
            return i
        }

        function Sc(t, e) {
            for (const n of e)
                if (n) {
                    var i = n[t];
                    if (Sr(i)) return i
                }
        }

        function Ec(t) {
            let e = t._keys;
            return e = e || (t._keys = function(t) {
                const e = new Set;
                for (const i of t)
                    for (const n of Object.keys(i).filter(t => !t.startsWith("_"))) e.add(n);
                return Array.from(e)
            }(t._scopes)), e
        }
        const Ac = Number.EPSILON || 1e-14,
            Mc = (t, e) => e < t.length && !t[e].skip && t[e],
            Oc = t => "x" === t ? "y" : "x";

        function Ic(t, e = "x") {
            var i, n = Oc(e),
                s = t.length;
            const o = Array(s).fill(0),
                a = Array(s);
            let r, l, c, h = Mc(t, 0);
            for (r = 0; r < s; ++r) l = c, c = h, h = Mc(t, r + 1), c && (h && (i = h[e] - c[e], o[r] = 0 != i ? (h[n] - c[n]) / i : 0), a[r] = l ? h ? Hr(o[r - 1]) !== Hr(o[r]) ? 0 : (o[r - 1] + o[r]) / 2 : o[r - 1] : o[r]);
            ! function(e, i, n) {
                var s, o, a, r = e.length;
                let l = Mc(e, 0);
                for (let t = 0; t < r - 1; ++t) a = l, l = Mc(e, t + 1), a && l && (Fr(i[t], 0, Ac) ? n[t] = n[t + 1] = 0 : (s = n[t] / i[t], o = n[t + 1] / i[t], (a = Math.pow(s, 2) + Math.pow(o, 2)) <= 9 || (a = 3 / Math.sqrt(a), n[t] = s * a * i[t], n[t + 1] = o * a * i[t])))
            }(t, o, a),
            function(e, i, n = "x") {
                var s, o, a = Oc(n),
                    r = e.length;
                let l, c, h, d = Mc(e, 0);
                for (let t = 0; t < r; ++t) c = h, h = d, d = Mc(e, t + 1), h && (s = h[n], o = h[a], c && (l = (s - c[n]) / 3, h[`cp1${n}`] = s - l, h[`cp1${a}`] = o - l * i[t]), d && (l = (d[n] - s) / 3, h[`cp2${n}`] = s + l, h[`cp2${a}`] = o + l * i[t]))
            }(t, a, e)
        }

        function Dc(t, e, i) {
            return Math.max(Math.min(t, i), e)
        }

        function Lc(e, i, t, n, s) {
            let o, a, r, l;
            if (i.spanGaps && (e = e.filter(t => !t.skip)), "monotone" === i.cubicInterpolationMode) Ic(e, s);
            else {
                let t = n ? e[e.length - 1] : e[0];
                for (o = 0, a = e.length; o < a; ++o) r = e[o], l = function(t, e, i, n) {
                    var s = t.skip ? e : t,
                        o = e,
                        t = i.skip ? e : i,
                        e = Kr(o, s),
                        i = Kr(t, o);
                    let a = e / (e + i),
                        r = i / (e + i);
                    return a = isNaN(a) ? 0 : a, r = isNaN(r) ? 0 : r, i = n * a, n *= r, {
                        previous: {
                            x: o.x - i * (t.x - s.x),
                            y: o.y - i * (t.y - s.y)
                        },
                        next: {
                            x: o.x + n * (t.x - s.x),
                            y: o.y + n * (t.y - s.y)
                        }
                    }
                }(t, r, e[Math.min(o + 1, a - (n ? 0 : 1)) % a], i.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, t = r
            }
            i.capBezierPoints && function(t, e) {
                let i, n, s, o, a, r = Kl(t[0], e);
                for (i = 0, n = t.length; i < n; ++i) a = o, o = r, r = i < n - 1 && Kl(t[i + 1], e), o && (s = t[i], a && (s.cp1x = Dc(s.cp1x, e.left, e.right), s.cp1y = Dc(s.cp1y, e.top, e.bottom)), r && (s.cp2x = Dc(s.cp2x, e.left, e.right), s.cp2y = Dc(s.cp2y, e.top, e.bottom)))
            }(e, t)
        }

        function Pc() {
            return "undefined" != typeof window && "undefined" != typeof document
        }

        function Rc(t) {
            let e = t.parentNode;
            return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
        }

        function Bc(t, e, i) {
            let n;
            return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n
        }
        const Nc = t => window.getComputedStyle(t, null);
        const Hc = ["top", "right", "bottom", "left"];

        function jc(e, i, n) {
            const s = {};
            n = n ? "-" + n : "";
            for (let t = 0; t < 4; t++) {
                var o = Hc[t];
                s[o] = parseFloat(e[i + "-" + o + n]) || 0
            }
            return s.width = s.left + s.right, s.height = s.top + s.bottom, s
        }
        const Wc = (t, e, i) => (0 < t || 0 < e) && (!i || !i.shadowRoot);

        function Fc(t, e) {
            var {
                canvas: i,
                currentDevicePixelRatio: n
            } = e, s = Nc(i), o = "border-box" === s.boxSizing, a = jc(s, "padding"), r = jc(s, "border", "width"), {
                x: l,
                y: c,
                box: s
            } = function(t, e) {
                var i = t.native || t,
                    n = (s = i.touches) && s.length ? s[0] : i,
                    {
                        offsetX: t,
                        offsetY: s
                    } = n;
                let o = !1,
                    a, r;
                return Wc(t, s, i.target) ? (a = t, r = s) : (e = e.getBoundingClientRect(), a = n.clientX - e.left, r = n.clientY - e.top, o = !0), {
                    x: a,
                    y: r,
                    box: o
                }
            }(t, i), t = a.left + (s && r.left), s = a.top + (s && r.top);
            let {
                width: h,
                height: d
            } = e;
            return o && (h -= a.width + r.width, d -= a.height + r.height), {
                x: Math.round((l - t) / h * i.width / n),
                y: Math.round((c - s) / d * i.height / n)
            }
        }
        const Vc = t => Math.round(10 * t) / 10;

        function zc(t, e, i, n) {
            var s = Nc(t),
                o = jc(s, "margin"),
                a = Bc(s.maxWidth, t, "clientWidth") || Dr,
                r = Bc(s.maxHeight, t, "clientHeight") || Dr,
                e = function(t, e, i) {
                    let n, s;
                    if (void 0 === e || void 0 === i) {
                        const c = Rc(t);
                        var o, a, r, l;
                        c ? (o = c.getBoundingClientRect(), r = jc(a = Nc(c), "border", "width"), l = jc(a, "padding"), e = o.width - l.width - r.width, i = o.height - l.height - r.height, n = Bc(a.maxWidth, c, "clientWidth"), s = Bc(a.maxHeight, c, "clientHeight")) : (e = t.clientWidth, i = t.clientHeight)
                    }
                    return {
                        width: e,
                        height: i,
                        maxWidth: n || Dr,
                        maxHeight: s || Dr
                    }
                }(t, e, i);
            let {
                width: l,
                height: c
            } = e;
            return "content-box" === s.boxSizing && (i = jc(s, "border", "width"), s = jc(s, "padding"), l -= s.width + i.width, c -= s.height + i.height), l = Math.max(0, l - o.width), c = Math.max(0, n ? Math.floor(l / n) : c - o.height), l = Vc(Math.min(l, a, e.maxWidth)), c = Vc(Math.min(c, r, e.maxHeight)), l && !c && (c = Vc(l / 2)), {
                width: l,
                height: c
            }
        }

        function Yc(t, e, i) {
            var n = e || 1,
                s = Math.floor(t.height * n),
                e = Math.floor(t.width * n);
            t.height = s / n, t.width = e / n;
            const o = t.canvas;
            return o.style && (i || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== n || o.height !== s || o.width !== e) && (t.currentDevicePixelRatio = n, o.height = s, o.width = e, t.ctx.setTransform(n, 0, 0, n, 0, 0), 1)
        }
        Jt = function() {
            let t = !1;
            try {
                var e = {
                    get passive() {
                        return !(t = !0)
                    }
                };
                window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
            } catch (t) {}
            return t
        }();

        function Xc(t, e) {
            const i = (t = t, e = e, Nc(t).getPropertyValue(e));
            e = i && i.match(/^(\d+)(\.\d+)?px$/);
            return e ? +e[1] : void 0
        }

        function Uc(t, e, i, n) {
            return {
                x: t.x + i * (e.x - t.x),
                y: t.y + i * (e.y - t.y)
            }
        }

        function Kc(t, e, i, n) {
            return {
                x: t.x + i * (e.x - t.x),
                y: ("middle" === n ? i < .5 ? t : e : "after" === n ? i < 1 ? t : e : 0 < i ? e : t).y
            }
        }

        function $c(t, e, i, n) {
            var s = {
                    x: t.cp2x,
                    y: t.cp2y
                },
                o = {
                    x: e.cp1x,
                    y: e.cp1y
                },
                t = Uc(t, s, i),
                s = Uc(s, o, i),
                e = Uc(o, e, i),
                t = Uc(t, s, i),
                e = Uc(s, e, i);
            return Uc(t, e, i)
        }
        const Qc = new Map;

        function qc(t, e, i) {
            return function(t, e) {
                e = e || {};
                var i = t + JSON.stringify(e);
                let n = Qc.get(i);
                return n || (n = new Intl.NumberFormat(t, e), Qc.set(i, n)), n
            }(e, i).format(t)
        }

        function Zc(t, e, i) {
            return t ? (n = e, s = i, {
                x(t) {
                    return n + n + s - t
                },
                setWidth(t) {
                    s = t
                },
                textAlign(t) {
                    return "center" === t ? t : "right" === t ? "left" : "right"
                },
                xPlus(t, e) {
                    return t - e
                },
                leftForLtr(t, e) {
                    return t - e
                }
            }) : {
                x(t) {
                    return t
                },
                setWidth(t) {},
                textAlign(t) {
                    return t
                },
                xPlus(t, e) {
                    return t + e
                },
                leftForLtr(t, e) {
                    return t
                }
            };
            var n, s
        }

        function Gc(t, e) {
            let i, n;
            "ltr" !== e && "rtl" !== e || (i = t.canvas.style, n = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = n)
        }

        function Jc(t, e) {
            void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
        }

        function th(t) {
            return "angle" === t ? {
                between: qr,
                compare: $r,
                normalize: Qr
            } : {
                between: Gr,
                compare: (t, e) => t - e,
                normalize: t => t
            }
        }

        function eh({
            start: t,
            end: e,
            count: i,
            loop: n,
            style: s
        }) {
            return {
                start: t % i,
                end: e % i,
                loop: n && (e - t + 1) % i == 0,
                style: s
            }
        }

        function ih(t, i, n) {
            if (!n) return [t];
            const {
                property: s,
                start: o,
                end: a
            } = n;
            var r = i.length;
            const {
                compare: l,
                between: c,
                normalize: h
            } = th(s);
            var {
                start: n,
                end: d,
                loop: u,
                style: p
            } = function(t, e, i) {
                var {
                    property: n,
                    start: s,
                    end: o
                } = i;
                const {
                    between: a,
                    normalize: r
                } = th(n);
                var l = e.length;
                let {
                    start: c,
                    end: h,
                    loop: d
                } = t, u, p;
                if (d) {
                    for (c += l, h += l, u = 0, p = l; u < p && a(r(e[c % l][n]), s, o); ++u) c--, h--;
                    c %= l, h %= l
                }
                return h < c && (h += l), {
                    start: c,
                    end: h,
                    loop: d,
                    style: t.style
                }
            }(t, i, n);
            const f = [];
            let g, _ = null,
                m, v, b;
            var y = () => g || c(o, b, m) && 0 !== l(o, b),
                x = () => !g || 0 === l(a, m) || c(a, b, m);
            for (let t = n, e = n; t <= d; ++t)(v = i[t % r]).skip || (m = h(v[s]), m !== b && (g = c(m, o, a), null === _ && y() && (_ = 0 === l(m, o) ? t : e), null !== _ && x() && (f.push(eh({
                start: _,
                end: t,
                loop: u,
                count: r,
                style: p
            })), _ = null), e = t, b = m));
            return null !== _ && f.push(eh({
                start: _,
                end: d,
                loop: u,
                count: r,
                style: p
            })), f
        }

        function nh(e, i) {
            const n = [];
            var s = e.segments;
            for (let t = 0; t < s.length; t++) {
                var o = ih(s[t], e.points, i);
                o.length && n.push(...o)
            }
            return n
        }

        function sh(t, e) {
            var i = t.points,
                n = t.options.spanGaps,
                s = i.length;
            if (!s) return [];
            var o = !!t._loop,
                {
                    start: a,
                    end: r
                } = function(t, e, i, n) {
                    let s = 0,
                        o = e - 1;
                    if (i && !n)
                        for (; s < e && !t[s].skip;) s++;
                    for (; s < e && t[s].skip;) s++;
                    for (s %= e, i && (o += s); o > s && t[o % e].skip;) o--;
                    return o %= e, {
                        start: s,
                        end: o
                    }
                }(i, s, o, n);
            return oh(t, !0 === n ? [{
                start: a,
                end: r,
                loop: o
            }] : function(t, e, i, n) {
                var s = t.length;
                const o = [];
                let a = e,
                    r = t[e],
                    l;
                for (l = e + 1; l <= i; ++l) {
                    var c = t[l % s];
                    c.skip || c.stop ? r.skip || (n = !1, o.push({
                        start: e % s,
                        end: (l - 1) % s,
                        loop: n
                    }), e = a = c.stop ? l : null) : (a = l, r.skip && (e = l)), r = c
                }
                return null !== a && o.push({
                    start: e % s,
                    end: a % s,
                    loop: n
                }), o
            }(i, a, r < a ? r + s : r, !!t._fullLoop && 0 === a && r === s - 1), i, e)
        }

        function oh(t, e, i, n) {
            return n && n.setContext && i ? function(t, e, o, i) {
                const n = t._chart.getContext(),
                    s = ah(t.options),
                    {
                        _datasetIndex: a,
                        options: {
                            spanGaps: r
                        }
                    } = t,
                    l = o.length,
                    c = [];
                let h = s,
                    d = e[0].start,
                    u = d;

                function p(t, e, i, n) {
                    var s = r ? -1 : 1;
                    if (t !== e) {
                        for (t += l; o[t % l].skip;) t -= s;
                        for (; o[e % l].skip;) e += s;
                        t % l != e % l && (c.push({
                            start: t % l,
                            end: e % l,
                            loop: i,
                            style: n
                        }), h = n, d = e % l)
                    }
                }
                for (const _ of e) {
                    d = r ? d : _.start;
                    let t = o[d % l];
                    var f;
                    for (u = d + 1; u <= _.end; u++) {
                        var g = o[u % l];
                        (function(t, e) {
                                return e && JSON.stringify(t) !== JSON.stringify(e)
                            }
                            /*!
                             * Chart.js v3.7.1
                             * https://www.chartjs.org
                             * (c) 2022 Chart.js Contributors
                             * Released under the MIT License
                             */
                        )(f = ah(i.setContext(cc(n, {
                            type: "segment",
                            p0: t,
                            p1: g,
                            p0DataIndex: (u - 1) % l,
                            p1DataIndex: u % l,
                            datasetIndex: a
                        }))), h) && p(d, u - 1, _.loop, h), t = g, h = f
                    }
                    d < u - 1 && p(d, u - 1, _.loop, h)
                }
                return c
            }(t, e, i, n) : e
        }

        function ah(t) {
            return {
                backgroundColor: t.backgroundColor,
                borderCapStyle: t.borderCapStyle,
                borderDash: t.borderDash,
                borderDashOffset: t.borderDashOffset,
                borderJoinStyle: t.borderJoinStyle,
                borderWidth: t.borderWidth,
                borderColor: t.borderColor
            }
        }
        var rh = new class {
            constructor() {
                this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
            }
            _notify(e, i, n, t) {
                const s = i.listeners[t],
                    o = i.duration;
                s.forEach(t => t({
                    chart: e,
                    initial: i.initial,
                    numSteps: o,
                    currentStep: Math.min(n - i.start, o)
                }))
            }
            _refresh() {
                this._request || (this._running = !0, this._request = Ja.call(window, () => {
                    this._update(), this._request = null, this._running && this._refresh()
                }))
            }
            _update(a = Date.now()) {
                let r = 0;
                this._charts.forEach((n, s) => {
                    if (n.running && n.items.length) {
                        const o = n.items;
                        let t = o.length - 1,
                            e = !1,
                            i;
                        for (; 0 <= t; --t) i = o[t], i._active ? (i._total > n.duration && (n.duration = i._total), i.tick(a), e = !0) : (o[t] = o[o.length - 1], o.pop());
                        e && (s.draw(), this._notify(s, n, a, "progress")), o.length || (n.running = !1, this._notify(s, n, a, "complete"), n.initial = !1), r += o.length
                    }
                }), this._lastDate = a, 0 === r && (this._running = !1)
            }
            _getAnims(t) {
                const e = this._charts;
                let i = e.get(t);
                return i || (i = {
                    running: !1,
                    initial: !0,
                    items: [],
                    listeners: {
                        complete: [],
                        progress: []
                    }
                }, e.set(t, i)), i
            }
            listen(t, e, i) {
                this._getAnims(t).listeners[e].push(i)
            }
            add(t, e) {
                e && e.length && this._getAnims(t).items.push(...e)
            }
            has(t) {
                return 0 < this._getAnims(t).items.length
            }
            start(t) {
                const e = this._charts.get(t);
                e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0), this._refresh())
            }
            running(t) {
                if (!this._running) return !1;
                t = this._charts.get(t);
                return !!(t && t.running && t.items.length)
            }
            stop(e) {
                const i = this._charts.get(e);
                if (i && i.items.length) {
                    const n = i.items;
                    let t = n.length - 1;
                    for (; 0 <= t; --t) n[t].cancel();
                    i.items = [], this._notify(e, i, Date.now(), "complete")
                }
            }
            remove(t) {
                return this._charts.delete(t)
            }
        };
        const lh = "transparent",
            ch = {
                boolean(t, e, i) {
                    return .5 < i ? e : t
                },
                color(t, e, i) {
                    t = Bl(t || lh);
                    const n = t.valid && Bl(e || lh);
                    return n && n.valid ? n.mix(t, i).hexString() : e
                },
                number(t, e, i) {
                    return t + (e - t) * i
                }
            };
        class hh {
            constructor(t, e, i, n) {
                var s = e[i];
                n = lc([t.to, n, s, t.from]);
                s = lc([t.from, s, n]);
                this._active = !0, this._fn = t.fn || ch[t.type || typeof s], this._easing = il[t.easing] || il.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = s, this._to = n, this._promises = void 0
            }
            active() {
                return this._active
            }
            update(t, e, i) {
                var n, s, o;
                this._active && (this._notify(!1), n = this._target[this._prop], s = i - this._start, o = this._duration - s, this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += s, this._loop = !!t.loop, this._to = lc([t.to, e, n, t.from]), this._from = lc([t.from, n, e]))
            }
            cancel() {
                this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
            }
            tick(t) {
                var e = t - this._start,
                    i = this._duration,
                    n = this._prop,
                    s = this._from,
                    o = this._loop,
                    t = this._to;
                let a;
                if (this._active = s !== t && (o || e < i), !this._active) return this._target[n] = t, void this._notify(!0);
                e < 0 ? this._target[n] = s : (a = e / i % 2, a = o && 1 < a ? 2 - a : a, a = this._easing(Math.min(1, Math.max(0, a))), this._target[n] = this._fn(s, t, a))
            }
            wait() {
                const i = this._promises || (this._promises = []);
                return new Promise((t, e) => {
                    i.push({
                        res: t,
                        rej: e
                    })
                })
            }
            _notify(t) {
                var e = t ? "res" : "rej";
                const i = this._promises || [];
                for (let t = 0; t < i.length; t++) i[t][e]()
            }
        }
        Vl.set("animation", {
            delay: void 0,
            duration: 1e3,
            easing: "easeOutQuart",
            fn: void 0,
            from: void 0,
            loop: void 0,
            to: void 0,
            type: void 0
        });
        const dh = Object.keys(Vl.animation);
        Vl.describe("animation", {
            _fallback: !1,
            _indexable: !1,
            _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
        }), Vl.set("animations", {
            colors: {
                type: "color",
                properties: ["color", "borderColor", "backgroundColor"]
            },
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius", "tension"]
            }
        }), Vl.describe("animations", {
            _fallback: "animation"
        }), Vl.set("transitions", {
            active: {
                animation: {
                    duration: 400
                }
            },
            resize: {
                animation: {
                    duration: 0
                }
            },
            show: {
                animations: {
                    colors: {
                        from: "transparent"
                    },
                    visible: {
                        type: "boolean",
                        duration: 0
                    }
                }
            },
            hide: {
                animations: {
                    colors: {
                        to: "transparent"
                    },
                    visible: {
                        type: "boolean",
                        easing: "linear",
                        fn: t => 0 | t
                    }
                }
            }
        });
        class uh {
            constructor(t, e) {
                this._chart = t, this._properties = new Map, this.configure(e)
            }
            configure(s) {
                if (rr(s)) {
                    const o = this._properties;
                    Object.getOwnPropertyNames(s).forEach(e => {
                        const t = s[e];
                        if (rr(t)) {
                            const i = {};
                            for (const n of dh) i[n] = t[n];
                            (ar(t.properties) && t.properties || [e]).forEach(t => {
                                t !== e && o.has(t) || o.set(t, i)
                            })
                        }
                    })
                }
            }
            _animateOptions(t, e) {
                const i = e.options;
                e = function(e, i) {
                    if (i) {
                        let t = e.options;
                        if (t) return t.$shared && (e.options = t = Object.assign({}, t, {
                            $shared: !1,
                            $animations: {}
                        })), t;
                        e.options = i
                    }
                }(t, i);
                if (!e) return [];
                e = this._createAnimations(e, i);
                return i.$shared && function(e, t) {
                    const i = [],
                        n = Object.keys(t);
                    for (let t = 0; t < n.length; t++) {
                        const s = e[n[t]];
                        s && s.active() && i.push(s.wait())
                    }
                    return Promise.all(i)
                }(t.options.$animations, i).then(() => {
                    t.options = i
                }, () => {}), e
            }
            _createAnimations(e, i) {
                const n = this._properties,
                    s = [],
                    o = e.$animations || (e.$animations = {});
                var t = Object.keys(i),
                    a = Date.now();
                let r;
                for (r = t.length - 1; 0 <= r; --r) {
                    const h = t[r];
                    if ("$" !== h.charAt(0))
                        if ("options" !== h) {
                            var l = i[h];
                            let t = o[h];
                            var c = n.get(h);
                            if (t) {
                                if (c && t.active()) {
                                    t.update(c, l, a);
                                    continue
                                }
                                t.cancel()
                            }
                            c && c.duration ? (o[h] = t = new hh(c, e, h, l), s.push(t)) : e[h] = l
                        } else s.push(...this._animateOptions(e, i))
                }
                return s
            }
            update(t, e) {
                if (0 !== this._properties.size) {
                    var i = this._createAnimations(t, e);
                    return i.length ? (rh.add(this._chart, i), !0) : void 0
                }
                Object.assign(t, e)
            }
        }

        function ph(t, e) {
            var i = t && t.options || {},
                n = i.reverse,
                t = void 0 === i.min ? e : 0,
                e = void 0 === i.max ? e : 0;
            return {
                start: n ? e : t,
                end: n ? t : e
            }
        }

        function fh(t, e) {
            const i = [];
            var n = t._getSortedDatasetMetas(e);
            let s, o;
            for (s = 0, o = n.length; s < o; ++s) i.push(n[s].index);
            return i
        }

        function gh(t, e, i, n = {}) {
            var s = t.keys,
                o = "single" === n.mode;
            let a, r, l, c;
            if (null !== e) {
                for (a = 0, r = s.length; a < r; ++a) {
                    if ((l = +s[a]) === i) {
                        if (n.all) continue;
                        break
                    }
                    c = t.values[l], lr(c) && (o || 0 === e || Hr(e) === Hr(c)) && (e += c)
                }
                return e
            }
        }

        function _h(t, e) {
            t = t && t.options.stacked;
            return t || void 0 === t && void 0 !== e.stack
        }

        function mh(t, e, i, n) {
            for (const o of e.getMatchingVisibleMetas(n).reverse()) {
                var s = t[o.index];
                if (i && 0 < s || !i && s < 0) return o.index
            }
            return null
        }

        function vh(t, e) {
            const {
                chart: i,
                _cachedMeta: n
            } = t;
            var s = i._stacks || (i._stacks = {}),
                {
                    iScale: o,
                    vScale: a,
                    index: r
                } = n,
                l = o.axis,
                c = a.axis,
                h = (t = n, `${o.id}.${a.id}.${t.stack||t.type}`),
                d = e.length;
            let u;
            for (let t = 0; t < d; ++t) {
                const g = e[t];
                var {
                    [l]: p, [c]: f
                } = g;
                const _ = g._stacks || (g._stacks = {});
                u = _[c] = function(t, e, i) {
                    const n = t[e] || (t[e] = {});
                    return n[i] || (n[i] = {})
                }(s, h, p), u[r] = f, u._top = mh(u, a, !0, n.type), u._bottom = mh(u, a, !1, n.type)
            }
        }

        function bh(t, e) {
            const i = t.scales;
            return Object.keys(i).filter(t => i[t].axis === e).shift()
        }

        function yh(t, e) {
            var i = t.controller.index,
                n = t.vScale && t.vScale.axis;
            if (n)
                for (const s of e = e || t._parsed) {
                    const o = s._stacks;
                    if (!o || void 0 === o[n] || void 0 === o[n][i]) return;
                    delete o[n][i]
                }
        }
        const xh = t => "reset" === t || "none" === t,
            wh = (t, e) => e ? t : Object.assign({}, t);
        class Ch {
            constructor(t, e) {
                this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.$context = void 0, this._syncList = [], this.initialize()
            }
            initialize() {
                const t = this._cachedMeta;
                this.configure(), this.linkScales(), t._stacked = _h(t.vScale, t), this.addElements()
            }
            updateIndex(t) {
                this.index !== t && yh(this._cachedMeta), this.index = t
            }
            linkScales() {
                var t = this.chart;
                const e = this._cachedMeta;
                var i = this.getDataset(),
                    n = (t, e, i, n) => "x" === t ? e : "r" === t ? n : i,
                    s = e.xAxisID = hr(i.xAxisID, bh(t, "x")),
                    o = e.yAxisID = hr(i.yAxisID, bh(t, "y")),
                    a = e.rAxisID = hr(i.rAxisID, bh(t, "r")),
                    i = e.indexAxis,
                    t = e.iAxisID = n(i, s, o, a),
                    i = e.vAxisID = n(i, o, s, a);
                e.xScale = this.getScaleForId(s), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(t), e.vScale = this.getScaleForId(i)
            }
            getDataset() {
                return this.chart.data.datasets[this.index]
            }
            getMeta() {
                return this.chart.getDatasetMeta(this.index)
            }
            getScaleForId(t) {
                return this.chart.scales[t]
            }
            _getOtherScale(t) {
                var e = this._cachedMeta;
                return t === e.iScale ? e.vScale : e.iScale
            }
            reset() {
                this._update("reset")
            }
            _destroy() {
                var t = this._cachedMeta;
                this._data && fc(this._data, this), t._stacked && yh(t)
            }
            _dataCheck() {
                const t = this.getDataset();
                var s, e = t.data || (t.data = []),
                    i = this._data;
                if (rr(e)) this._data = function(t) {
                    var e = Object.keys(t);
                    const i = new Array(e.length);
                    let n, s, o;
                    for (n = 0, s = e.length; n < s; ++n) o = e[n], i[n] = {
                        x: o,
                        y: t[o]
                    };
                    return i
                }(e);
                else if (i !== e) {
                    if (i) {
                        fc(i, this);
                        const n = this._cachedMeta;
                        yh(n), n._parsed = []
                    }
                    e && Object.isExtensible(e) && (i = this, (s = e)._chartjs ? s._chartjs.listeners.push(i) : (Object.defineProperty(s, "_chartjs", {
                        configurable: !0,
                        enumerable: !1,
                        value: {
                            listeners: [i]
                        }
                    }), pc.forEach(t => {
                        const i = "_onData" + Tr(t),
                            n = s[t];
                        Object.defineProperty(s, t, {
                            configurable: !0,
                            enumerable: !1,
                            value(...e) {
                                var t = n.apply(this, e);
                                return s._chartjs.listeners.forEach(t => {
                                    "function" == typeof t[i] && t[i](...e)
                                }), t
                            }
                        })
                    }))), this._syncList = [], this._data = e
                }
            }
            addElements() {
                const t = this._cachedMeta;
                this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
            }
            buildOrUpdateElements(t) {
                const e = this._cachedMeta;
                var i = this.getDataset();
                let n = !1;
                this._dataCheck();
                var s = e._stacked;
                e._stacked = _h(e.vScale, e), e.stack !== i.stack && (n = !0, yh(e), e.stack = i.stack), this._resyncElements(t), !n && s === e._stacked || vh(this, e._parsed)
            }
            configure() {
                const t = this.chart.config;
                var e = t.datasetScopeKeys(this._type),
                    e = t.getOptionScopes(this.getDataset(), e, !0);
                this.options = t.createResolver(e, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
            }
            parse(t, e) {
                const {
                    _cachedMeta: i,
                    _data: n
                } = this;
                var {
                    iScale: s,
                    _stacked: o
                } = i;
                const a = s.axis;
                let r = 0 === t && e === n.length || i._sorted,
                    l = 0 < t && i._parsed[t - 1],
                    c, h, d;
                if (!1 === this._parsing) i._parsed = n, i._sorted = !0, d = n;
                else {
                    d = ar(n[t]) ? this.parseArrayData(i, n, t, e) : rr(n[t]) ? this.parseObjectData(i, n, t, e) : this.parsePrimitiveData(i, n, t, e);
                    for (c = 0; c < e; ++c) i._parsed[c + t] = h = d[c], r && ((null === h[a] || l && h[a] < l[a]) && (r = !1), l = h);
                    i._sorted = r
                }
                o && vh(this, d)
            }
            parsePrimitiveData(t, e, i, n) {
                const {
                    iScale: s,
                    vScale: o
                } = t;
                var a = s.axis,
                    r = o.axis,
                    l = s.getLabels(),
                    c = s === o;
                const h = new Array(n);
                let d, u, p;
                for (d = 0, u = n; d < u; ++d) p = d + i, h[d] = {
                    [a]: c || s.parse(l[p], p),
                    [r]: o.parse(e[p], p)
                };
                return h
            }
            parseArrayData(t, e, i, n) {
                const {
                    xScale: s,
                    yScale: o
                } = t, a = new Array(n);
                let r, l, c, h;
                for (r = 0, l = n; r < l; ++r) h = e[c = r + i], a[r] = {
                    x: s.parse(h[0], c),
                    y: o.parse(h[1], c)
                };
                return a
            }
            parseObjectData(t, e, i, n) {
                const {
                    xScale: s,
                    yScale: o
                } = t;
                var {
                    xAxisKey: a = "x",
                    yAxisKey: r = "y"
                } = this._parsing;
                const l = new Array(n);
                let c, h, d, u;
                for (c = 0, h = n; c < h; ++c) u = e[d = c + i], l[c] = {
                    x: s.parse(kr(u, a), d),
                    y: o.parse(kr(u, r), d)
                };
                return l
            }
            getParsed(t) {
                return this._cachedMeta._parsed[t]
            }
            getDataElement(t) {
                return this._cachedMeta.data[t]
            }
            applyStack(t, e, i) {
                var n = this.chart,
                    s = this._cachedMeta,
                    o = e[t.axis];
                return gh({
                    keys: fh(n, !0),
                    values: e._stacks[t.axis]
                }, o, s.index, {
                    mode: i
                })
            }
            updateRangeFromParsed(t, e, i, n) {
                var s = i[e.axis];
                let o = null === s ? NaN : s;
                e = n && i._stacks[e.axis];
                n && e && (n.values = e, o = gh(n, s, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)
            }
            getMinMax(e, t) {
                var i = this._cachedMeta;
                const n = i._parsed;
                var s = i._sorted && e === i.iScale,
                    o = n.length;
                const a = this._getOtherScale(e);
                var r, l = (r = i, i = this.chart, t && !r.hidden && r._stacked && {
                        keys: fh(i, !0),
                        values: null
                    }),
                    c = {
                        min: Number.POSITIVE_INFINITY,
                        max: Number.NEGATIVE_INFINITY
                    };
                const {
                    min: h,
                    max: d
                } = function(t) {
                    var {
                        min: e,
                        max: i,
                        minDefined: n,
                        maxDefined: t
                    } = t.getUserBounds();
                    return {
                        min: n ? e : Number.NEGATIVE_INFINITY,
                        max: t ? i : Number.POSITIVE_INFINITY
                    }
                }(a);
                let u, p;

                function f() {
                    p = n[u];
                    var t = p[a.axis];
                    return !lr(p[e.axis]) || h > t || d < t
                }
                for (u = 0; u < o && (f() || (this.updateRangeFromParsed(c, e, p, l), !s)); ++u);
                if (s)
                    for (u = o - 1; 0 <= u; --u)
                        if (!f()) {
                            this.updateRangeFromParsed(c, e, p, l);
                            break
                        }
                return c
            }
            getAllParsedValues(t) {
                var e = this._cachedMeta._parsed;
                const i = [];
                let n, s, o;
                for (n = 0, s = e.length; n < s; ++n) o = e[n][t.axis], lr(o) && i.push(o);
                return i
            }
            getMaxOverflow() {
                return !1
            }
            getLabelAndValue(t) {
                var e = this._cachedMeta;
                const i = e.iScale,
                    n = e.vScale;
                t = this.getParsed(t);
                return {
                    label: i ? "" + i.getLabelForValue(t[i.axis]) : "",
                    value: n ? "" + n.getLabelForValue(t[n.axis]) : ""
                }
            }
            _update(t) {
                const e = this._cachedMeta;
                var i, n;
                this.update(t || "default"), e._clip = function(t) {
                    let e, i, n, s;
                    return rr(t) ? (e = t.top, i = t.right, n = t.bottom, s = t.left) : e = i = n = s = t, {
                        top: e,
                        right: i,
                        bottom: n,
                        left: s,
                        disabled: !1 === t
                    }
                }(hr(this.options.clip, (i = e.xScale, n = e.yScale, !1 !== (t = this.getMaxOverflow()) && (i = ph(i, t), {
                    top: (t = ph(n, t)).end,
                    right: i.end,
                    bottom: t.start,
                    left: i.start
                }))))
            }
            update(t) {}
            draw() {
                var t = this._ctx,
                    e = this.chart;
                const i = this._cachedMeta;
                var n = i.data || [],
                    s = e.chartArea;
                const o = [];
                var a = this._drawStart || 0,
                    r = this._drawCount || n.length - a,
                    l = this.options.drawActiveElementsOnTop;
                let c;
                for (i.dataset && i.dataset.draw(t, s, a, r), c = a; c < a + r; ++c) {
                    const h = n[c];
                    h.hidden || (h.active && l ? o.push(h) : h.draw(t, s))
                }
                for (c = 0; c < o.length; ++c) o[c].draw(t, s)
            }
            getStyle(t, e) {
                e = e ? "active" : "default";
                return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(e) : this.resolveDataElementOptions(t || 0, e)
            }
            getContext(t, e, i) {
                var n, s, o = this.getDataset();
                let a;
                if (0 <= t && t < this._cachedMeta.data.length) {
                    const r = this._cachedMeta.data[t];
                    a = r.$context || (r.$context = (n = this.getContext(), s = r, cc(n, {
                        active: !1,
                        dataIndex: t,
                        parsed: void 0,
                        raw: void 0,
                        element: s,
                        index: t,
                        mode: "default",
                        type: "data"
                    }))), a.parsed = this.getParsed(t), a.raw = o.data[t], a.index = a.dataIndex = t
                } else a = this.$context || (this.$context = (s = this.chart.getContext(), t = this.index, cc(s, {
                    active: !1,
                    dataset: void 0,
                    datasetIndex: t,
                    index: t,
                    mode: "default",
                    type: "dataset"
                }))), a.dataset = o, a.index = a.datasetIndex = this.index;
                return a.active = !!e, a.mode = i, a
            }
            resolveDatasetElementOptions(t) {
                return this._resolveElementOptions(this.datasetElementType.id, t)
            }
            resolveDataElementOptions(t, e) {
                return this._resolveElementOptions(this.dataElementType.id, e, t)
            }
            _resolveElementOptions(t, e = "default", i) {
                const n = "active" === e,
                    s = this._cachedDataOpts;
                var o = t + "-" + e,
                    a = s[o],
                    r = this.enableOptionSharing && Sr(i);
                if (a) return wh(a, r);
                const l = this.chart.config;
                e = l.datasetElementScopeKeys(this._type, t), a = n ? [`${t}Hover`, "hover", t, ""] : [t, ""], e = l.getOptionScopes(this.getDataset(), e), t = Object.keys(Vl.elements[t]);
                const c = l.resolveNamedOptions(e, t, () => this.getContext(i, n), a);
                return c.$shared && (c.$shared = r, s[o] = Object.freeze(wh(c, r))), c
            }
            _resolveAnimations(t, e, i) {
                var n = this.chart;
                const s = this._cachedDataOpts;
                var o = `animation-${e}`,
                    a = s[o];
                if (a) return a;
                let r;
                if (!1 !== n.options.animation) {
                    const l = this.chart.config;
                    a = l.datasetAnimationScopeKeys(this._type, e), a = l.getOptionScopes(this.getDataset(), a);
                    r = l.createResolver(a, this.getContext(t, i, e))
                }
                n = new uh(n, r && r.animations);
                return r && r._cacheable && (s[o] = Object.freeze(n)), n
            }
            getSharedOptions(t) {
                if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
            }
            includeOptions(t, e) {
                return !e || xh(t) || this.chart._animationsDisabled
            }
            updateElement(t, e, i, n) {
                xh(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i)
            }
            updateSharedOptions(t, e, i) {
                t && !xh(e) && this._resolveAnimations(void 0, e).update(t, i)
            }
            _setStyle(t, e, i, n) {
                t.active = n;
                var s = this.getStyle(e, n);
                this._resolveAnimations(e, i, n).update(t, {
                    options: !n && this.getSharedOptions(s) || s
                })
            }
            removeHoverStyle(t, e, i) {
                this._setStyle(t, i, "active", !1)
            }
            setHoverStyle(t, e, i) {
                this._setStyle(t, i, "active", !0)
            }
            _removeDatasetHoverStyle() {
                var t = this._cachedMeta.dataset;
                t && this._setStyle(t, void 0, "active", !1)
            }
            _setDatasetHoverStyle() {
                var t = this._cachedMeta.dataset;
                t && this._setStyle(t, void 0, "active", !0)
            }
            _resyncElements(t) {
                var e, i, n, s = this._data,
                    o = this._cachedMeta.data;
                for ([e, i, n] of this._syncList) this[e](i, n);
                this._syncList = [];
                var a = o.length,
                    o = s.length,
                    s = Math.min(o, a);
                s && this.parse(0, s), a < o ? this._insertElements(a, o - a, t) : o < a && this._removeElements(o, a - o)
            }
            _insertElements(t, e, i = !0) {
                var n = this._cachedMeta;
                const s = n.data,
                    o = t + e;
                let a;
                var r = t => {
                    for (t.length += e, a = t.length - 1; a >= o; a--) t[a] = t[a - e]
                };
                for (r(s), a = t; a < o; ++a) s[a] = new this.dataElementType;
                this._parsing && r(n._parsed), this.parse(t, e), i && this.updateElements(s, t, e, "reset")
            }
            updateElements(t, e, i, n) {}
            _removeElements(t, e) {
                const i = this._cachedMeta;
                var n;
                this._parsing && (n = i._parsed.splice(t, e), i._stacked && yh(i, n)), i.data.splice(t, e)
            }
            _sync(t) {
                var e, i, n;
                this._parsing ? this._syncList.push(t) : ([e, i, n] = t, this[e](i, n)), this.chart._dataChanges.push([this.index, ...t])
            }
            _onDataPush() {
                var t = arguments.length;
                this._sync(["_insertElements", this.getDataset().data.length - t, t])
            }
            _onDataPop() {
                this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
            }
            _onDataShift() {
                this._sync(["_removeElements", 0, 1])
            }
            _onDataSplice(t, e) {
                e && this._sync(["_removeElements", t, e]);
                e = arguments.length - 2;
                e && this._sync(["_insertElements", t, e])
            }
            _onDataUnshift() {
                this._sync(["_insertElements", 0, arguments.length])
            }
        }

        function kh(t) {
            const e = t.iScale;
            var i = function(n, t) {
                if (!n._cache.$bar) {
                    const s = n.getMatchingVisibleMetas(t);
                    let i = [];
                    for (let t = 0, e = s.length; t < e; t++) i = i.concat(s[t].controller.getAllParsedValues(n));
                    n._cache.$bar = gc(i.sort((t, e) => t - e))
                }
                return n._cache.$bar
            }(e, t.type);
            let n = e._length,
                s, o, a, r;
            var l = () => {
                32767 !== a && -32768 !== a && (Sr(r) && (n = Math.min(n, Math.abs(a - r) || n)), r = a)
            };
            for (s = 0, o = i.length; s < o; ++s) a = e.getPixelForValue(i[s]), l();
            for (r = void 0, s = 0, o = e.ticks.length; s < o; ++s) a = e.getPixelForTick(s), l();
            return n
        }

        function Th(t, e, i, n) {
            return ar(t) ? function(t, e, i, n) {
                var s = i.parse(t[0], n),
                    o = i.parse(t[1], n),
                    t = Math.min(s, o),
                    n = Math.max(s, o);
                let a = t,
                    r = n;
                Math.abs(t) > Math.abs(n) && (a = n, r = t), e[i.axis] = r, e._custom = {
                    barStart: a,
                    barEnd: r,
                    start: s,
                    end: o,
                    min: t,
                    max: n
                }
            }(t, e, i, n) : e[i.axis] = i.parse(t, n), e
        }

        function Sh(t, e, i, n) {
            const s = t.iScale;
            var o = t.vScale,
                a = s.getLabels(),
                r = s === o;
            const l = [];
            let c, h, d, u;
            for (h = (c = i) + n; c < h; ++c) u = e[c], d = {}, d[s.axis] = r || s.parse(a[c], c), l.push(Th(u, d, o, c));
            return l
        }

        function Eh(t) {
            return t && void 0 !== t.barStart && void 0 !== t.barEnd
        }

        function Ah(t, e, i, n) {
            let s = e.borderSkipped;
            const o = {};
            var a, r, l, c;
            s && ({
                start: a,
                end: r,
                reverse: l,
                top: c,
                bottom: e
            } = function(t) {
                let e, i, n, s, o;
                return n = t.horizontal ? (e = t.base > t.x, i = "left", "right") : (e = t.base < t.y, i = "bottom", "top"), o = e ? (s = "end", "start") : (s = "start", "end"), {
                    start: i,
                    end: n,
                    reverse: e,
                    top: s,
                    bottom: o
                }
            }(t), "middle" === s && i && (t.enableBorderRadius = !0, s = (i._top || 0) === n ? c : (i._bottom || 0) === n ? e : (o[Mh(e, a, r, l)] = !0, c)), o[Mh(s, a, r, l)] = !0), t.borderSkipped = o
        }

        function Mh(t, e, i, n) {
            var s, o;
            return t = n ? (o = i, Oh(t = (s = t) === (n = e) ? o : s === o ? n : s, i, e)) : Oh(t, e, i)
        }

        function Oh(t, e, i) {
            return "start" === t ? e : "end" === t ? i : t
        }
        Ch.defaults = {}, Ch.prototype.datasetElementType = null, Ch.prototype.dataElementType = null;
        class Ih extends Ch {
            parsePrimitiveData(t, e, i, n) {
                return Sh(t, e, i, n)
            }
            parseArrayData(t, e, i, n) {
                return Sh(t, e, i, n)
            }
            parseObjectData(t, e, i, n) {
                const {
                    iScale: s,
                    vScale: o
                } = t;
                var {
                    xAxisKey: a = "x",
                    yAxisKey: t = "y"
                } = this._parsing, r = "x" === s.axis ? a : t, l = "x" === o.axis ? a : t;
                const c = [];
                let h, d, u, p;
                for (d = (h = i) + n; h < d; ++h) p = e[h], u = {}, u[s.axis] = s.parse(kr(p, r), h), c.push(Th(kr(p, l), u, o, h));
                return c
            }
            updateRangeFromParsed(t, e, i, n) {
                super.updateRangeFromParsed(t, e, i, n);
                i = i._custom;
                i && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, i.min), t.max = Math.max(t.max, i.max))
            }
            getMaxOverflow() {
                return 0
            }
            getLabelAndValue(t) {
                const {
                    iScale: e,
                    vScale: i
                } = this._cachedMeta;
                var n = this.getParsed(t),
                    t = n._custom,
                    t = Eh(t) ? "[" + t.start + ", " + t.end + "]" : "" + i.getLabelForValue(n[i.axis]);
                return {
                    label: "" + e.getLabelForValue(n[e.axis]),
                    value: t
                }
            }
            initialize() {
                this.enableOptionSharing = !0, super.initialize();
                const t = this._cachedMeta;
                t.stack = this.getDataset().stack
            }
            update(t) {
                var e = this._cachedMeta;
                this.updateElements(e.data, 0, e.data.length, t)
            }
            updateElements(e, i, n, s) {
                var o = "reset" === s;
                const {
                    index: a,
                    _cachedMeta: {
                        vScale: r
                    }
                } = this;
                var l = r.getBasePixel(),
                    c = r.isHorizontal(),
                    h = this._getRuler(),
                    t = this.resolveDataElementOptions(i, s),
                    d = this.getSharedOptions(t),
                    u = this.includeOptions(s, d);
                this.updateSharedOptions(d, s, t);
                for (let t = i; t < i + n; t++) {
                    var p = this.getParsed(t),
                        f = o || or(p[r.axis]) ? {
                            base: l,
                            head: l
                        } : this._calculateBarValuePixels(t),
                        g = this._calculateBarIndexPixels(t, h),
                        _ = (p._stacks || {})[r.axis];
                    const m = {
                        horizontal: c,
                        base: f.base,
                        enableBorderRadius: !_ || Eh(p._custom) || a === _._top || a === _._bottom,
                        x: c ? f.head : g.center,
                        y: c ? g.center : f.head,
                        height: c ? g.size : Math.abs(f.size),
                        width: c ? Math.abs(f.size) : g.size
                    };
                    u && (m.options = d || this.resolveDataElementOptions(t, e[t].active ? "active" : s));
                    var f = m.options || e[t].options;
                    Ah(m, f, _, a), [g, _, f] = [m, f["inflateAmount"], h.ratio], g.inflateAmount = "auto" === _ ? 1 === f ? .33 : 0 : _, this.updateElement(e[t], t, m, s)
                }
            }
            _getStacks(t, e) {
                const i = this._cachedMeta.iScale;
                var n = i.getMatchingVisibleMetas(this._type),
                    s = i.options.stacked,
                    o = n.length;
                const a = [];
                let r, l;
                for (r = 0; r < o; ++r)
                    if (l = n[r], l.controller.options.grouped) {
                        if (void 0 !== e) {
                            var c = l.controller.getParsed(e)[l.controller._cachedMeta.vScale.axis];
                            if (or(c) || isNaN(c)) continue
                        }
                        if ((!1 === s || -1 === a.indexOf(l.stack) || void 0 === s && void 0 === l.stack) && a.push(l.stack), l.index === t) break
                    }
                return a.length || a.push(void 0), a
            }
            _getStackCount(t) {
                return this._getStacks(void 0, t).length
            }
            _getStackIndex(t, e, i) {
                const n = this._getStacks(t, i);
                e = void 0 !== e ? n.indexOf(e) : -1;
                return -1 === e ? n.length - 1 : e
            }
            _getRuler() {
                var t = this.options,
                    e = this._cachedMeta;
                const i = e.iScale,
                    n = [];
                let s, o;
                for (s = 0, o = e.data.length; s < o; ++s) n.push(i.getPixelForValue(this.getParsed(s)[i.axis], s));
                var a = t.barThickness;
                return {
                    min: a || kh(e),
                    pixels: n,
                    start: i._startPixel,
                    end: i._endPixel,
                    stackCount: this._getStackCount(),
                    scale: i,
                    grouped: t.grouped,
                    ratio: a ? 1 : t.categoryPercentage * t.barPercentage
                }
            }
            _calculateBarValuePixels(t) {
                const {
                    _cachedMeta: {
                        vScale: e,
                        _stacked: i
                    },
                    options: {
                        base: n,
                        minBarLength: s
                    }
                } = this;
                var o = n || 0,
                    a = this.getParsed(t),
                    r = a._custom,
                    l = Eh(r);
                let c = a[e.axis],
                    h = 0,
                    d = i ? this.applyStack(e, a, i) : c,
                    u, p;
                d !== c && (h = d - c, d = c), l && (c = r.barStart, d = r.barEnd - r.barStart, 0 !== c && Hr(c) !== Hr(r.barEnd) && (h = 0), h += c);
                r = or(n) || l ? h : n;
                let f = e.getPixelForValue(r);
                return u = this.chart.getDataVisibility(t) ? e.getPixelForValue(h + d) : f, p = u - f, Math.abs(p) < s && (p = (l = p, r = e, t = o, (0 !== l ? Hr(l) : (r.isHorizontal() ? 1 : -1) * (r.min >= t ? 1 : -1)) * s), c === o && (f -= p / 2), u = f + p), f === e.getPixelForValue(o) && (o = Hr(p) * e.getLineWidthForValue(o) / 2, f += o, p -= o), {
                    size: p,
                    base: f,
                    head: u,
                    center: u + p / 2
                }
            }
            _calculateBarIndexPixels(t, e) {
                const i = e.scale;
                var n, s = this.options,
                    o = s.skipNull,
                    a = hr(s.maxBarThickness, 1 / 0);
                let r, l;
                return l = e.grouped ? (n = o ? this._getStackCount(t) : e.stackCount, n = ("flex" === s.barThickness ? function(t, e, i, n) {
                    var s = e.pixels,
                        o = s[t];
                    let a = 0 < t ? s[t - 1] : null,
                        r = t < s.length - 1 ? s[t + 1] : null;
                    return t = i.categoryPercentage, null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a), o -= (o - Math.min(a, r)) / 2 * t, {
                        chunk: Math.abs(r - a) / 2 * t / n,
                        ratio: i.barPercentage,
                        start: o
                    }
                } : function(t, e, i, n) {
                    var s = i.barThickness;
                    let o, a;
                    return a = or(s) ? (o = e.min * i.categoryPercentage, i.barPercentage) : (o = s * n, 1), {
                        chunk: o / n,
                        ratio: a,
                        start: e.pixels[t] - o / 2
                    }
                })(t, e, s, n), o = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0), r = n.start + n.chunk * o + n.chunk / 2, Math.min(a, n.chunk * n.ratio)) : (r = i.getPixelForValue(this.getParsed(t)[i.axis], t), Math.min(a, e.min * e.ratio)), {
                    base: r - l / 2,
                    head: r + l / 2,
                    center: r,
                    size: l
                }
            }
            draw() {
                var t = this._cachedMeta,
                    e = t.vScale;
                const i = t.data;
                var n = i.length;
                let s = 0;
                for (; s < n; ++s) null !== this.getParsed(s)[e.axis] && i[s].draw(this._ctx)
            }
        }
        Ih.id = "bar", Ih.defaults = {
            datasetElementType: !1,
            dataElementType: "bar",
            categoryPercentage: .8,
            barPercentage: .9,
            grouped: !0,
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "base", "width", "height"]
                }
            }
        }, Ih.overrides = {
            scales: {
                _index_: {
                    type: "category",
                    offset: !0,
                    grid: {
                        offset: !0
                    }
                },
                _value_: {
                    type: "linear",
                    beginAtZero: !0
                }
            }
        };
        class Dh extends Ch {
            initialize() {
                this.enableOptionSharing = !0, super.initialize()
            }
            parsePrimitiveData(t, e, i, n) {
                const s = super.parsePrimitiveData(t, e, i, n);
                for (let t = 0; t < s.length; t++) s[t]._custom = this.resolveDataElementOptions(t + i).radius;
                return s
            }
            parseArrayData(t, e, i, n) {
                const s = super.parseArrayData(t, e, i, n);
                for (let t = 0; t < s.length; t++) {
                    var o = e[i + t];
                    s[t]._custom = hr(o[2], this.resolveDataElementOptions(t + i).radius)
                }
                return s
            }
            parseObjectData(t, e, i, n) {
                const s = super.parseObjectData(t, e, i, n);
                for (let t = 0; t < s.length; t++) {
                    var o = e[i + t];
                    s[t]._custom = hr(o && o.r && +o.r, this.resolveDataElementOptions(t + i).radius)
                }
                return s
            }
            getMaxOverflow() {
                const e = this._cachedMeta.data;
                let i = 0;
                for (let t = e.length - 1; 0 <= t; --t) i = Math.max(i, e[t].size(this.resolveDataElementOptions(t)) / 2);
                return 0 < i && i
            }
            getLabelAndValue(t) {
                var e = this._cachedMeta;
                const {
                    xScale: i,
                    yScale: n
                } = e;
                var s = this.getParsed(t),
                    o = i.getLabelForValue(s.x),
                    t = n.getLabelForValue(s.y),
                    s = s._custom;
                return {
                    label: e.label,
                    value: "(" + o + ", " + t + (s ? ", " + s : "") + ")"
                }
            }
            update(t) {
                var e = this._cachedMeta.data;
                this.updateElements(e, 0, e.length, t)
            }
            updateElements(e, i, n, s) {
                var o = "reset" === s;
                const {
                    iScale: a,
                    vScale: r
                } = this._cachedMeta;
                var t = this.resolveDataElementOptions(i, s),
                    l = this.getSharedOptions(t),
                    c = this.includeOptions(s, l),
                    h = a.axis,
                    d = r.axis;
                for (let t = i; t < i + n; t++) {
                    var u = e[t],
                        p = !o && this.getParsed(t);
                    const g = {};
                    var f = g[h] = o ? a.getPixelForDecimal(.5) : a.getPixelForValue(p[h]),
                        p = g[d] = o ? r.getBasePixel() : r.getPixelForValue(p[d]);
                    g.skip = isNaN(f) || isNaN(p), c && (g.options = this.resolveDataElementOptions(t, u.active ? "active" : s), o && (g.options.radius = 0)), this.updateElement(u, t, g, s)
                }
                this.updateSharedOptions(l, s, t)
            }
            resolveDataElementOptions(t, e) {
                var i = this.getParsed(t);
                let n = super.resolveDataElementOptions(t, e);
                n.$shared && (n = Object.assign({}, n, {
                    $shared: !1
                }));
                t = n.radius;
                return "active" !== e && (n.radius = 0), n.radius += hr(i && i._custom, t), n
            }
        }
        Dh.id = "bubble", Dh.defaults = {
            datasetElementType: !1,
            dataElementType: "point",
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "borderWidth", "radius"]
                }
            }
        }, Dh.overrides = {
            scales: {
                x: {
                    type: "linear"
                },
                y: {
                    type: "linear"
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title() {
                            return ""
                        }
                    }
                }
            }
        };
        class Lh extends Ch {
            constructor(t, e) {
                super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
            }
            linkScales() {}
            parse(n, s) {
                const o = this.getDataset().data,
                    a = this._cachedMeta;
                if (!1 === this._parsing) a._parsed = o;
                else {
                    let t = t => +o[t];
                    if (rr(o[n])) {
                        const {
                            key: r = "value"
                        } = this._parsing;
                        t = t => +kr(o[t], r)
                    }
                    let e, i;
                    for (i = (e = n) + s; e < i; ++e) a._parsed[e] = t(e)
                }
            }
            _getRotation() {
                return zr(this.options.rotation - 90)
            }
            _getCircumference() {
                return zr(this.options.circumference)
            }
            _getRotationExtents() {
                let e = Or,
                    i = -Or;
                for (let t = 0; t < this.chart.data.datasets.length; ++t)
                    if (this.chart.isDatasetVisible(t)) {
                        const o = this.chart.getDatasetMeta(t).controller;
                        var n = o._getRotation(),
                            s = o._getCircumference();
                        e = Math.min(e, n), i = Math.max(i, n + s)
                    }
                return {
                    rotation: e,
                    circumference: i - e
                }
            }
            update(t) {
                var e = this.chart["chartArea"];
                const i = this._cachedMeta;
                var n = i.data,
                    s = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,
                    o = Math.max((Math.min(e.width, e.height) - s) / 2, 0),
                    a = Math.min((c = this.options.cutout, h = o, "string" == typeof c && c.endsWith("%") ? parseFloat(c) / 100 : c / h), 1),
                    r = this._getRingWeight(this.index),
                    {
                        circumference: l,
                        rotation: o
                    } = this._getRotationExtents(),
                    {
                        ratioX: c,
                        ratioY: h,
                        offsetX: o,
                        offsetY: l
                    } = function(t, e, n) {
                        let i = 1,
                            s = 1,
                            o = 0,
                            a = 0;
                        if (e < Or) {
                            const u = t,
                                p = u + e;
                            var r = Math.cos(u),
                                l = Math.sin(u),
                                c = Math.cos(p),
                                h = Math.sin(p),
                                d = (t, e, i) => qr(t, u, p, !0) ? 1 : Math.max(e, e * n, i, i * n),
                                t = (t, e, i) => qr(t, u, p, !0) ? -1 : Math.min(e, e * n, i, i * n),
                                e = d(0, r, c),
                                d = d(Pr, l, h),
                                c = t(Mr, r, c),
                                h = t(Mr + Pr, l, h);
                            i = (e - c) / 2, s = (d - h) / 2, o = -(e + c) / 2, a = -(d + h) / 2
                        }
                        return {
                            ratioX: i,
                            ratioY: s,
                            offsetX: o,
                            offsetY: a
                        }
                    }(o, l, a),
                    c = (e.width - s) / c,
                    h = (e.height - s) / h,
                    h = Math.max(Math.min(c, h) / 2, 0),
                    h = dr(this.options.radius, h),
                    a = (h - Math.max(h * a, 0)) / this._getVisibleDatasetWeightTotal();
                this.offsetX = o * h, this.offsetY = l * h, i.total = this.calculateTotal(), this.outerRadius = h - a * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - a * r, 0), this.updateElements(n, 0, n.length, t)
            }
            _circumference(t, e) {
                var i = this.options,
                    n = this._cachedMeta,
                    s = this._getCircumference();
                return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === n._parsed[t] || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * s / Or)
            }
            updateElements(t, e, i, n) {
                var s = "reset" === n,
                    o = this.chart,
                    a = o.chartArea,
                    o = o.options.animation,
                    r = (a.left + a.right) / 2,
                    l = (a.top + a.bottom) / 2,
                    o = s && o.animateScale,
                    c = o ? 0 : this.innerRadius,
                    h = o ? 0 : this.outerRadius,
                    o = this.resolveDataElementOptions(e, n),
                    d = this.getSharedOptions(o),
                    u = this.includeOptions(n, d);
                let p = this._getRotation(),
                    f;
                for (f = 0; f < e; ++f) p += this._circumference(f, s);
                for (f = e; f < e + i; ++f) {
                    var g = this._circumference(f, s),
                        _ = t[f];
                    const m = {
                        x: r + this.offsetX,
                        y: l + this.offsetY,
                        startAngle: p,
                        endAngle: p + g,
                        circumference: g,
                        outerRadius: h,
                        innerRadius: c
                    };
                    u && (m.options = d || this.resolveDataElementOptions(f, _.active ? "active" : n)), p += g, this.updateElement(_, f, m, n)
                }
                this.updateSharedOptions(d, n, o)
            }
            calculateTotal() {
                var t = this._cachedMeta,
                    e = t.data;
                let i = 0,
                    n;
                for (n = 0; n < e.length; n++) {
                    var s = t._parsed[n];
                    null === s || isNaN(s) || !this.chart.getDataVisibility(n) || e[n].hidden || (i += Math.abs(s))
                }
                return i
            }
            calculateCircumference(t) {
                var e = this._cachedMeta.total;
                return 0 < e && !isNaN(t) ? Or * (Math.abs(t) / e) : 0
            }
            getLabelAndValue(t) {
                var e = this._cachedMeta,
                    i = this.chart,
                    n = i.data.labels || [],
                    i = qc(e._parsed[t], i.options.locale);
                return {
                    label: n[t] || "",
                    value: i
                }
            }
            getMaxBorderWidth(t) {
                let e = 0;
                const i = this.chart;
                let n, s, o, a, r;
                if (!t)
                    for (n = 0, s = i.data.datasets.length; n < s; ++n)
                        if (i.isDatasetVisible(n)) {
                            t = (o = i.getDatasetMeta(n)).data, a = o.controller;
                            break
                        }
                if (!t) return 0;
                for (n = 0, s = t.length; n < s; ++n) "inner" !== (r = a.resolveDataElementOptions(n)).borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
                return e
            }
            getMaxOffset(i) {
                let n = 0;
                for (let t = 0, e = i.length; t < e; ++t) {
                    var s = this.resolveDataElementOptions(t);
                    n = Math.max(n, s.offset || 0, s.hoverOffset || 0)
                }
                return n
            }
            _getRingWeightOffset(e) {
                let i = 0;
                for (let t = 0; t < e; ++t) this.chart.isDatasetVisible(t) && (i += this._getRingWeight(t));
                return i
            }
            _getRingWeight(t) {
                return Math.max(hr(this.chart.data.datasets[t].weight, 1), 0)
            }
            _getVisibleDatasetWeightTotal() {
                return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
            }
        }
        Lh.id = "doughnut", Lh.defaults = {
            datasetElementType: !1,
            dataElementType: "arc",
            animation: {
                animateRotate: !0,
                animateScale: !1
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
                }
            },
            cutout: "50%",
            rotation: 0,
            circumference: 360,
            radius: "100%",
            spacing: 0,
            indexAxis: "r"
        }, Lh.descriptors = {
            _scriptable: t => "spacing" !== t,
            _indexable: t => "spacing" !== t
        }, Lh.overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels(s) {
                            const t = s.data;
                            if (t.labels.length && t.datasets.length) {
                                const {
                                    labels: {
                                        pointStyle: o
                                    }
                                } = s.legend.options;
                                return t.labels.map((t, e) => {
                                    const i = s.getDatasetMeta(0);
                                    var n = i.controller.getStyle(e);
                                    return {
                                        text: t,
                                        fillStyle: n.backgroundColor,
                                        strokeStyle: n.borderColor,
                                        lineWidth: n.borderWidth,
                                        pointStyle: o,
                                        hidden: !s.getDataVisibility(e),
                                        index: e
                                    }
                                })
                            }
                            return []
                        }
                    },
                    onClick(t, e, i) {
                        i.chart.toggleDataVisibility(e.index), i.chart.update()
                    }
                },
                tooltip: {
                    callbacks: {
                        title() {
                            return ""
                        },
                        label(t) {
                            let e = t.label;
                            t = ": " + t.formattedValue;
                            return ar(e) ? (e = e.slice(), e[0] += t) : e += t, e
                        }
                    }
                }
            }
        };
        class Ph extends Ch {
            initialize() {
                this.enableOptionSharing = !0, super.initialize()
            }
            update(t) {
                var e = this._cachedMeta;
                const {
                    dataset: i,
                    data: n = [],
                    _dataset: s
                } = e;
                var o = this.chart._animationsDisabled;
                let {
                    start: a,
                    count: r
                } = function(t, e, i) {
                    var n = e.length;
                    let s = 0,
                        o = n;
                    if (t._sorted) {
                        const {
                            iScale: h,
                            _parsed: d
                        } = t;
                        var a = h.axis,
                            {
                                min: r,
                                max: l,
                                minDefined: c,
                                maxDefined: t
                            } = h.getUserBounds();
                        c && (s = Zr(Math.min(dc(d, h.axis, r).lo, i ? n : dc(e, a, h.getPixelForValue(r)).lo), 0, n - 1)), o = t ? Zr(Math.max(dc(d, h.axis, l).hi + 1, i ? 0 : dc(e, a, h.getPixelForValue(l)).hi + 1), s, n) - s : n - s
                    }
                    return {
                        start: s,
                        count: o
                    }
                }(e, n, o);
                this._drawStart = a, this._drawCount = r,
                    function(t) {
                        var {
                            xScale: e,
                            yScale: i,
                            _scaleRanges: n
                        } = t, s = {
                            xmin: e.min,
                            xmax: e.max,
                            ymin: i.min,
                            ymax: i.max
                        };
                        if (!n) return t._scaleRanges = s, !0;
                        i = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max;
                        return Object.assign(n, s), i
                    }(e) && (a = 0, r = n.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = n;
                const l = this.resolveDatasetElementOptions(t);
                this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
                    animated: !o,
                    options: l
                }, t), this.updateElements(n, a, r, t)
            }
            updateElements(e, i, n, s) {
                var o = "reset" === s;
                const {
                    iScale: a,
                    vScale: r,
                    _stacked: l,
                    _dataset: c
                } = this._cachedMeta;
                var t = this.resolveDataElementOptions(i, s),
                    h = this.getSharedOptions(t),
                    d = this.includeOptions(s, h),
                    u = a.axis,
                    p = r.axis,
                    {
                        spanGaps: f,
                        segment: g
                    } = this.options,
                    _ = Wr(f) ? f : Number.POSITIVE_INFINITY,
                    m = this.chart._animationsDisabled || o || "none" === s;
                let v = 0 < i && this.getParsed(i - 1);
                for (let t = i; t < i + n; ++t) {
                    var b = e[t],
                        y = this.getParsed(t);
                    const k = m ? b : {};
                    var x = or(y[p]),
                        w = k[u] = a.getPixelForValue(y[u], t),
                        C = k[p] = o || x ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, y, l) : y[p], t);
                    k.skip = isNaN(w) || isNaN(C) || x, k.stop = 0 < t && y[u] - v[u] > _, g && (k.parsed = y, k.raw = c.data[t]), d && (k.options = h || this.resolveDataElementOptions(t, b.active ? "active" : s)), m || this.updateElement(b, t, k, s), v = y
                }
                this.updateSharedOptions(h, s, t)
            }
            getMaxOverflow() {
                var t = this._cachedMeta,
                    e = t.dataset,
                    i = e.options && e.options.borderWidth || 0;
                const n = t.data || [];
                if (!n.length) return i;
                e = n[0].size(this.resolveDataElementOptions(0)), t = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
                return Math.max(i, e, t) / 2
            }
            draw() {
                const t = this._cachedMeta;
                t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
            }
        }
        Ph.id = "line", Ph.defaults = {
            datasetElementType: "line",
            dataElementType: "point",
            showLine: !0,
            spanGaps: !1
        }, Ph.overrides = {
            scales: {
                _index_: {
                    type: "category"
                },
                _value_: {
                    type: "linear"
                }
            }
        };
        class Rh extends Ch {
            constructor(t, e) {
                super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
            }
            getLabelAndValue(t) {
                var e = this._cachedMeta,
                    i = this.chart,
                    n = i.data.labels || [],
                    i = qc(e._parsed[t].r, i.options.locale);
                return {
                    label: n[t] || "",
                    value: i
                }
            }
            update(t) {
                var e = this._cachedMeta.data;
                this._updateRadius(), this.updateElements(e, 0, e.length, t)
            }
            _updateRadius() {
                const t = this.chart;
                var e = t.chartArea,
                    i = t.options,
                    e = Math.min(e.right - e.left, e.bottom - e.top),
                    e = Math.max(e / 2, 0),
                    i = (e - Math.max(i.cutoutPercentage ? e / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
                this.outerRadius = e - i * this.index, this.innerRadius = this.outerRadius - i
            }
            updateElements(n, t, e, s) {
                var o = "reset" === s;
                const a = this.chart;
                var r = this.getDataset(),
                    l = a.options.animation;
                const c = this._cachedMeta.rScale;
                var h = c.xCenter,
                    d = c.yCenter,
                    u = c.getIndexAngle(0) - .5 * Mr;
                let p = u,
                    f;
                var g = 360 / this.countVisibleElements();
                for (f = 0; f < t; ++f) p += this._computeAngle(f, s, g);
                for (f = t; f < t + e; f++) {
                    var _ = n[f];
                    let t = p,
                        e = p + this._computeAngle(f, s, g),
                        i = a.getDataVisibility(f) ? c.getDistanceFromCenterForValue(r.data[f]) : 0;
                    p = e, o && (l.animateScale && (i = 0), l.animateRotate && (t = e = u));
                    var m = {
                        x: h,
                        y: d,
                        innerRadius: 0,
                        outerRadius: i,
                        startAngle: t,
                        endAngle: e,
                        options: this.resolveDataElementOptions(f, _.active ? "active" : s)
                    };
                    this.updateElement(_, f, m, s)
                }
            }
            countVisibleElements() {
                const i = this.getDataset(),
                    t = this._cachedMeta;
                let n = 0;
                return t.data.forEach((t, e) => {
                    !isNaN(i.data[e]) && this.chart.getDataVisibility(e) && n++
                }), n
            }
            _computeAngle(t, e, i) {
                return this.chart.getDataVisibility(t) ? zr(this.resolveDataElementOptions(t, e).angle || i) : 0
            }
        }
        Rh.id = "polarArea", Rh.defaults = {
            dataElementType: "arc",
            animation: {
                animateRotate: !0,
                animateScale: !0
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
                }
            },
            indexAxis: "r",
            startAngle: 0
        }, Rh.overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels(s) {
                            const t = s.data;
                            if (t.labels.length && t.datasets.length) {
                                const {
                                    labels: {
                                        pointStyle: o
                                    }
                                } = s.legend.options;
                                return t.labels.map((t, e) => {
                                    const i = s.getDatasetMeta(0);
                                    var n = i.controller.getStyle(e);
                                    return {
                                        text: t,
                                        fillStyle: n.backgroundColor,
                                        strokeStyle: n.borderColor,
                                        lineWidth: n.borderWidth,
                                        pointStyle: o,
                                        hidden: !s.getDataVisibility(e),
                                        index: e
                                    }
                                })
                            }
                            return []
                        }
                    },
                    onClick(t, e, i) {
                        i.chart.toggleDataVisibility(e.index), i.chart.update()
                    }
                },
                tooltip: {
                    callbacks: {
                        title() {
                            return ""
                        },
                        label(t) {
                            return t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
                        }
                    }
                }
            },
            scales: {
                r: {
                    type: "radialLinear",
                    angleLines: {
                        display: !1
                    },
                    beginAtZero: !0,
                    grid: {
                        circular: !0
                    },
                    pointLabels: {
                        display: !1
                    },
                    startAngle: 0
                }
            }
        };
        class Bh extends Lh {}
        Bh.id = "pie", Bh.defaults = {
            cutout: 0,
            rotation: 0,
            circumference: 360,
            radius: "100%"
        };
        class Nh extends Ch {
            getLabelAndValue(t) {
                const e = this._cachedMeta.vScale;
                var i = this.getParsed(t);
                return {
                    label: e.getLabels()[t],
                    value: "" + e.getLabelForValue(i[e.axis])
                }
            }
            update(t) {
                const e = this._cachedMeta,
                    i = e.dataset;
                var n = e.data || [],
                    s = e.iScale.getLabels();
                if (i.points = n, "resize" !== t) {
                    const o = this.resolveDatasetElementOptions(t);
                    this.options.showLine || (o.borderWidth = 0);
                    s = {
                        _loop: !0,
                        _fullLoop: s.length === n.length,
                        options: o
                    };
                    this.updateElement(i, void 0, s, t)
                }
                this.updateElements(n, 0, n.length, t)
            }
            updateElements(e, i, n, s) {
                var o = this.getDataset();
                const a = this._cachedMeta.rScale;
                var r = "reset" === s;
                for (let t = i; t < i + n; t++) {
                    var l = e[t],
                        c = this.resolveDataElementOptions(t, l.active ? "active" : s),
                        h = a.getPointPositionForValue(t, o.data[t]),
                        d = r ? a.xCenter : h.x,
                        u = r ? a.yCenter : h.y,
                        c = {
                            x: d,
                            y: u,
                            angle: h.angle,
                            skip: isNaN(d) || isNaN(u),
                            options: c
                        };
                    this.updateElement(l, t, c, s)
                }
            }
        }
        Nh.id = "radar", Nh.defaults = {
            datasetElementType: "line",
            dataElementType: "point",
            indexAxis: "r",
            showLine: !0,
            elements: {
                line: {
                    fill: "start"
                }
            }
        }, Nh.overrides = {
            aspectRatio: 1,
            scales: {
                r: {
                    type: "radialLinear"
                }
            }
        };
        class Hh extends Ph {}
        Hh.id = "scatter", Hh.defaults = {
            showLine: !1,
            fill: !1
        }, Hh.overrides = {
            interaction: {
                mode: "point"
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title() {
                            return ""
                        },
                        label(t) {
                            return "(" + t.label + ", " + t.formattedValue + ")"
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: "linear"
                },
                y: {
                    type: "linear"
                }
            }
        };

        function jh() {
            throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
        }
        class Wh {
            constructor(t) {
                this.options = t || {}
            }
            formats() {
                return jh()
            }
            parse(t, e) {
                return jh()
            }
            format(t, e) {
                return jh()
            }
            add(t, e, i) {
                return jh()
            }
            diff(t, e, i) {
                return jh()
            }
            startOf(t, e, i) {
                return jh()
            }
            endOf(t, e) {
                return jh()
            }
        }
        Wh.override = function(t) {
            Object.assign(Wh.prototype, t)
        };
        var Fh = {
            _date: Wh
        };

        function Vh(t, e) {
            return "native" in t ? {
                x: t.x,
                y: t.y
            } : Fc(t, e)
        }

        function zh(t, i, e, n, s) {
            var o = t.getSortedVisibleDatasetMetas(),
                a = e[i];
            for (let t = 0, e = o.length; t < e; ++t) {
                var {
                    index: r,
                    data: l
                } = o[t], {
                    lo: c,
                    hi: h
                } = function(t, e, i, n) {
                    var {
                        controller: s,
                        data: o,
                        _sorted: a
                    } = t;
                    if ((t = s._cachedMeta.iScale) && e === t.axis && "r" !== e && a && o.length) {
                        const r = t._reversePixels ? uc : dc;
                        if (!n) return r(o, e, i);
                        if (s._sharedOptions) {
                            const l = o[0];
                            n = "function" == typeof l.getRange && l.getRange(e);
                            if (n) {
                                s = r(o, e, i - n), n = r(o, e, i + n);
                                return {
                                    lo: s.lo,
                                    hi: n.hi
                                }
                            }
                        }
                    }
                    return {
                        lo: 0,
                        hi: o.length - 1
                    }
                }(o[t], i, a, s);
                for (let t = c; t <= h; ++t) {
                    var d = l[t];
                    d.skip || n(d, r, t)
                }
            }
        }

        function Yh(t, n, e, s) {
            const o = [];
            if (!Kl(n, t.chartArea, t._minPadding)) return o;
            return zh(t, e, n, function(t, e, i) {
                t.inRange(n.x, n.y, s) && o.push({
                    element: t,
                    datasetIndex: e,
                    index: i
                })
            }, !0), o
        }

        function Xh(t, a, e, r) {
            let l = [];
            return zh(t, e, a, function(t, e, i) {
                var {
                    startAngle: n,
                    endAngle: s
                } = t.getProps(["startAngle", "endAngle"], r), o = Ur(t, {
                    x: a.x,
                    y: a.y
                })["angle"];
                qr(o, n, s) && l.push({
                    element: t,
                    datasetIndex: e,
                    index: i
                })
            }), l
        }

        function Uh(o, a, t, r, l) {
            let c = [];
            const h = function(t) {
                const n = -1 !== t.indexOf("x"),
                    s = -1 !== t.indexOf("y");
                return function(t, e) {
                    var i = n ? Math.abs(t.x - e.x) : 0,
                        e = s ? Math.abs(t.y - e.y) : 0;
                    return Math.sqrt(Math.pow(i, 2) + Math.pow(e, 2))
                }
            }(t);
            let d = Number.POSITIVE_INFINITY;
            return zh(o, t, a, function(t, e, i) {
                var n, s = t.inRange(a.x, a.y, l);
                r && !s || (Kl(n = t.getCenterPoint(l), o.chartArea, o._minPadding) || s) && ((n = h(a, n)) < d ? (c = [{
                    element: t,
                    datasetIndex: e,
                    index: i
                }], d = n) : n === d && c.push({
                    element: t,
                    datasetIndex: e,
                    index: i
                }))
            }), c
        }

        function Kh(t, e, i, n, s) {
            return Kl(e, t.chartArea, t._minPadding) ? "r" !== i || n ? Uh(t, e, i, n, s) : Xh(t, e, i, s) : []
        }

        function $h(t, e, i, n) {
            const s = Vh(e, t),
                o = [],
                a = i.axis,
                r = "x" === a ? "inXRange" : "inYRange";
            let l = !1;
            return function(t, i) {
                var n, s, o, a = t.getSortedVisibleDatasetMetas();
                for (let t = 0, e = a.length; t < e; ++t) {
                    ({
                        index: n,
                        data: s
                    } = a[t]);
                    for (let t = 0, e = s.length; t < e; ++t)(o = s[t]).skip || i(o, n, t)
                }
            }(t, (t, e, i) => {
                t[r](s[a], n) && o.push({
                    element: t,
                    datasetIndex: e,
                    index: i
                }), t.inRange(s.x, s.y, n) && (l = !0)
            }), i.intersect && !l ? [] : o
        }
        var Qh = {
            modes: {
                index(t, e, i, n) {
                    var s = Vh(e, t),
                        e = i.axis || "x";
                    const o = i.intersect ? Yh(t, s, e, n) : Kh(t, s, e, !1, n),
                        a = [];
                    return o.length ? (t.getSortedVisibleDatasetMetas().forEach(t => {
                        var e = o[0].index,
                            i = t.data[e];
                        i && !i.skip && a.push({
                            element: i,
                            datasetIndex: t.index,
                            index: e
                        })
                    }), a) : []
                },
                dataset(t, e, i, n) {
                    var s = Vh(e, t),
                        e = i.axis || "xy";
                    let o = i.intersect ? Yh(t, s, e, n) : Kh(t, s, e, !1, n);
                    if (0 < o.length) {
                        var a = o[0].datasetIndex,
                            r = t.getDatasetMeta(a).data;
                        o = [];
                        for (let t = 0; t < r.length; ++t) o.push({
                            element: r[t],
                            datasetIndex: a,
                            index: t
                        })
                    }
                    return o
                },
                point(t, e, i, n) {
                    return Yh(t, Vh(e, t), i.axis || "xy", n)
                },
                nearest(t, e, i, n) {
                    return Kh(t, Vh(e, t), i.axis || "xy", i.intersect, n)
                },
                x(t, e, i, n) {
                    return $h(t, e, {
                        axis: "x",
                        intersect: i.intersect
                    }, n)
                },
                y(t, e, i, n) {
                    return $h(t, e, {
                        axis: "y",
                        intersect: i.intersect
                    }, n)
                }
            }
        };
        const qh = ["left", "top", "right", "bottom"];

        function Zh(t, e) {
            return t.filter(t => t.pos === e)
        }

        function Gh(t, e) {
            return t.filter(t => -1 === qh.indexOf(t.pos) && t.box.axis === e)
        }

        function Jh(t, n) {
            return t.sort((t, e) => {
                var i = n ? e : t,
                    e = n ? t : e;
                return i.weight === e.weight ? i.index - e.index : i.weight - e.weight
            })
        }

        function td(t, e) {
            var i = function(t) {
                    const e = {};
                    for (const o of t) {
                        var {
                            stack: i,
                            pos: n,
                            stackWeight: s
                        } = o;
                        if (i && qh.includes(n)) {
                            const a = e[i] || (e[i] = {
                                count: 0,
                                placed: 0,
                                weight: 0,
                                size: 0
                            });
                            a.count++, a.weight += s
                        }
                    }
                    return e
                }(t),
                {
                    vBoxMaxWidth: n,
                    hBoxMaxHeight: s
                } = e;
            let o, a, r;
            for (o = 0, a = t.length; o < a; ++o) {
                r = t[o];
                var l = r.box["fullSize"],
                    c = i[r.stack],
                    c = c && r.stackWeight / c.weight;
                r.horizontal ? (r.width = c ? c * n : l && e.availableWidth, r.height = s) : (r.width = n, r.height = c ? c * s : l && e.availableHeight)
            }
            return i
        }

        function ed(t) {
            const e = function(t) {
                const e = [];
                let i, n, s, o, a, r;
                for (i = 0, n = (t || []).length; i < n; ++i) s = t[i], {
                    position: o,
                    options: {
                        stack: a,
                        stackWeight: r = 1
                    }
                } = s, e.push({
                    index: i,
                    box: s,
                    pos: o,
                    horizontal: s.isHorizontal(),
                    weight: s.weight,
                    stack: a && o + a,
                    stackWeight: r
                });
                return e
            }(t);
            var i = Jh(e.filter(t => t.box.fullSize), !0);
            const n = Jh(Zh(e, "left"), !0),
                s = Jh(Zh(e, "right")),
                o = Jh(Zh(e, "top"), !0);
            var a = Jh(Zh(e, "bottom")),
                r = Gh(e, "x"),
                t = Gh(e, "y");
            return {
                fullSize: i,
                leftAndTop: n.concat(o),
                rightAndBottom: s.concat(t).concat(a).concat(r),
                chartArea: Zh(e, "chartArea"),
                vertical: n.concat(s).concat(t),
                horizontal: o.concat(a).concat(r)
            }
        }

        function id(t, e, i, n) {
            return Math.max(t[i], e[i]) + Math.max(t[n], e[n])
        }

        function nd(t, e) {
            t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
        }

        function sd(t, e, i, n) {
            const s = [];
            let o, a, r, l, c, h;
            for (o = 0, a = t.length, c = 0; o < a; ++o) {
                r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, function(t, i) {
                    const n = i.maxPadding;

                    function e(t) {
                        const e = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0
                        };
                        return t.forEach(t => {
                            e[t] = Math.max(i[t], n[t])
                        }), e
                    }
                    return e(t ? ["left", "right"] : ["top", "bottom"])
                }(r.horizontal, e));
                var {
                    same: d,
                    other: u
                } = function(t, e, i, n) {
                    const {
                        pos: s,
                        box: o
                    } = i;
                    var a = t.maxPadding;
                    if (!rr(s)) {
                        i.size && (t[s] -= i.size);
                        const l = n[i.stack] || {
                            size: 0,
                            count: 1
                        };
                        l.size = Math.max(l.size, i.horizontal ? o.height : o.width), i.size = l.size / l.count, t[s] += i.size
                    }
                    o.getPadding && nd(a, o.getPadding());
                    var r = Math.max(0, e.outerWidth - id(a, t, "left", "right")),
                        n = Math.max(0, e.outerHeight - id(a, t, "top", "bottom")),
                        e = r !== t.w,
                        a = n !== t.h;
                    return t.w = r, t.h = n, i.horizontal ? {
                        same: e,
                        other: a
                    } : {
                        same: a,
                        other: e
                    }
                }(e, i, r, n);
                c |= d && s.length, h = h || u, l.fullSize || s.push(r)
            }
            return c && sd(s, e, i, n) || h
        }

        function od(t, e, i, n, s) {
            t.top = i, t.left = e, t.right = e + n, t.bottom = i + s, t.width = n, t.height = s
        }

        function ad(t, e, i, n) {
            var s = i.padding;
            let {
                x: o,
                y: a
            } = e;
            for (const d of t) {
                var r = d.box;
                const u = n[d.stack] || {
                    count: 1,
                    placed: 0,
                    weight: 1
                };
                var l, c, h = d.stackWeight / u.weight || 1;
                d.horizontal ? (c = e.w * h, l = u.size || r.height, Sr(u.start) && (a = u.start), r.fullSize ? od(r, s.left, a, i.outerWidth - s.right - s.left, l) : od(r, e.left + u.placed, a, c, l), u.start = a, u.placed += c, a = r.bottom) : (c = e.h * h, h = u.size || r.width, Sr(u.start) && (o = u.start), r.fullSize ? od(r, o, s.top, h, i.outerHeight - s.bottom - s.top) : od(r, o, e.top + u.placed, h, c), u.start = o, u.placed += c, o = r.right)
            }
            e.x = o, e.y = a
        }
        Vl.set("layout", {
            autoPadding: !0,
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }
        });
        var rd = function(t, e) {
                t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
                    return [{
                        z: 0,
                        draw(t) {
                            e.draw(t)
                        }
                    }]
                }, t.boxes.push(e)
            },
            ld = function(t, e) {
                e = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== e && t.boxes.splice(e, 1)
            },
            cd = function(t, e, i) {
                e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
            },
            hd = function(i, t, e, n) {
                if (i) {
                    var s = ac(i.options.layout.padding),
                        o = Math.max(t - s.width, 0),
                        a = Math.max(e - s.height, 0),
                        r = ed(i.boxes);
                    const h = r.vertical;
                    var l = r.horizontal;
                    pr(i.boxes, t => {
                        "function" == typeof t.beforeLayout && t.beforeLayout()
                    });
                    var c = h.reduce((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1,
                        e = Object.freeze({
                            outerWidth: t,
                            outerHeight: e,
                            padding: s,
                            availableWidth: o,
                            availableHeight: a,
                            vBoxMaxWidth: o / 2 / c,
                            hBoxMaxHeight: a / 2
                        }),
                        c = Object.assign({}, s);
                    nd(c, ac(n));
                    const d = Object.assign({
                        maxPadding: c,
                        w: o,
                        h: a,
                        x: s.left,
                        y: s.top
                    }, s);
                    s = td(h.concat(l), e);
                    sd(r.fullSize, d, e, s), sd(h, d, e, s), sd(l, d, e, s) && sd(h, d, e, s),
                        function(i) {
                            const n = i.maxPadding;

                            function t(t) {
                                var e = Math.max(n[t] - i[t], 0);
                                return i[t] += e, e
                            }
                            i.y += t("top"), i.x += t("left"), t("right"), t("bottom")
                        }(d), ad(r.leftAndTop, d, e, s), d.x += d.w, d.y += d.h, ad(r.rightAndBottom, d, e, s), i.chartArea = {
                            left: d.left,
                            top: d.top,
                            right: d.left + d.w,
                            bottom: d.top + d.h,
                            height: d.h,
                            width: d.w
                        }, pr(r.chartArea, t => {
                            const e = t.box;
                            Object.assign(e, i.chartArea), e.update(d.w, d.h, {
                                left: 0,
                                top: 0,
                                right: 0,
                                bottom: 0
                            })
                        })
                }
            };
        class dd {
            acquireContext(t, e) {}
            releaseContext(t) {
                return !1
            }
            addEventListener(t, e, i) {}
            removeEventListener(t, e, i) {}
            getDevicePixelRatio() {
                return 1
            }
            getMaximumSize(t, e, i, n) {
                return e = Math.max(0, e || t.width), i = i || t.height, {
                    width: e,
                    height: Math.max(0, n ? Math.floor(e / n) : i)
                }
            }
            isAttached(t) {
                return !0
            }
            updateConfig(t) {}
        }
        class ud extends dd {
            acquireContext(t) {
                return t && t.getContext && t.getContext("2d") || null
            }
            updateConfig(t) {
                t.options.animation = !1
            }
        }
        const pd = "$chartjs",
            fd = {
                touchstart: "mousedown",
                touchmove: "mousemove",
                touchend: "mouseup",
                pointerenter: "mouseenter",
                pointerdown: "mousedown",
                pointermove: "mousemove",
                pointerup: "mouseup",
                pointerleave: "mouseout",
                pointerout: "mouseout"
            },
            gd = t => null === t || "" === t;
        const _d = !!Jt && {
            passive: !0
        };

        function md(t, e, i) {
            t.canvas.removeEventListener(e, i, _d)
        }

        function vd(t, e) {
            for (const i of t)
                if (i === e || i.contains(e)) return !0
        }

        function bd(t, e, n) {
            const s = t.canvas,
                i = new MutationObserver(t => {
                    let e = !1;
                    for (const i of t) e = e || vd(i.addedNodes, s), e = e && !vd(i.removedNodes, s);
                    e && n()
                });
            return i.observe(document, {
                childList: !0,
                subtree: !0
            }), i
        }

        function yd(t, e, n) {
            const s = t.canvas,
                i = new MutationObserver(t => {
                    let e = !1;
                    for (const i of t) e = e || vd(i.removedNodes, s), e = e && !vd(i.addedNodes, s);
                    e && n()
                });
            return i.observe(document, {
                childList: !0,
                subtree: !0
            }), i
        }
        const xd = new Map;
        let wd = 0;

        function Cd() {
            const i = window.devicePixelRatio;
            i !== wd && (wd = i, xd.forEach((t, e) => {
                e.currentDevicePixelRatio !== i && t()
            }))
        }

        function kd(t, e, n) {
            var i = t.canvas;
            const s = i && Rc(i);
            if (s) {
                const o = tr((t, e) => {
                        var i = s.clientWidth;
                        n(t, e), i < s.clientWidth && n()
                    }, window),
                    a = new ResizeObserver(t => {
                        var e = t[0],
                            t = e.contentRect.width,
                            e = e.contentRect.height;
                        0 === t && 0 === e || o(t, e)
                    });
                return a.observe(s), i = t, t = o, xd.size || window.addEventListener("resize", Cd), xd.set(i, t), a
            }
        }

        function Td(t, e, i) {
            i && i.disconnect(), "resize" === e && (t = t, xd.delete(t), xd.size || window.removeEventListener("resize", Cd))
        }

        function Sd(e, t, i) {
            var n = e.canvas,
                s = tr(t => {
                    null !== e.ctx && i(function(t, e) {
                        var i = fd[t.type] || t.type,
                            {
                                x: n,
                                y: s
                            } = Fc(t, e);
                        return {
                            type: i,
                            chart: e,
                            native: t,
                            x: void 0 !== n ? n : null,
                            y: void 0 !== s ? s : null
                        }
                    }(t, e))
                }, e, t => {
                    t = t[0];
                    return [t, t.offsetX, t.offsetY]
                });
            return n.addEventListener(t, s, _d), s
        }
        class Ed extends dd {
            acquireContext(t, e) {
                var i = t && t.getContext && t.getContext("2d");
                return i && i.canvas === t ? (function(t, e) {
                    const i = t.style;
                    var n = t.getAttribute("height"),
                        s = t.getAttribute("width");
                    t[pd] = {
                        initial: {
                            height: n,
                            width: s,
                            style: {
                                display: i.display,
                                height: i.height,
                                width: i.width
                            }
                        }
                    }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", !gd(s) || void 0 !== (s = Xc(t, "width")) && (t.width = s), gd(n) && ("" === t.style.height ? t.height = t.width / (e || 2) : void 0 !== (e = Xc(t, "height")) && (t.height = e))
                }(t, e), i) : null
            }
            releaseContext(t) {
                const i = t.canvas;
                if (!i[pd]) return !1;
                const n = i[pd].initial;
                ["height", "width"].forEach(t => {
                    var e = n[t];
                    or(e) ? i.removeAttribute(t) : i.setAttribute(t, e)
                });
                const e = n.style || {};
                return Object.keys(e).forEach(t => {
                    i.style[t] = e[t]
                }), i.width = i.width, delete i[pd], !0
            }
            addEventListener(t, e, i) {
                this.removeEventListener(t, e);
                const n = t.$proxies || (t.$proxies = {});
                const s = {
                    attach: bd,
                    detach: yd,
                    resize: kd
                }[e] || Sd;
                n[e] = s(t, e, i)
            }
            removeEventListener(t, e) {
                const i = t.$proxies || (t.$proxies = {});
                var n = i[e];
                if (n) {
                    const s = {
                        attach: Td,
                        detach: Td,
                        resize: Td
                    }[e] || md;
                    s(t, e, n), i[e] = void 0
                }
            }
            getDevicePixelRatio() {
                return window.devicePixelRatio
            }
            getMaximumSize(t, e, i, n) {
                return zc(t, e, i, n)
            }
            isAttached(t) {
                t = Rc(t);
                return !(!t || !t.isConnected)
            }
        }
        class Ad {
            constructor() {
                this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0
            }
            tooltipPosition(t) {
                var {
                    x: e,
                    y: t
                } = this.getProps(["x", "y"], t);
                return {
                    x: e,
                    y: t
                }
            }
            hasValue() {
                return Wr(this.x) && Wr(this.y)
            }
            getProps(t, e) {
                const i = this.$animations;
                if (!e || !i) return this;
                const n = {};
                return t.forEach(t => {
                    n[t] = i[t] && i[t].active() ? i[t]._to : this[t]
                }), n
            }
        }
        Ad.defaults = {}, Ad.defaultRoutes = void 0;
        const Md = {
            values(t) {
                return ar(t) ? t : "" + t
            },
            numeric(t, e, i) {
                if (0 === t) return "0";
                var n, s = this.chart.options.locale;
                let o, a = t;
                1 < i.length && (((n = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value))) < 1e-4 || 1e15 < n) && (o = "scientific"), a = function(t, e) {
                    let i = 3 < e.length ? e[2].value - e[1].value : e[1].value - e[0].value;
                    1 <= Math.abs(i) && t !== Math.floor(t) && (i = t - Math.floor(t));
                    return i
                }(t, i));
                i = Nr(Math.abs(a)), i = Math.max(Math.min(-1 * Math.floor(i), 20), 0), i = {
                    notation: o,
                    minimumFractionDigits: i,
                    maximumFractionDigits: i
                };
                return Object.assign(i, this.options.ticks.format), qc(t, s, i)
            },
            logarithmic(t, e, i) {
                if (0 === t) return "0";
                var n = t / Math.pow(10, Math.floor(Nr(t)));
                return 1 == n || 2 == n || 5 == n ? Md.numeric.call(this, t, e, i) : ""
            }
        };
        Dt = {
            formatters: Md
        };

        function Od(t, i) {
            var n = t.options.ticks,
                s = n.maxTicksLimit || (a = (s = t).options.offset, r = s._tickSize(), a = s._length / r + (a ? 0 : 1), r = s._maxLength / r, Math.floor(Math.min(a, r))),
                o = n.major.enabled ? function(t) {
                    const e = [];
                    let i, n;
                    for (i = 0, n = t.length; i < n; i++) t[i].major && e.push(i);
                    return e
                }(i) : [],
                a = o.length,
                r = o[0],
                n = o[a - 1],
                l = [];
            if (s < a) return function(t, e, i, n) {
                let s = 0,
                    o = i[0],
                    a;
                for (n = Math.ceil(n), a = 0; a < t.length; a++) a === o && (e.push(t[a]), s++, o = i[s * n])
            }(i, l, o, a / s), l;
            var c = function(t, e, i) {
                var t = function(t) {
                        var e = t.length;
                        let i, n;
                        if (e < 2) return !1;
                        for (n = t[0], i = 1; i < e; ++i)
                            if (t[i] - t[i - 1] !== n) return !1;
                        return n
                    }(t),
                    n = e.length / i;
                if (!t) return Math.max(n, 1);
                var s = function(t) {
                    const e = [];
                    var i = Math.sqrt(t);
                    let n;
                    for (n = 1; n < i; n++) t % n == 0 && (e.push(n), e.push(t / n));
                    return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e
                }(t);
                for (let t = 0, e = s.length - 1; t < e; t++) {
                    var o = s[t];
                    if (n < o) return o
                }
                return Math.max(n, 1)
            }(o, i, s);
            if (0 < a) {
                let t, e;
                var s = 1 < a ? Math.round((n - r) / (a - 1)) : null;
                for (Id(i, l, c, or(s) ? 0 : r - s, r), t = 0, e = a - 1; t < e; t++) Id(i, l, c, o[t], o[t + 1]);
                return Id(i, l, c, n, or(s) ? i.length : n + s), l
            }
            return Id(i, l, c), l
        }

        function Id(t, e, i, n, s) {
            var o = hr(n, 0),
                a = Math.min(hr(s, t.length), t.length);
            let r = 0,
                l, c, h;
            for (i = Math.ceil(i), s && (i = (l = s - n) / Math.floor(l / i)), h = o; h < 0;) r++, h = Math.round(o + r * i);
            for (c = Math.max(o, 0); c < a; c++) c === h && (e.push(t[c]), r++, h = Math.round(o + r * i))
        }
        Vl.set("scale", {
            display: !0,
            offset: !1,
            reverse: !1,
            beginAtZero: !1,
            bounds: "ticks",
            grace: 0,
            grid: {
                display: !0,
                lineWidth: 1,
                drawBorder: !0,
                drawOnChartArea: !0,
                drawTicks: !0,
                tickLength: 8,
                tickWidth: (t, e) => e.lineWidth,
                tickColor: (t, e) => e.color,
                offset: !1,
                borderDash: [],
                borderDashOffset: 0,
                borderWidth: 1
            },
            title: {
                display: !1,
                text: "",
                padding: {
                    top: 4,
                    bottom: 4
                }
            },
            ticks: {
                minRotation: 0,
                maxRotation: 50,
                mirror: !1,
                textStrokeWidth: 0,
                textStrokeColor: "",
                padding: 3,
                display: !0,
                autoSkip: !0,
                autoSkipPadding: 3,
                labelOffset: 0,
                callback: Dt.formatters.values,
                minor: {},
                major: {},
                align: "center",
                crossAlign: "near",
                showLabelBackdrop: !1,
                backdropColor: "rgba(255, 255, 255, 0.75)",
                backdropPadding: 2
            }
        }), Vl.route("scale.ticks", "color", "", "color"), Vl.route("scale.grid", "color", "", "borderColor"), Vl.route("scale.grid", "borderColor", "", "borderColor"), Vl.route("scale.title", "color", "", "color"), Vl.describe("scale", {
            _fallback: !1,
            _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
            _indexable: t => "borderDash" !== t && "tickBorderDash" !== t
        }), Vl.describe("scales", {
            _fallback: "scale"
        }), Vl.describe("scale.ticks", {
            _scriptable: t => "backdropPadding" !== t && "callback" !== t,
            _indexable: t => "backdropPadding" !== t
        });
        const Dd = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i;

        function Ld(t, e) {
            const i = [];
            var n = t.length / e,
                s = t.length;
            let o = 0;
            for (; o < s; o += n) i.push(t[Math.floor(o)]);
            return i
        }

        function Pd(t) {
            return t.drawTicks ? t.tickLength : 0
        }

        function Rd(t, e) {
            if (!t.display) return 0;
            var i = rc(t.font, e),
                e = ac(t.padding);
            return (ar(t.text) ? t.text.length : 1) * i.lineHeight + e.height
        }
        class Bd extends Ad {
            constructor(t) {
                super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
            }
            init(t) {
                this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)
            }
            parse(t, e) {
                return t
            }
            getUserBounds() {
                var {
                    _userMin: t,
                    _userMax: e,
                    _suggestedMin: i,
                    _suggestedMax: n
                } = this, t = cr(t, Number.POSITIVE_INFINITY), e = cr(e, Number.NEGATIVE_INFINITY), i = cr(i, Number.POSITIVE_INFINITY), n = cr(n, Number.NEGATIVE_INFINITY);
                return {
                    min: cr(t, i),
                    max: cr(e, n),
                    minDefined: lr(t),
                    maxDefined: lr(e)
                }
            }
            getMinMax(i) {
                let {
                    min: n,
                    max: s,
                    minDefined: o,
                    maxDefined: a
                } = this.getUserBounds();
                var r;
                if (o && a) return {
                    min: n,
                    max: s
                };
                const l = this.getMatchingVisibleMetas();
                for (let t = 0, e = l.length; t < e; ++t) r = l[t].controller.getMinMax(this, i), o || (n = Math.min(n, r.min)), a || (s = Math.max(s, r.max));
                return n = a && n > s ? s : n, s = o && n > s ? n : s, {
                    min: cr(n, cr(s, n)),
                    max: cr(s, cr(n, s))
                }
            }
            getPadding() {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                }
            }
            getTicks() {
                return this.ticks
            }
            getLabels() {
                var t = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
            }
            beforeLayout() {
                this._cache = {}, this._dataLimitsCached = !1
            }
            beforeUpdate() {
                ur(this.options.beforeUpdate, [this])
            }
            update(t, e, i) {
                var {
                    beginAtZero: n,
                    grace: s,
                    ticks: o
                } = this.options, a = o.sampleSize;
                this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function(t, e, i) {
                    var {
                        min: n,
                        max: s
                    } = t, t = dr(e, (s - n) / 2);
                    return {
                        min: (e = (t, e) => i && 0 === t ? 0 : t + e)(n, -Math.abs(t)),
                        max: e(s, t)
                    }
                }(this, s, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
                n = a < this.ticks.length;
                this._convertTicksToLabels(n ? Ld(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = Od(this, this.ticks), this._labelSizes = null), n && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
            }
            configure() {
                let t = this.options.reverse,
                    e, i;
                this.isHorizontal() ? (e = this.left, i = this.right) : (e = this.top, i = this.bottom, t = !t), this._startPixel = e, this._endPixel = i, this._reversePixels = t, this._length = i - e, this._alignToPixels = this.options.alignToPixels
            }
            afterUpdate() {
                ur(this.options.afterUpdate, [this])
            }
            beforeSetDimensions() {
                ur(this.options.beforeSetDimensions, [this])
            }
            setDimensions() {
                this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
            }
            afterSetDimensions() {
                ur(this.options.afterSetDimensions, [this])
            }
            _callHooks(t) {
                this.chart.notifyPlugins(t, this.getContext()), ur(this.options[t], [this])
            }
            beforeDataLimits() {
                this._callHooks("beforeDataLimits")
            }
            determineDataLimits() {}
            afterDataLimits() {
                this._callHooks("afterDataLimits")
            }
            beforeBuildTicks() {
                this._callHooks("beforeBuildTicks")
            }
            buildTicks() {
                return []
            }
            afterBuildTicks() {
                this._callHooks("afterBuildTicks")
            }
            beforeTickToLabelConversion() {
                ur(this.options.beforeTickToLabelConversion, [this])
            }
            generateTickLabels(t) {
                var e = this.options.ticks;
                let i, n, s;
                for (i = 0, n = t.length; i < n; i++) s = t[i], s.label = ur(e.callback, [s.value, i, t], this)
            }
            afterTickToLabelConversion() {
                ur(this.options.afterTickToLabelConversion, [this])
            }
            beforeCalculateLabelRotation() {
                ur(this.options.beforeCalculateLabelRotation, [this])
            }
            calculateLabelRotation() {
                var t, e, i, n, s, o = this.options,
                    a = o.ticks,
                    r = this.ticks.length,
                    l = a.minRotation || 0,
                    c = a.maxRotation;
                let h = l;
                !this._isVisible() || !a.display || c <= l || r <= 1 || !this.isHorizontal() ? this.labelRotation = l : (e = (t = this._getLabelSizes()).widest.width, i = t.highest.height, n = Zr(this.chart.width - e, 0, this.maxWidth), (s = o.offset ? this.maxWidth / r : n / (r - 1)) < e + 6 && (s = n / (r - (o.offset ? .5 : 1)), o = this.maxHeight - Pd(o.grid) - a.padding - Rd(o.title, this.chart.options.font), e = Math.sqrt(e * e + i * i), h = Yr(Math.min(Math.asin(Zr((t.highest.height + 6) / s, -1, 1)), Math.asin(Zr(o / e, -1, 1)) - Math.asin(Zr(i / e, -1, 1)))), h = Math.max(l, Math.min(c, h))), this.labelRotation = h)
            }
            afterCalculateLabelRotation() {
                ur(this.options.afterCalculateLabelRotation, [this])
            }
            beforeFit() {
                ur(this.options.beforeFit, [this])
            }
            fit() {
                const t = {
                    width: 0,
                    height: 0
                };
                var e, i, n, s, o, {
                        chart: a,
                        options: {
                            ticks: r,
                            title: l,
                            grid: c
                        }
                    } = this,
                    h = this._isVisible(),
                    d = this.isHorizontal();
                h && (s = Rd(l, a.options.font), d ? (t.width = this.maxWidth, t.height = Pd(c) + s) : (t.height = this.maxHeight, t.width = Pd(c) + s), r.display && this.ticks.length && ({
                    first: e,
                    last: i,
                    widest: n,
                    highest: o
                } = this._getLabelSizes(), h = 2 * r.padding, l = zr(this.labelRotation), c = Math.cos(l), s = Math.sin(l), d ? (l = r.mirror ? 0 : s * n.width + c * o.height, t.height = Math.min(this.maxHeight, t.height + l + h)) : (o = r.mirror ? 0 : c * n.width + s * o.height, t.width = Math.min(this.maxWidth, t.width + o + h)), this._calculatePadding(e, i, s, c))), this._handleMargins(), d ? (this.width = this._length = a.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = a.height - this._margins.top - this._margins.bottom)
            }
            _calculatePadding(i, n, s, o) {
                var {
                    ticks: {
                        align: a,
                        padding: r
                    },
                    position: l
                } = this.options, c = 0 !== this.labelRotation, h = "top" !== l && "x" === this.axis;
                if (this.isHorizontal()) {
                    var d = this.getPixelForTick(0) - this.left,
                        l = this.right - this.getPixelForTick(this.ticks.length - 1);
                    let t = 0,
                        e = 0;
                    c ? e = h ? (t = o * i.width, s * n.height) : (t = s * i.height, o * n.width) : "start" === a ? e = n.width : "end" === a ? t = i.width : (t = i.width / 2, e = n.width / 2), this.paddingLeft = Math.max((t - d + r) * this.width / (this.width - d), 0), this.paddingRight = Math.max((e - l + r) * this.width / (this.width - l), 0)
                } else {
                    let t = n.height / 2,
                        e = i.height / 2;
                    "start" === a ? (t = 0, e = i.height) : "end" === a && (t = n.height, e = 0), this.paddingTop = t + r, this.paddingBottom = e + r
                }
            }
            _handleMargins() {
                this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
            }
            afterFit() {
                ur(this.options.afterFit, [this])
            }
            isHorizontal() {
                var {
                    axis: t,
                    position: e
                } = this.options;
                return "top" === e || "bottom" === e || "x" === t
            }
            isFullSize() {
                return this.options.fullSize
            }
            _convertTicksToLabels(t) {
                this.beforeTickToLabelConversion(), this.generateTickLabels(t);
                let e, i;
                for (e = 0, i = t.length; e < i; e++) or(t[e].label) && (t.splice(e, 1), i--, e--);
                this.afterTickToLabelConversion()
            }
            _getLabelSizes() {
                let e = this._labelSizes;
                if (!e) {
                    var i = this.options.ticks.sampleSize;
                    let t = this.ticks;
                    i < t.length && (t = Ld(t, i)), this._labelSizes = e = this._computeLabelSizes(t, t.length)
                }
                return e
            }
            _computeLabelSizes(t, e) {
                const {
                    ctx: i,
                    _longestTextCache: n
                } = this, s = [], o = [];
                let a = 0,
                    r = 0,
                    l, c, h, d, u, p, f, g, _, m, v;
                for (l = 0; l < e; ++l) {
                    if (d = t[l].label, u = this._resolveTickFontOptions(l), i.font = p = u.string, f = n[p] = n[p] || {
                            data: {},
                            gc: []
                        }, g = u.lineHeight, _ = m = 0, or(d) || ar(d)) {
                        if (ar(d))
                            for (c = 0, h = d.length; c < h; ++c) or(v = d[c]) || ar(v) || (_ = zl(i, f.data, f.gc, _, v), m += g)
                    } else _ = zl(i, f.data, f.gc, _, d), m = g;
                    s.push(_), o.push(m), a = Math.max(_, a), r = Math.max(m, r)
                }
                var b;
                w = n, b = e, pr(w, t => {
                    const e = t.gc;
                    var i = e.length / 2;
                    let n;
                    if (b < i) {
                        for (n = 0; n < i; ++n) delete t.data[e[n]];
                        e.splice(0, i)
                    }
                });
                var y = s.indexOf(a),
                    x = o.indexOf(r),
                    w = t => ({
                        width: s[t] || 0,
                        height: o[t] || 0
                    });
                return {
                    first: w(0),
                    last: w(e - 1),
                    widest: w(y),
                    highest: w(x),
                    widths: s,
                    heights: o
                }
            }
            getLabelForValue(t) {
                return t
            }
            getPixelForValue(t, e) {
                return NaN
            }
            getValueForPixel(t) {}
            getPixelForTick(t) {
                var e = this.ticks;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
            }
            getPixelForDecimal(t) {
                this._reversePixels && (t = 1 - t);
                t = this._startPixel + t * this._length;
                return Zr(this._alignToPixels ? Yl(this.chart, t, 0) : t, -32768, 32767)
            }
            getDecimalForPixel(t) {
                t = (t - this._startPixel) / this._length;
                return this._reversePixels ? 1 - t : t
            }
            getBasePixel() {
                return this.getPixelForValue(this.getBaseValue())
            }
            getBaseValue() {
                var {
                    min: t,
                    max: e
                } = this;
                return t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0
            }
            getContext(t) {
                var e, i = this.ticks || [];
                if (0 <= t && t < i.length) {
                    const n = i[t];
                    return n.$context || (n.$context = (e = this.getContext(), i = n, cc(e, {
                        tick: i,
                        index: t,
                        type: "tick"
                    })))
                }
                return this.$context || (this.$context = cc(this.chart.getContext(), {
                    scale: this,
                    type: "scale"
                }))
            }
            _tickSize() {
                var t = this.options.ticks,
                    e = zr(this.labelRotation),
                    i = Math.abs(Math.cos(e)),
                    n = Math.abs(Math.sin(e)),
                    s = this._getLabelSizes(),
                    e = t.autoSkipPadding || 0,
                    t = s ? s.widest.width + e : 0,
                    e = s ? s.highest.height + e : 0;
                return this.isHorizontal() ? t * n < e * i ? t / i : e / n : e * n < t * i ? e / i : t / n
            }
            _isVisible() {
                var t = this.options.display;
                return "auto" !== t ? !!t : 0 < this.getMatchingVisibleMetas().length
            }
            _computeGridLineItems(t) {
                var e = this.axis;
                const i = this.chart;
                var n = this.options;
                const {
                    grid: s,
                    position: o
                } = n;
                var a = s.offset,
                    r = this.isHorizontal(),
                    l = this.ticks.length + (a ? 1 : 0),
                    c = Pd(s);
                const h = [];
                var d = s.setContext(this.getContext());
                const u = d.drawBorder ? d.borderWidth : 0;

                function p(t) {
                    return Yl(i, t, u)
                }
                var f, g = u / 2;
                let _, m, v, b, y, x, w, C, k, T, S, E;
                "top" === o ? (_ = p(this.bottom), x = this.bottom - c, C = _ - g, T = p(t.top) + g, E = t.bottom) : "bottom" === o ? (_ = p(this.top), T = t.top, E = p(t.bottom) - g, x = _ + g, C = this.top + c) : "left" === o ? (_ = p(this.right), y = this.right - c, w = _ - g, k = p(t.left) + g, S = t.right) : "right" === o ? (_ = p(this.left), k = t.left, S = p(t.right) - g, y = _ + g, w = this.left + c) : "x" === e ? ("center" === o ? _ = p((t.top + t.bottom) / 2 + .5) : rr(o) && (f = o[d = Object.keys(o)[0]], _ = p(this.chart.scales[d].getPixelForValue(f))), T = t.top, E = t.bottom, x = _ + g, C = x + c) : "y" === e && ("center" === o ? _ = p((t.left + t.right) / 2) : rr(o) && (e = o[f = Object.keys(o)[0]], _ = p(this.chart.scales[f].getPixelForValue(e))), y = _ - g, w = y - c, k = t.left, S = t.right);
                var n = hr(n.ticks.maxTicksLimit, l),
                    A = Math.max(1, Math.ceil(l / n));
                for (m = 0; m < l; m += A) {
                    var M = s.setContext(this.getContext(m)),
                        O = M.lineWidth,
                        I = M.color,
                        D = s.borderDash || [],
                        L = M.borderDashOffset,
                        P = M.tickWidth,
                        R = M.tickColor,
                        B = M.tickBorderDash || [],
                        M = M.tickBorderDashOffset;
                    void 0 !== (v = function(t, e, i) {
                        var n = t.ticks.length,
                            s = Math.min(e, n - 1),
                            o = t._startPixel,
                            a = t._endPixel;
                        let r = t.getPixelForTick(s),
                            l;
                        if (!(i && (l = 1 === n ? Math.max(r - o, a - r) : 0 === e ? (t.getPixelForTick(1) - r) / 2 : (r - t.getPixelForTick(s - 1)) / 2, r += s < e ? l : -l, r < o - 1e-6 || r > a + 1e-6))) return r
                    }(this, m, a)) && (b = Yl(i, v, O), r ? y = w = k = S = b : x = C = T = E = b, h.push({
                        tx1: y,
                        ty1: x,
                        tx2: w,
                        ty2: C,
                        x1: k,
                        y1: T,
                        x2: S,
                        y2: E,
                        width: O,
                        color: I,
                        borderDash: D,
                        borderDashOffset: L,
                        tickWidth: P,
                        tickColor: R,
                        tickBorderDash: B,
                        tickBorderDashOffset: M
                    }))
                }
                return this._ticksLength = l, this._borderValue = _, h
            }
            _computeLabelItems(t) {
                var e = this.axis,
                    i = this.options;
                const {
                    position: n,
                    ticks: s
                } = i;
                var o, a, r = this.isHorizontal(),
                    l = this.ticks,
                    {
                        align: c,
                        crossAlign: h,
                        padding: d,
                        mirror: u
                    } = s,
                    p = Pd(i.grid),
                    i = p + d,
                    d = u ? -d : i,
                    f = -zr(this.labelRotation);
                const g = [];
                let _, m, v, b, y, x, w, C, k, T, S, E = "middle";
                "top" === n ? (y = this.bottom - d, x = this._getXAxisLabelAlignment()) : "bottom" === n ? (y = this.top + d, x = this._getXAxisLabelAlignment()) : "left" === n ? (o = this._getYAxisLabelAlignment(p), x = o.textAlign, b = o.x) : "right" === n ? (a = this._getYAxisLabelAlignment(p), x = a.textAlign, b = a.x) : "x" === e ? ("center" === n ? y = (t.top + t.bottom) / 2 + i : rr(n) && (a = n[o = Object.keys(n)[0]], y = this.chart.scales[o].getPixelForValue(a) + i), x = this._getXAxisLabelAlignment()) : "y" === e && ("center" === n ? b = (t.left + t.right) / 2 - i : rr(n) && (i = n[t = Object.keys(n)[0]], b = this.chart.scales[t].getPixelForValue(i)), x = this._getYAxisLabelAlignment(p).textAlign), "y" === e && ("start" === c ? E = "top" : "end" === c && (E = "bottom"));
                var A = this._getLabelSizes();
                for (_ = 0, m = l.length; _ < m; ++_) {
                    v = l[_].label;
                    var M = s.setContext(this.getContext(_));
                    w = this.getPixelForTick(_) + s.labelOffset, k = (C = this._resolveTickFontOptions(_)).lineHeight;
                    var O = (T = ar(v) ? v.length : 1) / 2,
                        I = M.color,
                        D = M.textStrokeColor,
                        L = M.textStrokeWidth;
                    r ? (b = w, S = "top" === n ? "near" === h || 0 != f ? -T * k + k / 2 : "center" === h ? -A.highest.height / 2 - O * k + k : -A.highest.height + k / 2 : "near" === h || 0 != f ? k / 2 : "center" === h ? A.highest.height / 2 - O * k : A.highest.height - T * k, u && (S *= -1)) : (y = w, S = (1 - T) * k / 2);
                    let i;
                    if (M.showLabelBackdrop) {
                        var O = ac(M.backdropPadding),
                            P = A.heights[_],
                            R = A.widths[_];
                        let t = y + S - O.top,
                            e = b - O.left;
                        switch (E) {
                            case "middle":
                                t -= P / 2;
                                break;
                            case "bottom":
                                t -= P
                        }
                        switch (x) {
                            case "center":
                                e -= R / 2;
                                break;
                            case "right":
                                e -= R
                        }
                        i = {
                            left: e,
                            top: t,
                            width: R + O.width,
                            height: P + O.height,
                            color: M.backdropColor
                        }
                    }
                    g.push({
                        rotation: f,
                        label: v,
                        font: C,
                        color: I,
                        strokeColor: D,
                        strokeWidth: L,
                        textOffset: S,
                        textAlign: x,
                        textBaseline: E,
                        translation: [b, y],
                        backdrop: i
                    })
                }
                return g
            }
            _getXAxisLabelAlignment() {
                var {
                    position: t,
                    ticks: e
                } = this.options;
                if (-zr(this.labelRotation)) return "top" === t ? "left" : "right";
                let i = "center";
                return "start" === e.align ? i = "left" : "end" === e.align && (i = "right"), i
            }
            _getYAxisLabelAlignment(t) {
                var {
                    position: e,
                    ticks: {
                        crossAlign: i,
                        mirror: n,
                        padding: s
                    }
                } = this.options, o = t + s, t = this._getLabelSizes().widest.width;
                let a, r;
                return "left" === e ? n ? (r = this.right + s, "near" === i ? a = "left" : "center" === i ? (a = "center", r += t / 2) : (a = "right", r += t)) : (r = this.right - o, "near" === i ? a = "right" : "center" === i ? (a = "center", r -= t / 2) : (a = "left", r = this.left)) : "right" === e ? n ? (r = this.left + s, "near" === i ? a = "right" : "center" === i ? (a = "center", r -= t / 2) : (a = "left", r -= t)) : (r = this.left + o, "near" === i ? a = "left" : "center" === i ? (a = "center", r += t / 2) : (a = "right", r = this.right)) : a = "right", {
                    textAlign: a,
                    x: r
                }
            }
            _computeLabelArea() {
                if (!this.options.ticks.mirror) {
                    var t = this.chart,
                        e = this.options.position;
                    return "left" === e || "right" === e ? {
                        top: 0,
                        left: this.left,
                        bottom: t.height,
                        right: this.right
                    } : "top" === e || "bottom" === e ? {
                        top: this.top,
                        left: 0,
                        bottom: this.bottom,
                        right: t.width
                    } : void 0
                }
            }
            drawBackground() {
                const {
                    ctx: t,
                    options: {
                        backgroundColor: e
                    },
                    left: i,
                    top: n,
                    width: s,
                    height: o
                } = this;
                e && (t.save(), t.fillStyle = e, t.fillRect(i, n, s, o), t.restore())
            }
            getLineWidthForValue(e) {
                const t = this.options.grid;
                if (!this._isVisible() || !t.display) return 0;
                const i = this.ticks;
                var n = i.findIndex(t => t.value === e);
                return 0 <= n ? t.setContext(this.getContext(n)).lineWidth : 0
            }
            drawGrid(t) {
                var e = this.options.grid;
                const n = this.ctx;
                var i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
                let s, o;
                var a = (t, e, i) => {
                    i.width && i.color && (n.save(), n.lineWidth = i.width, n.strokeStyle = i.color, n.setLineDash(i.borderDash || []), n.lineDashOffset = i.borderDashOffset, n.beginPath(), n.moveTo(t.x, t.y), n.lineTo(e.x, e.y), n.stroke(), n.restore())
                };
                if (e.display)
                    for (s = 0, o = i.length; s < o; ++s) {
                        var r = i[s];
                        e.drawOnChartArea && a({
                            x: r.x1,
                            y: r.y1
                        }, {
                            x: r.x2,
                            y: r.y2
                        }, r), e.drawTicks && a({
                            x: r.tx1,
                            y: r.ty1
                        }, {
                            x: r.tx2,
                            y: r.ty2
                        }, {
                            color: r.tickColor,
                            width: r.tickWidth,
                            borderDash: r.tickBorderDash,
                            borderDashOffset: r.tickBorderDashOffset
                        })
                    }
            }
            drawBorder() {
                const {
                    chart: s,
                    ctx: o,
                    options: {
                        grid: a
                    }
                } = this;
                var r = a.setContext(this.getContext()),
                    l = a.drawBorder ? r.borderWidth : 0;
                if (l) {
                    var c = a.setContext(this.getContext(0)).lineWidth,
                        h = this._borderValue;
                    let t, e, i, n;
                    this.isHorizontal() ? (t = Yl(s, this.left, l) - l / 2, e = Yl(s, this.right, c) + c / 2, i = n = h) : (i = Yl(s, this.top, l) - l / 2, n = Yl(s, this.bottom, c) + c / 2, t = e = h), o.save(), o.lineWidth = r.borderWidth, o.strokeStyle = r.borderColor, o.beginPath(), o.moveTo(t, i), o.lineTo(e, n), o.stroke(), o.restore()
                }
            }
            drawLabels(i) {
                if (this.options.ticks.display) {
                    const c = this.ctx;
                    var n = this._computeLabelArea();
                    n && $l(c, n);
                    var s = this._labelItems || (this._labelItems = this._computeLabelItems(i));
                    let t, e;
                    for (t = 0, e = s.length; t < e; ++t) {
                        var o = s[t],
                            a = o.font,
                            r = o.label;
                        o.backdrop && (c.fillStyle = o.backdrop.color, c.fillRect(o.backdrop.left, o.backdrop.top, o.backdrop.width, o.backdrop.height));
                        var l = o.textOffset;
                        Gl(c, r, 0, l, a, o)
                    }
                    n && Ql(c)
                }
            }
            drawTitle() {
                var {
                    ctx: e,
                    options: {
                        position: i,
                        title: n,
                        reverse: s
                    }
                } = this;
                if (n.display) {
                    var o = rc(n.font),
                        a = ac(n.padding),
                        r = n.align;
                    let t = o.lineHeight / 2;
                    "bottom" === i || "center" === i || rr(i) ? (t += a.bottom, ar(n.text) && (t += o.lineHeight * (n.text.length - 1))) : t += a.top;
                    var {
                        titleX: l,
                        titleY: c,
                        maxWidth: h,
                        rotation: a
                    } = function(t, e, i, n) {
                        var {
                            top: s,
                            left: o,
                            bottom: a,
                            right: r,
                            chart: l
                        } = t;
                        const {
                            chartArea: c,
                            scales: h
                        } = l;
                        let d = 0,
                            u, p, f;
                        var g, _ = a - s,
                            m = r - o;
                        return t.isHorizontal() ? (p = ir(n, o, r), f = rr(i) ? (l = i[g = Object.keys(i)[0]], h[g].getPixelForValue(l) + _ - e) : "center" === i ? (c.bottom + c.top) / 2 + _ - e : Dd(t, i, e), u = r - o) : (p = rr(i) ? (o = i[r = Object.keys(i)[0]], h[r].getPixelForValue(o) - m + e) : "center" === i ? (c.left + c.right) / 2 - m + e : Dd(t, i, e), f = ir(n, a, s), d = "left" === i ? -Pr : Pr), {
                            titleX: p,
                            titleY: f,
                            maxWidth: u,
                            rotation: d
                        }
                    }(this, t, i, r);
                    Gl(e, n.text, 0, 0, o, {
                        color: n.color,
                        maxWidth: h,
                        rotation: a,
                        textAlign: function(t, e, i) {
                            let n = er(t);
                            return (i && "right" !== e || !i && "right" === e) && (n = "left" === (e = n) ? "right" : "right" === e ? "left" : e), n
                        }(r, i, s),
                        textBaseline: "middle",
                        translation: [l, c]
                    })
                }
            }
            draw(t) {
                this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
            }
            _layers() {
                var t = this.options,
                    e = t.ticks && t.ticks.z || 0,
                    t = hr(t.grid && t.grid.z, -1);
                return this._isVisible() && this.draw === Bd.prototype.draw ? [{
                    z: t,
                    draw: t => {
                        this.drawBackground(), this.drawGrid(t), this.drawTitle()
                    }
                }, {
                    z: t + 1,
                    draw: () => {
                        this.drawBorder()
                    }
                }, {
                    z: e,
                    draw: t => {
                        this.drawLabels(t)
                    }
                }] : [{
                    z: e,
                    draw: t => {
                        this.draw(t)
                    }
                }]
            }
            getMatchingVisibleMetas(t) {
                var e = this.chart.getSortedVisibleDatasetMetas(),
                    i = this.axis + "AxisID";
                const n = [];
                let s, o;
                for (s = 0, o = e.length; s < o; ++s) {
                    var a = e[s];
                    a[i] !== this.id || t && a.type !== t || n.push(a)
                }
                return n
            }
            _resolveTickFontOptions(t) {
                return rc(this.options.ticks.setContext(this.getContext(t)).font)
            }
            _maxDigits() {
                var t = this._resolveTickFontOptions(0).lineHeight;
                return (this.isHorizontal() ? this.width : this.height) / t
            }
        }
        class Nd {
            constructor(t, e, i) {
                this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
            }
            isForType(t) {
                return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
            }
            register(t) {
                var e = Object.getPrototypeOf(t);
                let i;
                "id" in (s = e) && "defaults" in s && (i = this.register(e));
                const n = this.items;
                var s = t.id,
                    e = this.scope + "." + s;
                if (!s) throw new Error("class does not have id: " + t);
                return s in n || (function(t, e, i) {
                    i = vr(Object.create(null), [i ? Vl.get(i) : {}, Vl.get(e), t.defaults]);
                    Vl.set(e, i), t.defaultRoutes && function(a, r) {
                        Object.keys(r).forEach(t => {
                            const e = t.split(".");
                            var i = e.pop(),
                                n = [a].concat(e).join(".");
                            const s = r[t].split(".");
                            var o = s.pop(),
                                t = s.join(".");
                            Vl.route(n, i, t, o)
                        })
                    }(e, t.defaultRoutes);
                    t.descriptors && Vl.describe(e, t.descriptors)
                }(n[s] = t, e, i), this.override && Vl.override(t.id, t.overrides)), e
            }
            get(t) {
                return this.items[t]
            }
            unregister(t) {
                const e = this.items;
                var i = t.id,
                    t = this.scope;
                i in e && delete e[i], t && i in Vl[t] && (delete Vl[t][i], this.override && delete Hl[i])
            }
        }
        var Hd = new class {
            constructor() {
                this.controllers = new Nd(Ch, "datasets", !0), this.elements = new Nd(Ad, "elements"), this.plugins = new Nd(Object, "plugins"), this.scales = new Nd(Bd, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
            }
            add(...t) {
                this._each("register", t)
            }
            remove(...t) {
                this._each("unregister", t)
            }
            addControllers(...t) {
                this._each("register", t, this.controllers)
            }
            addElements(...t) {
                this._each("register", t, this.elements)
            }
            addPlugins(...t) {
                this._each("register", t, this.plugins)
            }
            addScales(...t) {
                this._each("register", t, this.scales)
            }
            getController(t) {
                return this._get(t, this.controllers, "controller")
            }
            getElement(t) {
                return this._get(t, this.elements, "element")
            }
            getPlugin(t) {
                return this._get(t, this.plugins, "plugin")
            }
            getScale(t) {
                return this._get(t, this.scales, "scale")
            }
            removeControllers(...t) {
                this._each("unregister", t, this.controllers)
            }
            removeElements(...t) {
                this._each("unregister", t, this.elements)
            }
            removePlugins(...t) {
                this._each("unregister", t, this.plugins)
            }
            removeScales(...t) {
                this._each("unregister", t, this.scales)
            }
            _each(i, t, n) {
                [...t].forEach(t => {
                    const e = n || this._getRegistryForType(t);
                    n || e.isForType(t) || e === this.plugins && t.id ? this._exec(i, e, t) : pr(t, t => {
                        var e = n || this._getRegistryForType(t);
                        this._exec(i, e, t)
                    })
                })
            }
            _exec(t, e, i) {
                var n = Tr(t);
                ur(i["before" + n], [], i), e[t](i), ur(i["after" + n], [], i)
            }
            _getRegistryForType(e) {
                for (let t = 0; t < this._typedRegistries.length; t++) {
                    const i = this._typedRegistries[t];
                    if (i.isForType(e)) return i
                }
                return this.plugins
            }
            _get(t, e, i) {
                e = e.get(t);
                if (void 0 === e) throw new Error('"' + t + '" is not a registered ' + i + ".");
                return e
            }
        };
        class jd {
            constructor() {
                this._init = []
            }
            notify(t, e, i, n) {
                "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
                n = n ? this._descriptors(t).filter(n) : this._descriptors(t), i = this._notify(n, t, e, i);
                return "afterDestroy" === e && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), i
            }
            _notify(t, e, i, n) {
                n = n || {};
                for (const o of t) {
                    var s = o.plugin;
                    if (!1 === ur(s[i], [e, n, o.options], s) && n.cancelable) return !1
                }
                return !0
            }
            invalidate() {
                or(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
            }
            _descriptors(t) {
                if (this._cache) return this._cache;
                var e = this._cache = this._createDescriptors(t);
                return this._notifyStateChanges(t), e
            }
            _createDescriptors(t, e) {
                var i = t && t.config,
                    n = hr(i.options && i.options.plugins, {}),
                    i = function(t) {
                        const e = [],
                            i = Object.keys(Hd.plugins.items);
                        for (let t = 0; t < i.length; t++) e.push(Hd.getPlugin(i[t]));
                        var n = t.plugins || [];
                        for (let t = 0; t < n.length; t++) {
                            var s = n[t]; - 1 === e.indexOf(s) && e.push(s)
                        }
                        return e
                    }(i);
                return !1 !== n || e ? function(e, i, n, s) {
                    const o = [],
                        a = e.getContext();
                    for (let t = 0; t < i.length; t++) {
                        var r = i[t],
                            l = r.id,
                            l = function(t, e) {
                                return e || !1 !== t ? !0 !== t ? t : {} : null
                            }(n[l], s);
                        null !== l && o.push({
                            plugin: r,
                            options: function(t, e, i, n) {
                                e = t.pluginScopeKeys(e), e = t.getOptionScopes(i, e);
                                return t.createResolver(e, n, [""], {
                                    scriptable: !1,
                                    indexable: !1,
                                    allKeys: !0
                                })
                            }(e.config, r, l, a)
                        })
                    }
                    return o
                }(t, i, n, e) : []
            }
            _notifyStateChanges(t) {
                var e = this._oldCache || [],
                    i = this._cache,
                    n = (t, i) => t.filter(e => !i.some(t => e.plugin.id === t.plugin.id));
                this._notify(n(e, i), t, "stop"), this._notify(n(i, e), t, "start")
            }
        }

        function Wd(t, e) {
            var i = Vl.datasets[t] || {};
            return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
        }

        function Fd(t, e) {
            return "x" === t || "y" === t ? t : e.axis || ("top" === (e = e.position) || "bottom" === e ? "x" : "left" === e || "right" === e ? "y" : void 0) || t.charAt(0).toLowerCase()
        }

        function Vd(e, i) {
            const o = Hl[e.type] || {
                    scales: {}
                },
                a = i.scales || {},
                r = Wd(e.type, i),
                l = Object.create(null),
                c = Object.create(null);
            return Object.keys(a).forEach(t => {
                var e = a[t];
                if (!rr(e)) return console.error(`Invalid scale configuration for scale: ${t}`);
                if (e._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${t}`);
                var i, n = Fd(t, e),
                    i = (i = n, s = r, i === s ? "_index_" : "_value_"),
                    s = o.scales || {};
                l[n] = l[n] || t, c[t] = br(Object.create(null), [{
                    axis: n
                }, e, s[n], s[i]])
            }), e.data.datasets.forEach(n => {
                var t = n.type || e.type;
                const s = n.indexAxis || Wd(t, i),
                    o = (Hl[t] || {}).scales || {};
                Object.keys(o).forEach(t => {
                    var e = function(t, e) {
                            let i = t;
                            return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
                        }(t, s),
                        i = n[e + "AxisID"] || l[e] || e;
                    c[i] = c[i] || Object.create(null), br(c[i], [{
                        axis: e
                    }, a[i], o[t]])
                })
            }), Object.keys(c).forEach(t => {
                t = c[t];
                br(t, [Vl.scales[t.type], Vl.scale])
            }), c
        }

        function zd(t) {
            const e = t.options || (t.options = {});
            e.plugins = hr(e.plugins, {}), e.scales = Vd(t, e)
        }

        function Yd(t) {
            return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
        }
        const Xd = new Map,
            Ud = new Set;

        function Kd(t, e) {
            let i = Xd.get(t);
            return i || (i = e(), Xd.set(t, i), Ud.add(i)), i
        }
        const $d = (t, e, i) => {
            i = kr(e, i);
            void 0 !== i && t.add(i)
        };
        class Qd {
            constructor(t) {
                this._config = ((t = (t = t) || {}).data = Yd(t.data), zd(t), t), this._scopeCache = new Map, this._resolverCache = new Map
            }
            get platform() {
                return this._config.platform
            }
            get type() {
                return this._config.type
            }
            set type(t) {
                this._config.type = t
            }
            get data() {
                return this._config.data
            }
            set data(t) {
                this._config.data = Yd(t)
            }
            get options() {
                return this._config.options
            }
            set options(t) {
                this._config.options = t
            }
            get plugins() {
                return this._config.plugins
            }
            update() {
                var t = this._config;
                this.clearCache(), zd(t)
            }
            clearCache() {
                this._scopeCache.clear(), this._resolverCache.clear()
            }
            datasetScopeKeys(t) {
                return Kd(t, () => [
                    [`datasets.${t}`, ""]
                ])
            }
            datasetAnimationScopeKeys(t, e) {
                return Kd(`${t}.transition.${e}`, () => [
                    [`datasets.${t}.transitions.${e}`, `transitions.${e}`],
                    [`datasets.${t}`, ""]
                ])
            }
            datasetElementScopeKeys(t, e) {
                return Kd(`${t}-${e}`, () => [
                    [`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]
                ])
            }
            pluginScopeKeys(t) {
                const e = t.id;
                return Kd(`${this.type}-plugin-${e}`, () => [
                    [`plugins.${e}`, ...t.additionalOptionScopes || []]
                ])
            }
            _cachedScopes(t, e) {
                const i = this._scopeCache;
                let n = i.get(t);
                return n && !e || (n = new Map, i.set(t, n)), n
            }
            getOptionScopes(e, t, i) {
                const {
                    options: n,
                    type: s
                } = this, o = this._cachedScopes(e, i);
                i = o.get(t);
                if (i) return i;
                const a = new Set;
                t.forEach(t => {
                    e && (a.add(e), t.forEach(t => $d(a, e, t))), t.forEach(t => $d(a, n, t)), t.forEach(t => $d(a, Hl[s] || {}, t)), t.forEach(t => $d(a, Vl, t)), t.forEach(t => $d(a, jl, t))
                });
                const r = Array.from(a);
                return 0 === r.length && r.push(Object.create(null)), Ud.has(t) && o.set(t, r), r
            }
            chartOptionScopes() {
                var {
                    options: t,
                    type: e
                } = this;
                return [t, Hl[e] || {}, Vl.datasets[e] || {}, {
                    type: e
                }, Vl, jl]
            }
            resolveNamedOptions(t, e, i, n = [""]) {
                const s = {
                    $shared: !0
                };
                var {
                    resolver: o,
                    subPrefixes: n
                } = qd(this._resolverCache, t, n);
                let a = o;
                ! function(t, e) {
                    const {
                        isScriptable: i,
                        isIndexable: n
                    } = vc(t);
                    for (const r of e) {
                        var s = i(r),
                            o = n(r),
                            a = (o || s) && t[r];
                        if (s && (Er(a) || Zd(a)) || o && ar(a)) return !0
                    }
                    return !1
                }(o, e) || (s.$shared = !1, i = Er(i) ? i() : i, n = this.createResolver(t, i, n), a = mc(o, i, n));
                for (const r of e) s[r] = a[r];
                return s
            }
            createResolver(t, e, i = [""], n) {
                var i = qd(this._resolverCache, t, i)["resolver"];
                return rr(e) ? mc(i, e, void 0, n) : i
            }
        }

        function qd(t, e, i) {
            let n = t.get(e);
            n || (n = new Map, t.set(e, n));
            t = i.join();
            let s = n.get(t);
            return s || (e = _c(e, i), s = {
                resolver: e,
                subPrefixes: i.filter(t => !t.toLowerCase().includes("hover"))
            }, n.set(t, s)), s
        }
        const Zd = i => rr(i) && Object.getOwnPropertyNames(i).reduce((t, e) => t || Er(i[e]), !1);
        const Gd = ["top", "bottom", "left", "right", "chartArea"];

        function Jd(t, e) {
            return "top" === t || "bottom" === t || -1 === Gd.indexOf(t) && "x" === e
        }

        function tu(i, n) {
            return function(t, e) {
                return t[i] === e[i] ? t[n] - e[n] : t[i] - e[i]
            }
        }

        function eu(t) {
            const e = t.chart;
            var i = e.options.animation;
            e.notifyPlugins("afterRender"), ur(i && i.onComplete, [t], e)
        }

        function iu(t) {
            var e = t.chart,
                i = e.options.animation;
            ur(i && i.onProgress, [t], e)
        }

        function nu(t) {
            return Pc() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t = t && t.canvas ? t.canvas : t
        }
        const su = {},
            ou = t => {
                const e = nu(t);
                return Object.values(su).filter(t => t.canvas === e).pop()
            };
        class au {
            constructor(t, e) {
                const i = this.config = new Qd(e);
                var n = nu(t),
                    s = ou(n);
                if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas can be reused.");
                e = i.createResolver(i.chartOptionScopes(), this.getContext());
                this.platform = new(i.platform || (o = n, !Pc() || "undefined" != typeof OffscreenCanvas && o instanceof OffscreenCanvas ? ud : Ed)), this.platform.updateConfig(i);
                var t = this.platform.acquireContext(n, e.aspectRatio),
                    s = t && t.canvas,
                    o = s && s.height,
                    n = s && s.width;
                this.id = sr(), this.ctx = t, this.canvas = s, this.width = n, this.height = o, this._options = e, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new jd, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function(e, i) {
                    let n;
                    return function(...t) {
                        return i ? (clearTimeout(n), n = setTimeout(e, i, t)) : e.apply(this, t), i
                    }
                }(t => this.update(t), e.resizeDelay || 0), this._dataChanges = [], su[this.id] = this, t && s ? (rh.listen(this, "complete", eu), rh.listen(this, "progress", iu), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
            }
            get aspectRatio() {
                var {
                    options: {
                        aspectRatio: t,
                        maintainAspectRatio: e
                    },
                    width: i,
                    height: n,
                    _aspectRatio: s
                } = this;
                return or(t) ? e && s ? s : n ? i / n : null : t
            }
            get data() {
                return this.config.data
            }
            set data(t) {
                this.config.data = t
            }
            get options() {
                return this._options
            }
            set options(t) {
                this.config.options = t
            }
            _initialize() {
                return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Yc(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
            }
            clear() {
                return Xl(this.canvas, this.ctx), this
            }
            stop() {
                return rh.stop(this), this
            }
            resize(t, e) {
                rh.running(this) ? this._resizeBeforeDraw = {
                    width: t,
                    height: e
                } : this._resize(t, e)
            }
            _resize(t, e) {
                var i = this.options,
                    n = this.canvas,
                    s = i.maintainAspectRatio && this.aspectRatio,
                    t = this.platform.getMaximumSize(n, t, e, s),
                    e = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
                    s = this.width ? "resize" : "attach";
                this.width = t.width, this.height = t.height, this._aspectRatio = this.aspectRatio, Yc(this, e, !0) && (this.notifyPlugins("resize", {
                    size: t
                }), ur(i.onResize, [this, t], this), this.attached && this._doResize(s) && this.render())
            }
            ensureScalesHaveIDs() {
                pr(this.options.scales || {}, (t, e) => {
                    t.id = e
                })
            }
            buildOrUpdateScales() {
                const r = this.options,
                    n = r.scales,
                    l = this.scales,
                    c = Object.keys(l).reduce((t, e) => (t[e] = !1, t), {});
                let t = [];
                n && (t = t.concat(Object.keys(n).map(t => {
                    var e = n[t],
                        i = Fd(t, e),
                        t = "r" === i,
                        i = "x" === i;
                    return {
                        options: e,
                        dposition: t ? "chartArea" : i ? "bottom" : "left",
                        dtype: t ? "radialLinear" : i ? "category" : "linear"
                    }
                }))), pr(t, t => {
                    const e = t.options;
                    var i = e.id,
                        n = Fd(i, e),
                        s = hr(e.type, t.dtype);
                    void 0 !== e.position && Jd(e.position, n) === Jd(t.dposition) || (e.position = t.dposition), c[i] = !0;
                    let o = null;
                    if (i in l && l[i].type === s) o = l[i];
                    else {
                        const a = Hd.getScale(s);
                        o = new a({
                            id: i,
                            type: s,
                            ctx: this.ctx,
                            chart: this
                        }), l[o.id] = o
                    }
                    o.init(e, r)
                }), pr(c, (t, e) => {
                    t || delete l[e]
                }), pr(l, t => {
                    cd(this, t, t.options), rd(this, t)
                })
            }
            _updateMetasets() {
                const t = this._metasets;
                var e = this.data.datasets.length,
                    i = t.length;
                if (t.sort((t, e) => t.index - e.index), e < i) {
                    for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
                    t.splice(e, i - e)
                }
                this._sortedMetasets = t.slice(0).sort(tu("order", "index"))
            }
            _removeUnreferencedMetasets() {
                const {
                    _metasets: t,
                    data: {
                        datasets: i
                    }
                } = this;
                t.length > i.length && delete this._stacks, t.forEach((e, t) => {
                    0 === i.filter(t => t === e._dataset).length && this._destroyDatasetMeta(t)
                })
            }
            buildOrUpdateControllers() {
                const e = [];
                var i = this.data.datasets;
                let n, t;
                for (this._removeUnreferencedMetasets(), n = 0, t = i.length; n < t; n++) {
                    var s = i[n];
                    let t = this.getDatasetMeta(n);
                    var o = s.type || this.config.type;
                    if (t.type && t.type !== o && (this._destroyDatasetMeta(n), t = this.getDatasetMeta(n)), t.type = o, t.indexAxis = s.indexAxis || Wd(o, this.options), t.order = s.order || 0, t.index = n, t.label = "" + s.label, t.visible = this.isDatasetVisible(n), t.controller) t.controller.updateIndex(n), t.controller.linkScales();
                    else {
                        const a = Hd.getController(o);
                        var {
                            datasetElementType: s,
                            dataElementType: o
                        } = Vl.datasets[o];
                        Object.assign(a.prototype, {
                            dataElementType: Hd.getElement(o),
                            datasetElementType: s && Hd.getElement(s)
                        }), t.controller = new a(this, n), e.push(t.controller)
                    }
                }
                return this._updateMetasets(), e
            }
            _resetElements() {
                pr(this.data.datasets, (t, e) => {
                    this.getDatasetMeta(e).controller.reset()
                }, this)
            }
            reset() {
                this._resetElements(), this.notifyPlugins("reset")
            }
            update(t) {
                const e = this.config;
                e.update();
                var n = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),
                    s = this._animationsDisabled = !n.animation;
                if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 !== this.notifyPlugins("beforeUpdate", {
                        mode: t,
                        cancelable: !0
                    })) {
                    const a = this.buildOrUpdateControllers();
                    this.notifyPlugins("beforeElementsUpdate");
                    let i = 0;
                    for (let t = 0, e = this.data.datasets.length; t < e; t++) {
                        const r = this.getDatasetMeta(t)["controller"];
                        var o = !s && -1 === a.indexOf(r);
                        r.buildOrUpdateElements(o), i = Math.max(+r.getMaxOverflow(), i)
                    }
                    i = this._minPadding = n.layout.autoPadding ? i : 0, this._updateLayout(i), s || pr(a, t => {
                        t.reset()
                    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
                        mode: t
                    }), this._layers.sort(tu("z", "_idx"));
                    var {
                        _active: n,
                        _lastEvent: t
                    } = this;
                    t ? this._eventHandler(t, !0) : n.length && this._updateHoverStyles(n, n, !0), this.render()
                }
            }
            _updateScales() {
                pr(this.scales, t => {
                    ld(this, t)
                }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
            }
            _checkEventBindings() {
                var t = this.options,
                    e = new Set(Object.keys(this._listeners)),
                    i = new Set(t.events);
                Ar(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())
            }
            _updateHiddenIndices() {
                var t, e, i, n = this["_hiddenIndices"];
                for ({
                        method: t,
                        start: e,
                        count: i
                    } of this._getUniformDataChanges() || []) {
                    var s = "_removeElements" === t ? -i : i;
                    ! function(t, e, i) {
                        for (const o of Object.keys(t)) {
                            var n, s = +o;
                            e <= s && (n = t[o], delete t[o], (0 < i || e < s) && (t[s + i] = n))
                        }
                    }(n, e, s)
                }
            }
            _getUniformDataChanges() {
                const t = this._dataChanges;
                if (t && t.length) {
                    this._dataChanges = [];
                    var e = this.data.datasets.length,
                        i = e => new Set(t.filter(t => t[0] === e).map((t, e) => e + "," + t.splice(1).join(","))),
                        n = i(0);
                    for (let t = 1; t < e; t++)
                        if (!Ar(n, i(t))) return;
                    return Array.from(n).map(t => t.split(",")).map(t => ({
                        method: t[1],
                        start: +t[2],
                        count: +t[3]
                    }))
                }
            }
            _updateLayout(t) {
                if (!1 !== this.notifyPlugins("beforeLayout", {
                        cancelable: !0
                    })) {
                    hd(this, this.width, this.height, t);
                    t = this.chartArea;
                    const e = t.width <= 0 || t.height <= 0;
                    this._layers = [], pr(this.boxes, t => {
                        e && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()))
                    }, this), this._layers.forEach((t, e) => {
                        t._idx = e
                    }), this.notifyPlugins("afterLayout")
                }
            }
            _updateDatasets(i) {
                if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                        mode: i,
                        cancelable: !0
                    })) {
                    for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();
                    for (let t = 0, e = this.data.datasets.length; t < e; ++t) this._updateDataset(t, Er(i) ? i({
                        datasetIndex: t
                    }) : i);
                    this.notifyPlugins("afterDatasetsUpdate", {
                        mode: i
                    })
                }
            }
            _updateDataset(t, e) {
                const i = this.getDatasetMeta(t),
                    n = {
                        meta: i,
                        index: t,
                        mode: e,
                        cancelable: !0
                    };
                !1 !== this.notifyPlugins("beforeDatasetUpdate", n) && (i.controller._update(e), n.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", n))
            }
            render() {
                !1 !== this.notifyPlugins("beforeRender", {
                    cancelable: !0
                }) && (rh.has(this) ? this.attached && !rh.running(this) && rh.start(this) : (this.draw(), eu({
                    chart: this
                })))
            }
            draw() {
                let t;
                var e, i;
                if (this._resizeBeforeDraw && ({
                        width: e,
                        height: i
                    } = this._resizeBeforeDraw, this._resize(e, i), this._resizeBeforeDraw = null), this.clear(), !(this.width <= 0 || this.height <= 0) && !1 !== this.notifyPlugins("beforeDraw", {
                        cancelable: !0
                    })) {
                    const n = this._layers;
                    for (t = 0; t < n.length && n[t].z <= 0; ++t) n[t].draw(this.chartArea);
                    for (this._drawDatasets(); t < n.length; ++t) n[t].draw(this.chartArea);
                    this.notifyPlugins("afterDraw")
                }
            }
            _getSortedDatasetMetas(t) {
                var e = this._sortedMetasets;
                const i = [];
                let n, s;
                for (n = 0, s = e.length; n < s; ++n) {
                    var o = e[n];
                    t && !o.visible || i.push(o)
                }
                return i
            }
            getSortedVisibleDatasetMetas() {
                return this._getSortedDatasetMetas(!0)
            }
            _drawDatasets() {
                if (!1 !== this.notifyPlugins("beforeDatasetsDraw", {
                        cancelable: !0
                    })) {
                    var e = this.getSortedVisibleDatasetMetas();
                    for (let t = e.length - 1; 0 <= t; --t) this._drawDataset(e[t]);
                    this.notifyPlugins("afterDatasetsDraw")
                }
            }
            _drawDataset(t) {
                var e = this.ctx,
                    i = t._clip,
                    n = !i.disabled,
                    s = this.chartArea;
                const o = {
                    meta: t,
                    index: t.index,
                    cancelable: !0
                };
                !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (n && $l(e, {
                    left: !1 === i.left ? 0 : s.left - i.left,
                    right: !1 === i.right ? this.width : s.right + i.right,
                    top: !1 === i.top ? 0 : s.top - i.top,
                    bottom: !1 === i.bottom ? this.height : s.bottom + i.bottom
                }), t.controller.draw(), n && Ql(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o))
            }
            getElementsAtEventForMode(t, e, i, n) {
                const s = Qh.modes[e];
                return "function" == typeof s ? s(this, t, i, n) : []
            }
            getDatasetMeta(t) {
                const e = this.data.datasets[t],
                    i = this._metasets;
                let n = i.filter(t => t && t._dataset === e).pop();
                return n || (n = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: e && e.order || 0,
                    index: t,
                    _dataset: e,
                    _parsed: [],
                    _sorted: !1
                }, i.push(n)), n
            }
            getContext() {
                return this.$context || (this.$context = cc(null, {
                    chart: this,
                    type: "chart"
                }))
            }
            getVisibleDatasetCount() {
                return this.getSortedVisibleDatasetMetas().length
            }
            isDatasetVisible(t) {
                var e = this.data.datasets[t];
                if (!e) return !1;
                t = this.getDatasetMeta(t);
                return "boolean" == typeof t.hidden ? !t.hidden : !e.hidden
            }
            setDatasetVisibility(t, e) {
                const i = this.getDatasetMeta(t);
                i.hidden = !e
            }
            toggleDataVisibility(t) {
                this._hiddenIndices[t] = !this._hiddenIndices[t]
            }
            getDataVisibility(t) {
                return !this._hiddenIndices[t]
            }
            _updateVisibility(e, t, i) {
                const n = i ? "show" : "hide",
                    s = this.getDatasetMeta(e),
                    o = s.controller._resolveAnimations(void 0, n);
                Sr(t) ? (s.data[t].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(s, {
                    visible: i
                }), this.update(t => t.datasetIndex === e ? n : void 0))
            }
            hide(t, e) {
                this._updateVisibility(t, e, !1)
            }
            show(t, e) {
                this._updateVisibility(t, e, !0)
            }
            _destroyDatasetMeta(t) {
                const e = this._metasets[t];
                e && e.controller && e.controller._destroy(), delete this._metasets[t]
            }
            _stop() {
                let t, e;
                for (this.stop(), rh.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t)
            }
            destroy() {
                this.notifyPlugins("beforeDestroy");
                var {
                    canvas: t,
                    ctx: e
                } = this;
                this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Xl(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete su[this.id], this.notifyPlugins("afterDestroy")
            }
            toBase64Image(...t) {
                return this.canvas.toDataURL(...t)
            }
            bindEvents() {
                this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
            }
            bindUserEvents() {
                const i = this._listeners,
                    n = this.platform,
                    e = (t, e) => {
                        n.addEventListener(this, t, e), i[t] = e
                    },
                    s = (t, e, i) => {
                        t.offsetX = e, t.offsetY = i, this._eventHandler(t)
                    };
                pr(this.options.events, t => e(t, s))
            }
            bindResponsiveEvents() {
                this._responsiveListeners || (this._responsiveListeners = {});
                const i = this._responsiveListeners,
                    n = this.platform,
                    t = (t, e) => {
                        n.addEventListener(this, t, e), i[t] = e
                    },
                    e = (t, e) => {
                        i[t] && (n.removeEventListener(this, t, e), delete i[t])
                    },
                    s = (t, e) => {
                        this.canvas && this.resize(t, e)
                    };
                let o;
                const a = () => {
                    e("attach", a), this.attached = !0, this.resize(), t("resize", s), t("detach", o)
                };
                o = () => {
                    this.attached = !1, e("resize", s), this._stop(), this._resize(0, 0), t("attach", a)
                }, (n.isAttached(this.canvas) ? a : o)()
            }
            unbindEvents() {
                pr(this._listeners, (t, e) => {
                    this.platform.removeEventListener(this, e, t)
                }), this._listeners = {}, pr(this._responsiveListeners, (t, e) => {
                    this.platform.removeEventListener(this, e, t)
                }), this._responsiveListeners = void 0
            }
            updateHoverStyle(t, e, i) {
                var n = i ? "set" : "remove";
                let s, o, a, r;
                for ("dataset" === e && (s = this.getDatasetMeta(t[0].datasetIndex), s.controller["_" + n + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) {
                    const l = (o = t[a]) && this.getDatasetMeta(o.datasetIndex).controller;
                    l && l[n + "HoverStyle"](o.element, o.datasetIndex, o.index)
                }
            }
            getActiveElements() {
                return this._active || []
            }
            setActiveElements(t) {
                var e = this._active || [],
                    t = t.map(({
                        datasetIndex: t,
                        index: e
                    }) => {
                        var i = this.getDatasetMeta(t);
                        if (!i) throw new Error("No dataset found at index " + t);
                        return {
                            datasetIndex: t,
                            element: i.data[e],
                            index: e
                        }
                    });
                fr(t, e) || (this._active = t, this._lastEvent = null, this._updateHoverStyles(t, e))
            }
            notifyPlugins(t, e, i) {
                return this._plugins.notify(this, t, e, i)
            }
            _updateHoverStyles(t, e, i) {
                var n = this.options.hover,
                    s = (t, i) => t.filter(e => !i.some(t => e.datasetIndex === t.datasetIndex && e.index === t.index)),
                    o = s(e, t),
                    e = i ? t : s(t, e);
                o.length && this.updateHoverStyle(o, n.mode, !1), e.length && n.mode && this.updateHoverStyle(e, n.mode, !0)
            }
            _eventHandler(e, t) {
                const i = {
                    event: e,
                    replay: t,
                    cancelable: !0,
                    inChartArea: Kl(e, this.chartArea, this._minPadding)
                };
                var n = t => (t.options.events || this.options.events).includes(e.native.type);
                if (!1 !== this.notifyPlugins("beforeEvent", i, n)) {
                    t = this._handleEvent(e, t, i.inChartArea);
                    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, n), (t || i.changed) && this.render(), this
                }
            }
            _handleEvent(t, e, i) {
                var n, s, o, {
                        _active: a = [],
                        options: r
                    } = this,
                    l = this._getActiveElements(t, a, i, e),
                    c = "mouseup" === (o = t).type || "click" === o.type || "contextmenu" === o.type,
                    n = (n = t, s = this._lastEvent, o = c, i && "mouseout" !== n.type ? o ? s : n : null);
                i && (this._lastEvent = null, ur(r.onHover, [t, l, this], this), c && ur(r.onClick, [t, l, this], this));
                t = !fr(l, a);
                return (t || e) && (this._active = l, this._updateHoverStyles(l, a, e)), this._lastEvent = n, t
            }
            _getActiveElements(t, e, i, n) {
                if ("mouseout" === t.type) return [];
                if (!i) return e;
                e = this.options.hover;
                return this.getElementsAtEventForMode(t, e.mode, e, n)
            }
        }
        const ru = () => pr(au.instances, t => t._plugins.invalidate());

        function lu(t, e, i) {
            var {
                startAngle: n,
                pixelMargin: s,
                x: o,
                y: a,
                outerRadius: r,
                innerRadius: l
            } = e, e = s / r;
            t.beginPath(), t.arc(o, a, r, n - e, i + e), s < l ? t.arc(o, a, l, i + (e = s / l), n - e, !0) : t.arc(o, a, s, i + Pr, n - Pr), t.closePath(), t.clip()
        }

        function cu(t, e, i, n) {
            var s = nc(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
            const o = (i - e) / 2;
            t = Math.min(o, n * e / 2), e = t => {
                var e = (i - Math.min(o, t)) * n / 2;
                return Zr(t, 0, Math.min(o, e))
            };
            return {
                outerStart: e(s.outerStart),
                outerEnd: e(s.outerEnd),
                innerStart: Zr(s.innerStart, 0, t),
                innerEnd: Zr(s.innerEnd, 0, t)
            }
        }

        function hu(t, e, i, n) {
            return {
                x: i + t * Math.cos(e),
                y: n + t * Math.sin(e)
            }
        }

        function du(t, e, i, n, s) {
            var {
                x: o,
                y: a,
                startAngle: r,
                pixelMargin: l,
                innerRadius: c
            } = e, h = Math.max(e.outerRadius + n + i - l, 0), d = 0 < c ? c + n + i + l : 0;
            let u = 0;
            var p = s - r;
            n && (b = ((0 < c ? c - n : 0) + (0 < h ? h - n : 0)) / 2, u = (p - (0 != b ? p * b / (b + n) : p)) / 2);
            var f = (p - Math.max(.001, p * h - i / Mr) / h) / 2,
                g = r + f + u,
                _ = s - f - u,
                {
                    outerStart: m,
                    outerEnd: v,
                    innerStart: l,
                    innerEnd: c
                } = cu(e, d, h, _ - g),
                b = h - m,
                n = h - v,
                p = g + m / b,
                i = _ - v / n,
                r = d + l,
                s = d + c,
                f = g + l / r,
                e = _ - c / s;
            t.beginPath(), t.arc(o, a, h, p, i), 0 < v && (n = hu(n, i, o, a), t.arc(n.x, n.y, v, i, _ + Pr));
            i = hu(s, _, o, a);
            t.lineTo(i.x, i.y), 0 < c && (s = hu(s, e, o, a), t.arc(s.x, s.y, c, _ + Pr, e + Math.PI)), t.arc(o, a, d, _ - c / d, g + l / d, !0), 0 < l && (r = hu(r, f, o, a), t.arc(r.x, r.y, l, f + Math.PI, g - Pr));
            f = hu(b, g, o, a);
            t.lineTo(f.x, f.y), 0 < m && (a = hu(b, p, o, a), t.arc(a.x, a.y, m, g - Pr, p)), t.closePath()
        }

        function uu(t, e, i, n, s) {
            var o = e["options"],
                {
                    borderWidth: a,
                    borderJoinStyle: r
                } = o,
                o = "inner" === o.borderAlign;
            a && (o ? (t.lineWidth = 2 * a, t.lineJoin = r || "round") : (t.lineWidth = a, t.lineJoin = r || "bevel"), e.fullCircles && function(t, e, i) {
                var {
                    x: n,
                    y: s,
                    startAngle: o,
                    pixelMargin: a,
                    fullCircles: r
                } = e, l = Math.max(e.outerRadius - a, 0), a = e.innerRadius + a;
                let c;
                for (i && lu(t, e, o + Or), t.beginPath(), t.arc(n, s, a, o + Or, o, !0), c = 0; c < r; ++c) t.stroke();
                for (t.beginPath(), t.arc(n, s, l, o, o + Or), c = 0; c < r; ++c) t.stroke()
            }(t, e, o), o && lu(t, e, s), du(t, e, i, n, s), t.stroke())
        }
        Object.defineProperties(au, {
            defaults: {
                enumerable: !0,
                value: Vl
            },
            instances: {
                enumerable: !0,
                value: su
            },
            overrides: {
                enumerable: !0,
                value: Hl
            },
            registry: {
                enumerable: !0,
                value: Hd
            },
            version: {
                enumerable: !0,
                value: "3.7.1"
            },
            getChart: {
                enumerable: !0,
                value: ou
            },
            register: {
                enumerable: !0,
                value: (...t) => {
                    Hd.add(...t), ru()
                }
            },
            unregister: {
                enumerable: !0,
                value: (...t) => {
                    Hd.remove(...t), ru()
                }
            }
        });
        class pu extends Ad {
            constructor(t) {
                super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
            }
            inRange(t, e, i) {
                var {
                    angle: n,
                    distance: s
                } = Ur(this.getProps(["x", "y"], i), {
                    x: t,
                    y: e
                }), {
                    startAngle: o,
                    endAngle: a,
                    innerRadius: r,
                    outerRadius: t,
                    circumference: e
                } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), i = this.options.spacing / 2, a = hr(e, a - o) >= Or || qr(n, o, a), i = Gr(s, r + i, t + i);
                return a && i
            }
            getCenterPoint(t) {
                var {
                    x: e,
                    y: i,
                    startAngle: n,
                    endAngle: s,
                    innerRadius: o,
                    outerRadius: a
                } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t), {
                    offset: r,
                    spacing: t
                } = this.options, s = (n + s) / 2, r = (o + a + t + r) / 2;
                return {
                    x: e + Math.cos(s) * r,
                    y: i + Math.sin(s) * r
                }
            }
            tooltipPosition(t) {
                return this.getCenterPoint(t)
            }
            draw(e) {
                var {
                    options: i,
                    circumference: n
                } = this, s = (i.offset || 0) / 2, o = (i.spacing || 0) / 2;
                if (this.pixelMargin = "inner" === i.borderAlign ? .33 : 0, this.fullCircles = n > Or ? Math.floor(n / Or) : 0, !(0 === n || this.innerRadius < 0 || this.outerRadius < 0)) {
                    e.save();
                    let t = 0;
                    s && (t = s / 2, n = (this.startAngle + this.endAngle) / 2, e.translate(Math.cos(n) * t, Math.sin(n) * t), this.circumference >= Mr && (t = s)), e.fillStyle = i.backgroundColor, e.strokeStyle = i.borderColor;
                    i = function(e, t, i, n) {
                        var {
                            fullCircles: s,
                            startAngle: o,
                            circumference: a
                        } = t;
                        let r = t.endAngle;
                        if (s) {
                            du(e, t, i, n, o + Or);
                            for (let t = 0; t < s; ++t) e.fill();
                            isNaN(a) || (r = o + a % Or, a % Or == 0 && (r += Or))
                        }
                        return du(e, t, i, n, r), e.fill(), r
                    }(e, this, t, o);
                    uu(e, this, t, o, i), e.restore()
                }
            }
        }

        function fu(t, e, i = e) {
            t.lineCap = hr(i.borderCapStyle, e.borderCapStyle), t.setLineDash(hr(i.borderDash, e.borderDash)), t.lineDashOffset = hr(i.borderDashOffset, e.borderDashOffset), t.lineJoin = hr(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = hr(i.borderWidth, e.borderWidth), t.strokeStyle = hr(i.borderColor, e.borderColor)
        }

        function gu(t, e, i) {
            t.lineTo(i.x, i.y)
        }

        function _u(t, e, i = {}) {
            var n = t.length,
                {
                    start: s = 0,
                    end: o = n - 1
                } = i,
                {
                    start: a,
                    end: r
                } = e,
                t = Math.max(s, a),
                i = Math.min(o, r);
            return {
                count: n,
                start: t,
                loop: e.loop,
                ilen: i < t && !(s < a && o < a || r < s && r < o) ? n + i - t : i - t
            }
        }

        function mu(t, e, i, n) {
            var {
                points: s,
                options: o
            } = e, {
                count: a,
                start: r,
                loop: e,
                ilen: l
            } = _u(s, i, n);
            const c = (i = o).stepped ? ql : i.tension || "monotone" === i.cubicInterpolationMode ? Zl : gu;
            let {
                move: h = !0,
                reverse: d
            } = n || {}, u, p, f;
            for (u = 0; u <= l; ++u) p = s[(r + (d ? l - u : u)) % a], p.skip || (h ? (t.moveTo(p.x, p.y), h = !1) : c(t, f, p, d, o.stepped), f = p);
            return e && (p = s[(r + (d ? l : 0)) % a], c(t, f, p, d, o.stepped)), !!e
        }

        function vu(t, e, i, n) {
            var s = e.points;
            const {
                count: o,
                start: a,
                ilen: r
            } = _u(s, i, n), {
                move: l = !0,
                reverse: c
            } = n || {};
            let h = 0,
                d = 0,
                u, p, f, g, _, m;
            var v, b, y, x = t => (a + (c ? r - t : t)) % o,
                w = () => {
                    g !== _ && (t.lineTo(h, _), t.lineTo(h, g), t.lineTo(h, m))
                };
            for (l && (p = s[x(0)], t.moveTo(p.x, p.y)), u = 0; u <= r; ++u) p = s[x(u)], p.skip || (v = p.x, b = p.y, (y = 0 | v) === f ? (b < g ? g = b : b > _ && (_ = b), h = (d * h + v) / ++d) : (w(), t.lineTo(v, b), f = y, d = 0, g = _ = b), m = b);
            w()
        }

        function bu(t) {
            var e = t.options,
                i = e.borderDash && e.borderDash.length;
            return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? vu : mu
        }
        pu.id = "arc", pu.defaults = {
            borderAlign: "center",
            borderColor: "#fff",
            borderJoinStyle: void 0,
            borderRadius: 0,
            borderWidth: 2,
            offset: 0,
            spacing: 0,
            angle: void 0
        }, pu.defaultRoutes = {
            backgroundColor: "backgroundColor"
        };
        const yu = "function" == typeof Path2D;

        function xu(t, e, i, n) {
            (yu && !e.options.segment ? function(t, e, i, n) {
                let s = e._path;
                s || (s = e._path = new Path2D, e.path(s, i, n) && s.closePath()), fu(t, e.options), t.stroke(s)
            } : function(t, e, i, n) {
                var {
                    segments: s,
                    options: o
                } = e;
                const a = bu(e);
                for (const r of s) fu(t, o, r.style), t.beginPath(), a(t, e, r, {
                    start: i,
                    end: i + n - 1
                }) && t.closePath(), t.stroke()
            })(t, e, i, n)
        }
        class wu extends Ad {
            constructor(t) {
                super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t)
            }
            updateControlPoints(t, e) {
                var i, n = this.options;
                !n.tension && "monotone" !== n.cubicInterpolationMode || n.stepped || this._pointsUpdated || (i = n.spanGaps ? this._loop : this._fullLoop, Lc(this._points, n, t, i, e), this._pointsUpdated = !0)
            }
            set points(t) {
                this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1
            }
            get points() {
                return this._points
            }
            get segments() {
                return this._segments || (this._segments = sh(this, this.options.segment))
            }
            first() {
                var t = this.segments,
                    e = this.points;
                return t.length && e[t[0].start]
            }
            last() {
                var t = this.segments,
                    e = this.points,
                    i = t.length;
                return i && e[t[i - 1].end]
            }
            interpolate(i, n) {
                var s, o = this.options,
                    a = i[n],
                    r = this.points,
                    l = nh(this, {
                        property: n,
                        start: a,
                        end: a
                    });
                if (l.length) {
                    const u = [],
                        p = (s = o).stepped ? Kc : s.tension || "monotone" === s.cubicInterpolationMode ? $c : Uc;
                    let t, e;
                    for (t = 0, e = l.length; t < e; ++t) {
                        var {
                            start: c,
                            end: h
                        } = l[t], d = r[c], c = r[h];
                        if (d !== c) {
                            h = Math.abs((a - d[n]) / (c[n] - d[n]));
                            const f = p(d, c, h, o.stepped);
                            f[n] = i[n], u.push(f)
                        } else u.push(d)
                    }
                    return 1 === u.length ? u[0] : u
                }
            }
            pathSegment(t, e, i) {
                const n = bu(this);
                return n(t, this, e, i)
            }
            path(t, e, i) {
                var n = this.segments;
                const s = bu(this);
                let o = this._loop;
                e = e || 0, i = i || this.points.length - e;
                for (const a of n) o &= s(t, this, a, {
                    start: e,
                    end: e + i - 1
                });
                return !!o
            }
            draw(t, e, i, n) {
                var s = this.options || {};
                (this.points || []).length && s.borderWidth && (t.save(), xu(t, this, i, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
            }
        }

        function Cu(t, e, i, n) {
            var s = t.options,
                {
                    [i]: i
                } = t.getProps([i], n);
            return Math.abs(e - i) < s.radius + s.hitRadius
        }
        wu.id = "line", wu.defaults = {
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            borderWidth: 3,
            capBezierPoints: !0,
            cubicInterpolationMode: "default",
            fill: !1,
            spanGaps: !1,
            stepped: !1,
            tension: 0
        }, wu.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        }, wu.descriptors = {
            _scriptable: !0,
            _indexable: t => "borderDash" !== t && "fill" !== t
        };
        class ku extends Ad {
            constructor(t) {
                super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t)
            }
            inRange(t, e, i) {
                var n = this.options,
                    {
                        x: s,
                        y: i
                    } = this.getProps(["x", "y"], i);
                return Math.pow(t - s, 2) + Math.pow(e - i, 2) < Math.pow(n.hitRadius + n.radius, 2)
            }
            inXRange(t, e) {
                return Cu(this, t, "x", e)
            }
            inYRange(t, e) {
                return Cu(this, t, "y", e)
            }
            getCenterPoint(t) {
                var {
                    x: e,
                    y: t
                } = this.getProps(["x", "y"], t);
                return {
                    x: e,
                    y: t
                }
            }
            size(t) {
                var e = (t = t || this.options || {}).radius || 0;
                return 2 * ((e = Math.max(e, e && t.hoverRadius || 0)) + (e && t.borderWidth || 0))
            }
            draw(t, e) {
                var i = this.options;
                this.skip || i.radius < .1 || !Kl(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Ul(t, i, this.x, this.y))
            }
            getRange() {
                var t = this.options || {};
                return t.radius + t.hitRadius
            }
        }

        function Tu(t, e) {
            var {
                x: i,
                y: n,
                base: s,
                width: o,
                height: e
            } = t.getProps(["x", "y", "base", "width", "height"], e);
            let a, r, l, c, h;
            return c = t.horizontal ? (h = e / 2, a = Math.min(i, s), r = Math.max(i, s), l = n - h, n + h) : (h = o / 2, a = i - h, r = i + h, l = Math.min(n, s), Math.max(n, s)), {
                left: a,
                top: l,
                right: r,
                bottom: c
            }
        }

        function Su(t, e, i, n) {
            return t ? 0 : Zr(e, i, n)
        }

        function Eu(t) {
            var e, i, n, s, o, a = Tu(t),
                r = a.right - a.left,
                l = a.bottom - a.top,
                c = (o = r / 2, n = l / 2, s = (e = t).options.borderWidth, e = e.borderSkipped, s = sc(s), {
                    t: Su(e.top, s.top, 0, n),
                    r: Su(e.right, s.right, 0, o),
                    b: Su(e.bottom, s.bottom, 0, n),
                    l: Su(e.left, s.left, 0, o)
                }),
                n = (i = r / 2, n = l / 2, s = (e = t).getProps(["enableBorderRadius"]).enableBorderRadius, o = e.options.borderRadius, t = oc(o), n = Math.min(i, n), e = e.borderSkipped, {
                    topLeft: Su(!(o = s || rr(o)) || e.top || e.left, t.topLeft, 0, n),
                    topRight: Su(!o || e.top || e.right, t.topRight, 0, n),
                    bottomLeft: Su(!o || e.bottom || e.left, t.bottomLeft, 0, n),
                    bottomRight: Su(!o || e.bottom || e.right, t.bottomRight, 0, n)
                });
            return {
                outer: {
                    x: a.left,
                    y: a.top,
                    w: r,
                    h: l,
                    radius: n
                },
                inner: {
                    x: a.left + c.l,
                    y: a.top + c.t,
                    w: r - c.l - c.r,
                    h: l - c.t - c.b,
                    radius: {
                        topLeft: Math.max(0, n.topLeft - Math.max(c.t, c.l)),
                        topRight: Math.max(0, n.topRight - Math.max(c.t, c.r)),
                        bottomLeft: Math.max(0, n.bottomLeft - Math.max(c.b, c.l)),
                        bottomRight: Math.max(0, n.bottomRight - Math.max(c.b, c.r))
                    }
                }
            }
        }

        function Au(t, e, i, n) {
            var s = null === e,
                o = null === i,
                n = t && !(s && o) && Tu(t, n);
            return n && (s || Gr(e, n.left, n.right)) && (o || Gr(i, n.top, n.bottom))
        }

        function Mu(t, e) {
            t.rect(e.x, e.y, e.w, e.h)
        }

        function Ou(t, e, i = {}) {
            var n = t.x !== i.x ? -e : 0,
                s = t.y !== i.y ? -e : 0,
                o = (t.x + t.w !== i.x + i.w ? e : 0) - n,
                e = (t.y + t.h !== i.y + i.h ? e : 0) - s;
            return {
                x: t.x + n,
                y: t.y + s,
                w: t.w + o,
                h: t.h + e,
                radius: t.radius
            }
        }
        ku.id = "point", ku.defaults = {
            borderWidth: 1,
            hitRadius: 1,
            hoverBorderWidth: 1,
            hoverRadius: 4,
            pointStyle: "circle",
            radius: 3,
            rotation: 0
        }, ku.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        };
        class Iu extends Ad {
            constructor(t) {
                super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t)
            }
            draw(t) {
                var e, {
                        inflateAmount: i,
                        options: {
                            borderColor: n,
                            backgroundColor: s
                        }
                    } = this,
                    {
                        inner: o,
                        outer: a
                    } = Eu(this);
                const r = (e = a.radius).topLeft || e.topRight || e.bottomLeft || e.bottomRight ? Jl : Mu;
                t.save(), a.w === o.w && a.h === o.h || (t.beginPath(), r(t, Ou(a, i, o)), t.clip(), r(t, Ou(o, -i, a)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), r(t, Ou(o, i)), t.fillStyle = s, t.fill(), t.restore()
            }
            inRange(t, e, i) {
                return Au(this, t, e, i)
            }
            inXRange(t, e) {
                return Au(this, t, null, e)
            }
            inYRange(t, e) {
                return Au(this, null, t, e)
            }
            getCenterPoint(t) {
                var {
                    x: e,
                    y: i,
                    base: n,
                    horizontal: t
                } = this.getProps(["x", "y", "base", "horizontal"], t);
                return {
                    x: t ? (e + n) / 2 : e,
                    y: t ? i : (i + n) / 2
                }
            }
            getRange(t) {
                return "x" === t ? this.width / 2 : this.height / 2
            }
        }
        Iu.id = "bar", Iu.defaults = {
            borderSkipped: "start",
            borderWidth: 0,
            borderRadius: 0,
            inflateAmount: "auto",
            pointStyle: void 0
        }, Iu.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        };
        pu, wu, ku, Iu;

        function Du(t) {
            var e;
            t._decimated && (e = t._data, delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
                value: e
            }))
        }

        function Lu(t) {
            t.data.datasets.forEach(t => {
                Du(t)
            })
        }
        St = {
            id: "decimation",
            defaults: {
                algorithm: "min-max",
                enabled: !1
            },
            beforeElementsUpdate: (r, t, l) => {
                if (l.enabled) {
                    const c = r.width;
                    r.data.datasets.forEach((e, t) => {
                        var {
                            _data: i,
                            indexAxis: n
                        } = e, t = r.getDatasetMeta(t), s = i || e.data;
                        if ("y" !== lc([n, r.options.indexAxis]) && "line" === t.type) {
                            n = r.scales[t.xAxisID];
                            if (("linear" === n.type || "time" === n.type) && !r.options.parsing) {
                                var {
                                    start: o,
                                    count: a
                                } = function(t, e) {
                                    var i = e.length;
                                    let n = 0,
                                        s;
                                    const o = t["iScale"];
                                    var {
                                        min: a,
                                        max: r,
                                        minDefined: l,
                                        maxDefined: t
                                    } = o.getUserBounds();
                                    return l && (n = Zr(dc(e, o.axis, a).lo, 0, i - 1)), s = t ? Zr(dc(e, o.axis, r).hi + 1, n, i) - n : i - n, {
                                        start: n,
                                        count: s
                                    }
                                }(t, s);
                                if (a <= (l.threshold || 4 * c)) Du(e);
                                else {
                                    or(i) && (e._data = s, delete e.data, Object.defineProperty(e, "data", {
                                        configurable: !0,
                                        enumerable: !0,
                                        get: function() {
                                            return this._decimated
                                        },
                                        set: function(t) {
                                            this._data = t
                                        }
                                    }));
                                    let t;
                                    switch (l.algorithm) {
                                        case "lttb":
                                            t = function(n, s, o, t, e) {
                                                var i = e.samples || t;
                                                if (o <= i) return n.slice(s, s + o);
                                                const a = [];
                                                var r = (o - 2) / (i - 2);
                                                let l = 0;
                                                t = s + o - 1;
                                                let c = s,
                                                    h, d, u, p, f;
                                                for (a[l++] = n[c], h = 0; h < i - 2; h++) {
                                                    let t = 0,
                                                        e = 0,
                                                        i;
                                                    var g = Math.floor((h + 1) * r) + 1 + s,
                                                        _ = Math.min(Math.floor((h + 2) * r) + 1, o) + s,
                                                        m = _ - g;
                                                    for (i = g; i < _; i++) t += n[i].x, e += n[i].y;
                                                    t /= m, e /= m;
                                                    var m = Math.floor(h * r) + 1 + s,
                                                        v = Math.min(Math.floor((h + 1) * r) + 1, o) + s,
                                                        {
                                                            x: b,
                                                            y
                                                        } = n[c];
                                                    for (u = -1, i = m; i < v; i++)(p = .5 * Math.abs((b - t) * (n[i].y - y) - (b - n[i].x) * (e - y))) > u && (u = p, d = n[i], f = i);
                                                    a[l++] = d, c = f
                                                }
                                                return a[l++] = n[t], a
                                            }(s, o, a, c, l);
                                            break;
                                        case "min-max":
                                            t = function(t, e, i, n) {
                                                let s = 0,
                                                    o = 0,
                                                    a, r, l, c, h, d, u, p, f, g;
                                                const _ = [];
                                                var m = t[e].x,
                                                    v = t[e + i - 1].x - m;
                                                for (a = e; a < e + i; ++a) {
                                                    l = ((r = t[a]).x - m) / v * n, c = r.y;
                                                    var b, y, x, w = 0 | l;
                                                    w === h ? (c < f ? (f = c, d = a) : c > g && (g = c, u = a), s = (o * s + r.x) / ++o) : (b = a - 1, or(d) || or(u) || (y = Math.min(d, u), x = Math.max(d, u), y !== p && y !== b && _.push({ ...t[y],
                                                        x: s
                                                    }), x !== p && x !== b && _.push({ ...t[x],
                                                        x: s
                                                    })), 0 < a && b !== p && _.push(t[b]), _.push(r), h = w, o = 0, f = g = c, d = u = p = a)
                                                }
                                                return _
                                            }(s, o, a, c);
                                            break;
                                        default:
                                            throw new Error(`Unsupported decimation algorithm '${l.algorithm}'`)
                                    }
                                    e._decimated = t
                                }
                            }
                        }
                    })
                } else Lu(r)
            },
            destroy(t) {
                Lu(t)
            }
        };

        function Pu(t, e, i) {
            t = function(t) {
                var e = t.options;
                let i = hr((t = e.fill) && t.target, t);
                return void 0 === i && (i = !!e.backgroundColor), !1 !== i && null !== i && (!0 === i ? "origin" : i)
            }(t);
            if (rr(t)) return !isNaN(t.value) && t;
            let n = parseFloat(t);
            return lr(n) && Math.floor(n) === n ? ("-" !== t[0] && "+" !== t[0] || (n = e + n), !(n === e || n < 0 || n >= i) && n) : 0 <= ["origin", "start", "end", "stack", "shape"].indexOf(t) && t
        }
        class Ru {
            constructor(t) {
                this.x = t.x, this.y = t.y, this.radius = t.radius
            }
            pathSegment(t, e, i) {
                var {
                    x: n,
                    y: s,
                    radius: o
                } = this;
                return e = e || {
                    start: 0,
                    end: Or
                }, t.arc(n, s, o, e.end, e.start, !0), !i.bounds
            }
            interpolate(t) {
                var {
                    x: e,
                    y: i,
                    radius: n
                } = this, t = t.angle;
                return {
                    x: e + Math.cos(t) * n,
                    y: i + Math.sin(t) * n,
                    angle: t
                }
            }
        }

        function Bu(t) {
            return ((t.scale || {}).getPointPositionForValue ? function(t) {
                const {
                    scale: e,
                    fill: i
                } = t;
                var n = e.options,
                    s = e.getLabels().length;
                const o = [];
                var a = n.reverse ? e.max : e.min,
                    t = n.reverse ? e.min : e.max;
                let r, l, c;
                if (c = "start" === i ? a : "end" === i ? t : rr(i) ? i.value : e.getBaseValue(), n.grid.circular) return l = e.getPointPositionForValue(0, a), new Ru({
                    x: l.x,
                    y: l.y,
                    radius: e.getDistanceFromCenterForValue(c)
                });
                for (r = 0; r < s; ++r) o.push(e.getPointPositionForValue(r, c));
                return o
            } : function(t) {
                const {
                    scale: e = {},
                    fill: i
                } = t;
                let n = null;
                return "start" === i ? n = e.bottom : "end" === i ? n = e.top : rr(i) ? n = e.getPixelForValue(i.value) : e.getBasePixel && (n = e.getBasePixel()), lr(n) ? {
                    x: (t = e.isHorizontal()) ? n : null,
                    y: t ? null : n
                } : null
            })(t)
        }

        function Nu(t, e, i) {
            for (; t < e; e--) {
                var n = i[e];
                if (!isNaN(n.x) && !isNaN(n.y)) break
            }
            return e
        }

        function Hu(t) {
            var {
                scale: e,
                index: i,
                line: t
            } = t, n = [], s = t.segments, o = t.points;
            const a = function(t, e) {
                const i = [],
                    n = t.getMatchingVisibleMetas("line");
                for (let t = 0; t < n.length; t++) {
                    var s = n[t];
                    if (s.index === e) break;
                    s.hidden || i.unshift(s.dataset)
                }
                return i
            }(e, i);
            a.push(ju({
                x: null,
                y: e.bottom
            }, t));
            for (let t = 0; t < s.length; t++) {
                var r = s[t];
                for (let t = r.start; t <= r.end; t++) ! function(e, i, n) {
                    const s = [];
                    for (let t = 0; t < n.length; t++) {
                        var {
                            first: o,
                            last: a,
                            point: r
                        } = function(t, e, i) {
                            e = t.interpolate(e, i);
                            if (!e) return {};
                            var n = e[i],
                                s = t.segments,
                                o = t.points;
                            let a = !1,
                                r = !1;
                            for (let t = 0; t < s.length; t++) {
                                var l = s[t],
                                    c = o[l.start][i],
                                    l = o[l.end][i];
                                if (Gr(n, c, l)) {
                                    a = n === c, r = n === l;
                                    break
                                }
                            }
                            return {
                                first: a,
                                last: r,
                                point: e
                            }
                        }(n[t], i, "x");
                        if (!(!r || o && a))
                            if (o) s.unshift(r);
                            else if (e.push(r), !a) break
                    }
                    e.push(...s)
                }(n, o[t], a)
            }
            return new wu({
                points: n,
                options: {}
            })
        }

        function ju(t, e) {
            let i = [],
                n = !1;
            return i = ar(t) ? (n = !0, t) : function(t, e) {
                const {
                    x: i = null,
                    y: n = null
                } = t || {}, s = e.points, o = [];
                return e.segments.forEach(({
                    start: t,
                    end: e
                }) => {
                    e = Nu(t, e, s);
                    t = s[t], e = s[e];
                    null !== n ? (o.push({
                        x: t.x,
                        y: n
                    }), o.push({
                        x: e.x,
                        y: n
                    })) : null !== i && (o.push({
                        x: i,
                        y: t.y
                    }), o.push({
                        x: i,
                        y: e.y
                    }))
                }), o
            }(t, e), i.length ? new wu({
                points: i,
                options: {
                    tension: 0
                },
                _loop: n,
                _fullLoop: n
            }) : null
        }

        function Wu(t, e, i) {
            var {
                segments: n,
                points: s
            } = e;
            let o = !0,
                a = !1;
            t.beginPath();
            for (const h of n) {
                var {
                    start: r,
                    end: l
                } = h, c = s[r], l = s[Nu(r, l, s)];
                o ? (t.moveTo(c.x, c.y), o = !1) : (t.lineTo(c.x, i), t.lineTo(c.x, c.y)), a = !!e.pathSegment(t, h, {
                    move: a
                }), a ? t.closePath() : t.lineTo(l.x, i)
            }
            t.lineTo(e.first().x, i), t.closePath(), t.clip()
        }

        function Fu(i, n, s, t) {
            if (!t) {
                let t = n[i],
                    e = s[i];
                return "angle" === i && (t = Qr(t), e = Qr(e)), {
                    property: i,
                    start: t,
                    end: e
                }
            }
        }

        function Vu(t, e, i, n) {
            return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
        }

        function zu(t, e, i, n) {
            n = e.interpolate(i, n);
            n && t.lineTo(n.x, n.y)
        }

        function Yu(e, t) {
            const {
                line: i,
                target: n,
                property: s,
                color: o,
                scale: a
            } = t;
            var r, l, c, h;
            for ({
                    source: r,
                    target: l,
                    start: c,
                    end: h
                } of function(t, e, i) {
                    var n = t.segments,
                        s = t.points,
                        o = e.points;
                    const a = [];
                    for (const d of n) {
                        var {
                            start: r,
                            end: l
                        } = d, l = Nu(r, l, s), c = Fu(i, s[r], s[l], d.loop);
                        if (e.segments)
                            for (const u of nh(e, c)) {
                                var h = Fu(i, o[u.start], o[u.end], u.loop);
                                for (const p of ih(d, s, h)) a.push({
                                    source: p,
                                    target: u,
                                    start: {
                                        [i]: Vu(c, h, "start", Math.max)
                                    },
                                    end: {
                                        [i]: Vu(c, h, "end", Math.min)
                                    }
                                })
                            } else a.push({
                                source: d,
                                target: c,
                                start: s[r],
                                end: s[l]
                            })
                    }
                    return a
                }(i, n, s)) {
                var {
                    style: {
                        backgroundColor: d = o
                    } = {}
                } = r, u = !0 !== n;
                e.save(), e.fillStyle = d,
                    function(t, e, i) {
                        var {
                            top: n,
                            bottom: s
                        } = e.chart.chartArea, {
                            property: o,
                            start: e,
                            end: i
                        } = i || {};
                        "x" === o && (t.beginPath(), t.rect(e, n, i - e, s - n), t.clip())
                    }(e, a, u && Fu(s, c, h)), e.beginPath();
                d = !!i.pathSegment(e, r);
                let t;
                u && (d ? e.closePath() : zu(e, n, h, s), u = !!n.pathSegment(e, l, {
                    move: d,
                    reverse: !0
                }), t = d && u, t || zu(e, n, c, s)), e.closePath(), e.fill(t ? "evenodd" : "nonzero"), e.restore()
            }
        }

        function Xu(t, e, i) {
            var n = function(t) {
                    var e, i, {
                        chart: n,
                        fill: s,
                        line: o
                    } = t;
                    return lr(s) ? (i = s, (n = (e = n).getDatasetMeta(i)) && e.isDatasetVisible(i) ? n.dataset : null) : "stack" === s ? Hu(t) : "shape" === s || ((t = Bu(t)) instanceof Ru ? t : ju(t, o))
                }(e),
                {
                    line: s,
                    scale: o,
                    axis: a
                } = e,
                r = s.options,
                e = r.fill,
                r = r.backgroundColor,
                {
                    above: e = r,
                    below: r = r
                } = e || {};
            n && s.points.length && ($l(t, i), function(t, e) {
                var {
                    line: i,
                    target: n,
                    above: s,
                    below: o,
                    area: a,
                    scale: r
                } = e, e = i._loop ? "angle" : e.axis;
                t.save(), "x" === e && o !== s && (Wu(t, n, a.top), Yu(t, {
                    line: i,
                    target: n,
                    color: s,
                    scale: r,
                    property: e
                }), t.restore(), t.save(), Wu(t, n, a.bottom)), Yu(t, {
                    line: i,
                    target: n,
                    color: o,
                    scale: r,
                    property: e
                }), t.restore()
            }(t, {
                line: s,
                target: n,
                above: e,
                below: r,
                area: i,
                scale: o,
                axis: a
            }), Ql(t))
        }
        $t = {
            id: "filler",
            afterDatasetsUpdate(t, e, i) {
                var n = (t.data.datasets || []).length;
                const s = [];
                let o, a, r, l;
                for (a = 0; a < n; ++a) o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof wu && (l = {
                    visible: t.isDatasetVisible(a),
                    index: a,
                    fill: Pu(r, a, n),
                    chart: t,
                    axis: o.controller.options.indexAxis,
                    scale: o.vScale,
                    line: r
                }), o.$filler = l, s.push(l);
                for (a = 0; a < n; ++a) l = s[a], l && !1 !== l.fill && (l.fill = function(t, e, i) {
                    var n;
                    let s = t[e].fill;
                    const o = [e];
                    if (!i) return s;
                    for (; !1 !== s && -1 === o.indexOf(s);) {
                        if (!lr(s)) return s;
                        if (!(n = t[s])) return !1;
                        if (n.visible) return s;
                        o.push(s), s = n.fill
                    }
                    return !1
                }(s, a, i.propagate))
            },
            beforeDraw(e, t, i) {
                var n = "beforeDraw" === i.drawTime,
                    s = e.getSortedVisibleDatasetMetas(),
                    o = e.chartArea;
                for (let t = s.length - 1; 0 <= t; --t) {
                    const a = s[t].$filler;
                    a && (a.line.updateControlPoints(o, a.axis), n && Xu(e.ctx, a, o))
                }
            },
            beforeDatasetsDraw(e, t, i) {
                if ("beforeDatasetsDraw" === i.drawTime) {
                    var n = e.getSortedVisibleDatasetMetas();
                    for (let t = n.length - 1; 0 <= t; --t) {
                        var s = n[t].$filler;
                        s && Xu(e.ctx, s, e.chartArea)
                    }
                }
            },
            beforeDatasetDraw(t, e, i) {
                e = e.meta.$filler;
                e && !1 !== e.fill && "beforeDatasetDraw" === i.drawTime && Xu(t.ctx, e, t.chartArea)
            },
            defaults: {
                propagate: !0,
                drawTime: "beforeDatasetDraw"
            }
        };
        const Uu = (t, e) => {
            let {
                boxHeight: i = e,
                boxWidth: n = e
            } = t;
            return t.usePointStyle && (i = Math.min(i, e), n = Math.min(n, e)), {
                boxWidth: n,
                boxHeight: i,
                itemHeight: Math.max(e, i)
            }
        };
        class Ku extends Ad {
            constructor(t) {
                super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
            }
            update(t, e, i) {
                this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()
            }
            setDimensions() {
                this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
            }
            buildLabels() {
                const i = this.options.labels || {};
                let t = ur(i.generateLabels, [this.chart], this) || [];
                i.filter && (t = t.filter(t => i.filter(t, this.chart.data))), i.sort && (t = t.sort((t, e) => i.sort(t, e, this.chart.data))), this.options.reverse && t.reverse(), this.legendItems = t
            }
            fit() {
                const {
                    options: i,
                    ctx: n
                } = this;
                if (i.display) {
                    var s = i.labels,
                        o = rc(s.font),
                        a = o.size,
                        r = this._computeTitleHeight(),
                        {
                            boxWidth: l,
                            itemHeight: s
                        } = Uu(s, a);
                    let t, e;
                    n.font = o.string, this.isHorizontal() ? (t = this.maxWidth, e = this._fitRows(r, a, l, s) + 10) : (e = this.maxHeight, t = this._fitCols(r, a, l, s) + 10), this.width = Math.min(t, i.maxWidth || this.maxWidth), this.height = Math.min(e, i.maxHeight || this.maxHeight)
                } else this.width = this.height = 0
            }
            _fitRows(t, i, n, s) {
                const {
                    ctx: o,
                    maxWidth: a,
                    options: {
                        labels: {
                            padding: r
                        }
                    }
                } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], h = s + r;
                let d = t;
                o.textAlign = "left", o.textBaseline = "middle";
                let u = -1,
                    p = -h;
                return this.legendItems.forEach((t, e) => {
                    t = n + i / 2 + o.measureText(t.text).width;
                    (0 === e || c[c.length - 1] + t + 2 * r > a) && (d += h, c[c.length - (0 < e ? 0 : 1)] = 0, p += h, u++), l[e] = {
                        left: 0,
                        top: p,
                        row: u,
                        width: t,
                        height: s
                    }, c[c.length - 1] += t + r
                }), d
            }
            _fitCols(t, i, n, s) {
                const {
                    ctx: o,
                    maxHeight: e,
                    options: {
                        labels: {
                            padding: a
                        }
                    }
                } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], c = e - t;
                let h = a,
                    d = 0,
                    u = 0,
                    p = 0,
                    f = 0;
                return this.legendItems.forEach((t, e) => {
                    t = n + i / 2 + o.measureText(t.text).width;
                    0 < e && u + s + 2 * a > c && (h += d + a, l.push({
                        width: d,
                        height: u
                    }), p += d + a, f++, d = u = 0), r[e] = {
                        left: p,
                        top: u,
                        col: f,
                        width: t,
                        height: s
                    }, d = Math.max(d, t), u += s + a
                }), h += d, l.push({
                    width: d,
                    height: u
                }), h
            }
            adjustHitBoxes() {
                if (this.options.display) {
                    var i = this._computeTitleHeight(),
                        {
                            legendHitBoxes: n,
                            options: {
                                align: s,
                                labels: {
                                    padding: o
                                },
                                rtl: t
                            }
                        } = this;
                    const a = Zc(t, this.left, this.width);
                    if (this.isHorizontal()) {
                        let t = 0,
                            e = ir(s, this.left + o, this.right - this.lineWidths[t]);
                        for (const r of n) t !== r.row && (t = r.row, e = ir(s, this.left + o, this.right - this.lineWidths[t])), r.top += this.top + i + o, r.left = a.leftForLtr(a.x(e), r.width), e += r.width + o
                    } else {
                        let t = 0,
                            e = ir(s, this.top + i + o, this.bottom - this.columnSizes[t].height);
                        for (const l of n) l.col !== t && (t = l.col, e = ir(s, this.top + i + o, this.bottom - this.columnSizes[t].height)), l.top = e, l.left += this.left + o, l.left = a.leftForLtr(a.x(l.left), l.width), e += l.height + o
                    }
                }
            }
            isHorizontal() {
                return "top" === this.options.position || "bottom" === this.options.position
            }
            draw() {
                var t;
                this.options.display && ($l(t = this.ctx, this), this._draw(), Ql(t))
            }
            _draw() {
                const {
                    options: u,
                    columnSizes: p,
                    lineWidths: f,
                    ctx: g
                } = this, {
                    align: _,
                    labels: m
                } = u, v = Vl.color, b = Zc(u.rtl, this.left, this.width), y = rc(m.font), {
                    color: x,
                    padding: w
                } = m, C = y.size, k = C / 2;
                let T;
                this.drawTitle(), g.textAlign = b.textAlign("left"), g.textBaseline = "middle", g.lineWidth = .5, g.font = y.string;
                const {
                    boxWidth: S,
                    boxHeight: E,
                    itemHeight: A
                } = Uu(m, C), M = this.isHorizontal(), O = this._computeTitleHeight();
                T = M ? {
                    x: ir(_, this.left + w, this.right - f[0]),
                    y: this.top + w + O,
                    line: 0
                } : {
                    x: this.left + w,
                    y: ir(_, this.top + O + w, this.bottom - p[0].height),
                    line: 0
                }, Gc(this.ctx, u.textDirection);
                const I = A + w;
                this.legendItems.forEach((t, e) => {
                    g.strokeStyle = t.fontColor || x, g.fillStyle = t.fontColor || x;
                    var i = g.measureText(t.text).width,
                        n = b.textAlign(t.textAlign || (t.textAlign = m.textAlign)),
                        s = S + k + i;
                    let o = T.x,
                        a = T.y;
                    b.setWidth(this.width), M ? 0 < e && o + s + w > this.right && (a = T.y += I, T.line++, o = T.x = ir(_, this.left + w, this.right - f[T.line])) : 0 < e && a + I > this.bottom && (o = T.x = o + p[T.line].width + w, T.line++, a = T.y = ir(_, this.top + O + w, this.bottom - p[T.line].height));
                    var r, l, c, h, d = b.x(o);
                    l = d, h = a, r = t, isNaN(S) || S <= 0 || isNaN(E) || E < 0 || (g.save(), c = hr(r.lineWidth, 1), g.fillStyle = hr(r.fillStyle, v), g.lineCap = hr(r.lineCap, "butt"), g.lineDashOffset = hr(r.lineDashOffset, 0), g.lineJoin = hr(r.lineJoin, "miter"), g.lineWidth = c, g.strokeStyle = hr(r.strokeStyle, v), g.setLineDash(hr(r.lineDash, [])), m.usePointStyle ? (i = {
                        radius: S * Math.SQRT2 / 2,
                        pointStyle: r.pointStyle,
                        rotation: r.rotation,
                        borderWidth: c
                    }, e = b.xPlus(l, S / 2), d = h + k, Ul(g, i, e, d)) : (h = h + Math.max((C - E) / 2, 0), l = b.leftForLtr(l, S), r = oc(r.borderRadius), g.beginPath(), Object.values(r).some(t => 0 !== t) ? Jl(g, {
                        x: l,
                        y: h,
                        w: S,
                        h: E,
                        radius: r
                    }) : g.rect(l, h, S, E), g.fill(), 0 !== c && g.stroke()), g.restore()), o = (l = n, h = o + S + k, c = M ? o + s : this.right, n = u.rtl, l === (n ? "left" : "right") ? c : "center" === l ? (h + c) / 2 : h), c = b.x(o), h = a, t = t, Gl(g, t.text, c, h + A / 2, y, {
                        strikethrough: t.hidden,
                        textAlign: b.textAlign(t.textAlign)
                    }), M ? T.x += s + w : T.y += I
                }), Jc(this.ctx, u.textDirection)
            }
            drawTitle() {
                var n = this.options,
                    s = n.title,
                    o = rc(s.font),
                    a = ac(s.padding);
                if (s.display) {
                    const c = Zc(n.rtl, this.left, this.width),
                        h = this.ctx;
                    var r = s.position,
                        l = o.size / 2,
                        a = a.top + l;
                    let t, e = this.left,
                        i = this.width;
                    this.isHorizontal() ? (i = Math.max(...this.lineWidths), t = this.top + a, e = ir(n.align, e, this.right - i)) : (l = this.columnSizes.reduce((t, e) => Math.max(t, e.height), 0), t = a + ir(n.align, this.top, this.bottom - l - n.labels.padding - this._computeTitleHeight()));
                    n = ir(r, e, e + i);
                    h.textAlign = c.textAlign(er(r)), h.textBaseline = "middle", h.strokeStyle = s.color, h.fillStyle = s.color, h.font = o.string, Gl(h, s.text, n, t, o)
                }
            }
            _computeTitleHeight() {
                var t = this.options.title,
                    e = rc(t.font),
                    i = ac(t.padding);
                return t.display ? e.lineHeight + i.height : 0
            }
            _getLegendItemAt(t, e) {
                let i, n, s;
                if (Gr(t, this.left, this.right) && Gr(e, this.top, this.bottom))
                    for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)
                        if (Gr(t, (n = s[i]).left, n.left + n.width) && Gr(e, n.top, n.top + n.height)) return this.legendItems[i];
                return null
            }
            handleEvent(t) {
                var e, i, n, s, o = this.options;
                n = t.type, s = o, ("mousemove" === n && (s.onHover || s.onLeave) || s.onClick && ("click" === n || "mouseup" === n)) && (e = this._getLegendItemAt(t.x, t.y), "mousemove" === t.type ? (i = this._hoveredItem, s = e, s = null !== (n = i) && null !== s && n.datasetIndex === s.datasetIndex && n.index === s.index, i && !s && ur(o.onLeave, [t, i, this], this), (this._hoveredItem = e) && !s && ur(o.onHover, [t, e, this], this)) : e && ur(o.onClick, [t, e, this], this))
            }
        }
        Ae = {
            id: "legend",
            _element: Ku,
            start(t, e, i) {
                var n = t.legend = new Ku({
                    ctx: t.ctx,
                    options: i,
                    chart: t
                });
                cd(t, n, i), rd(t, n)
            },
            stop(t) {
                ld(t, t.legend), delete t.legend
            },
            beforeUpdate(t, e, i) {
                const n = t.legend;
                cd(t, n, i), n.options = i
            },
            afterUpdate(t) {
                const e = t.legend;
                e.buildLabels(), e.adjustHitBoxes()
            },
            afterEvent(t, e) {
                e.replay || t.legend.handleEvent(e.event)
            },
            defaults: {
                display: !0,
                position: "top",
                align: "center",
                fullSize: !0,
                reverse: !1,
                weight: 1e3,
                onClick(t, e, i) {
                    var n = e.datasetIndex;
                    const s = i.chart;
                    s.isDatasetVisible(n) ? (s.hide(n), e.hidden = !0) : (s.show(n), e.hidden = !1)
                },
                onHover: null,
                onLeave: null,
                labels: {
                    color: t => t.chart.options.color,
                    boxWidth: 40,
                    padding: 10,
                    generateLabels(t) {
                        const n = t.data.datasets,
                            {
                                labels: {
                                    usePointStyle: s,
                                    pointStyle: o,
                                    textAlign: a,
                                    color: r
                                }
                            } = t.legend.options;
                        return t._getSortedDatasetMetas().map(t => {
                            var e = t.controller.getStyle(s ? 0 : void 0),
                                i = ac(e.borderWidth);
                            return {
                                text: n[t.index].label,
                                fillStyle: e.backgroundColor,
                                fontColor: r,
                                hidden: !t.visible,
                                lineCap: e.borderCapStyle,
                                lineDash: e.borderDash,
                                lineDashOffset: e.borderDashOffset,
                                lineJoin: e.borderJoinStyle,
                                lineWidth: (i.width + i.height) / 4,
                                strokeStyle: e.borderColor,
                                pointStyle: o || e.pointStyle,
                                rotation: e.rotation,
                                textAlign: a || e.textAlign,
                                borderRadius: 0,
                                datasetIndex: t.index
                            }
                        }, this)
                    }
                },
                title: {
                    color: t => t.chart.options.color,
                    display: !1,
                    position: "center",
                    text: ""
                }
            },
            descriptors: {
                _scriptable: t => !t.startsWith("on"),
                labels: {
                    _scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
                }
            }
        };
        class $u extends Ad {
            constructor(t) {
                super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
            }
            update(t, e) {
                var i = this.options;
                this.left = 0, this.top = 0, i.display ? (this.width = this.right = t, this.height = this.bottom = e, e = ar(i.text) ? i.text.length : 1, this._padding = ac(i.padding), i = e * rc(i.font).lineHeight + this._padding.height, this.isHorizontal() ? this.height = i : this.width = i) : this.width = this.height = this.right = this.bottom = 0
            }
            isHorizontal() {
                var t = this.options.position;
                return "top" === t || "bottom" === t
            }
            _drawArgs(t) {
                var {
                    top: e,
                    left: i,
                    bottom: n,
                    right: s,
                    options: o
                } = this, a = o.align;
                let r = 0,
                    l, c, h;
                return l = this.isHorizontal() ? (c = ir(a, i, s), h = e + t, s - i) : (r = "left" === o.position ? (c = i + t, h = ir(a, n, e), -.5 * Mr) : (c = s - t, h = ir(a, e, n), .5 * Mr), n - e), {
                    titleX: c,
                    titleY: h,
                    maxWidth: l,
                    rotation: r
                }
            }
            draw() {
                var t, e, i, n, s, o = this.ctx,
                    a = this.options;
                a.display && (s = (t = rc(a.font)).lineHeight / 2 + this._padding.top, {
                    titleX: e,
                    titleY: i,
                    maxWidth: n,
                    rotation: s
                } = this._drawArgs(s), Gl(o, a.text, 0, 0, t, {
                    color: a.color,
                    maxWidth: n,
                    rotation: s,
                    textAlign: er(a.align),
                    textBaseline: "middle",
                    translation: [e, i]
                }))
            }
        }
        e = {
            id: "title",
            _element: $u,
            start(t, e, i) {
                var n;
                n = t, t = i, i = new $u({
                    ctx: n.ctx,
                    options: t,
                    chart: n
                }), cd(n, i, t), rd(n, i), n.titleBlock = i
            },
            stop(t) {
                var e = t.titleBlock;
                ld(t, e), delete t.titleBlock
            },
            beforeUpdate(t, e, i) {
                const n = t.titleBlock;
                cd(t, n, i), n.options = i
            },
            defaults: {
                align: "center",
                display: !1,
                font: {
                    weight: "bold"
                },
                fullSize: !0,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: !0,
                _indexable: !1
            }
        };
        const Qu = new WeakMap;
        Ot = {
            id: "subtitle",
            start(t, e, i) {
                var n = new $u({
                    ctx: t.ctx,
                    options: i,
                    chart: t
                });
                cd(t, n, i), rd(t, n), Qu.set(t, n)
            },
            stop(t) {
                ld(t, Qu.get(t)), Qu.delete(t)
            },
            beforeUpdate(t, e, i) {
                const n = Qu.get(t);
                cd(t, n, i), n.options = i
            },
            defaults: {
                align: "center",
                display: !1,
                font: {
                    weight: "normal"
                },
                fullSize: !0,
                padding: 0,
                position: "top",
                text: "",
                weight: 1500
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: !0,
                _indexable: !1
            }
        };
        const qu = {
            average(t) {
                if (!t.length) return !1;
                let e, i, n = 0,
                    s = 0,
                    o = 0;
                for (e = 0, i = t.length; e < i; ++e) {
                    const r = t[e].element;
                    var a;
                    r && r.hasValue() && (a = r.tooltipPosition(), n += a.x, s += a.y, ++o)
                }
                return {
                    x: n / o,
                    y: s / o
                }
            },
            nearest(t, e) {
                if (!t.length) return !1;
                let i = e.x,
                    n = e.y,
                    s = Number.POSITIVE_INFINITY,
                    o, a, r;
                for (o = 0, a = t.length; o < a; ++o) {
                    const h = t[o].element;
                    var l;
                    h && h.hasValue() && ((l = Kr(e, h.getCenterPoint())) < s && (s = l, r = h))
                }
                var c;
                return r && (c = r.tooltipPosition(), i = c.x, n = c.y), {
                    x: i,
                    y: n
                }
            }
        };

        function Zu(t, e) {
            return e && (ar(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
        }

        function Gu(t) {
            return ("string" == typeof t || t instanceof String) && -1 < t.indexOf("\n") ? t.split("\n") : t
        }

        function Ju(t, e) {
            const i = t.chart.ctx,
                {
                    body: n,
                    footer: s,
                    title: o
                } = t;
            var {
                boxWidth: a,
                boxHeight: r
            } = e, l = rc(e.bodyFont), c = rc(e.titleFont), h = rc(e.footerFont), d = o.length, u = s.length, p = n.length, f = ac(e.padding);
            let g = f.height,
                _ = 0;
            var m = n.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0);
            m += t.beforeBody.length + t.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), m && (r = e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight, g += p * r + (m - p) * l.lineHeight + (m - 1) * e.bodySpacing), u && (g += e.footerMarginTop + u * h.lineHeight + (u - 1) * e.footerSpacing);
            let v = 0;

            function b(t) {
                _ = Math.max(_, i.measureText(t).width + v)
            }
            return i.save(), i.font = c.string, pr(t.title, b), i.font = l.string, pr(t.beforeBody.concat(t.afterBody), b), v = e.displayColors ? a + 2 + e.boxPadding : 0, pr(n, t => {
                pr(t.before, b), pr(t.lines, b), pr(t.after, b)
            }), v = 0, i.font = h.string, pr(t.footer, b), i.restore(), _ += f.width, {
                width: _,
                height: g
            }
        }

        function tp(t, e, i, n) {
            var {
                x: s,
                width: o
            } = i, {
                width: a,
                chartArea: {
                    left: r,
                    right: l
                }
            } = t;
            let c = "center";
            return "center" === n ? c = s <= (r + l) / 2 ? "left" : "right" : s <= o / 2 ? c = "left" : a - o / 2 <= s && (c = "right"),
                function(t, e, i, n) {
                    var {
                        x: s,
                        width: n
                    } = n, i = i.caretSize + i.caretPadding;
                    return "left" === t && s + n + i > e.width || "right" === t && s - n - i < 0
                }(c, t, e, i) && (c = "center"), c
        }

        function ep(t, e, i) {
            var n = i.yAlign || e.yAlign || function(t, e) {
                var {
                    y: i,
                    height: e
                } = e;
                return i < e / 2 ? "top" : i > t.height - e / 2 ? "bottom" : "center"
            }(t, i);
            return {
                xAlign: i.xAlign || e.xAlign || tp(t, e, i, n),
                yAlign: n
            }
        }

        function ip(t, e, i, n) {
            var {
                caretSize: s,
                caretPadding: o,
                cornerRadius: a
            } = t, {
                xAlign: r,
                yAlign: l
            } = i, c = s + o, {
                topLeft: h,
                topRight: t,
                bottomLeft: i,
                bottomRight: o
            } = oc(a);
            let d = function(t, e) {
                let {
                    x: i,
                    width: n
                } = t;
                return "right" === e ? i -= n : "center" === e && (i -= n / 2), i
            }(e, r);
            a = function(t, e, i) {
                let {
                    y: n,
                    height: s
                } = t;
                return "top" === e ? n += i : n -= "bottom" === e ? s + i : s / 2, n
            }(e, l, c);
            return "center" === l ? "left" === r ? d += c : "right" === r && (d -= c) : "left" === r ? d -= Math.max(h, i) + s : "right" === r && (d += Math.max(t, o) + s), {
                x: Zr(d, 0, n.width - e.width),
                y: Zr(a, 0, n.height - e.height)
            }
        }

        function np(t, e, i) {
            i = ac(i.padding);
            return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - i.right : t.x + i.left
        }

        function sp(t) {
            return Zu([], Gu(t))
        }

        function op(t, e) {
            e = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
            return e ? t.override(e) : t
        }
        class ap extends Ad {
            constructor(t) {
                super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
            }
            initialize(t) {
                this.options = t, this._cachedAnimations = void 0, this.$context = void 0
            }
            _resolveAnimations() {
                var t = this._cachedAnimations;
                if (t) return t;
                var e = this.chart,
                    t = this.options.setContext(this.getContext()),
                    e = t.enabled && e.options.animation && t.animations,
                    t = new uh(this.chart, e);
                return e._cacheable && (this._cachedAnimations = Object.freeze(t)), t
            }
            getContext() {
                return this.$context || (this.$context = (t = this.chart.getContext(), i = (e = this)._tooltipItems, cc(t, {
                    tooltip: e,
                    tooltipItems: i,
                    type: "tooltip"
                })));
                var t, e, i
            }
            getTitle(t, e) {
                const i = e["callbacks"];
                var n = i.beforeTitle.apply(this, [t]),
                    s = i.title.apply(this, [t]),
                    e = i.afterTitle.apply(this, [t]),
                    t = Zu(t = [], Gu(n));
                return t = Zu(t, Gu(s)), t = Zu(t, Gu(e))
            }
            getBeforeBody(t, e) {
                return sp(e.callbacks.beforeBody.apply(this, [t]))
            }
            getBody(t, e) {
                const n = e["callbacks"],
                    s = [];
                return pr(t, t => {
                    var e = {
                        before: [],
                        lines: [],
                        after: []
                    };
                    const i = op(n, t);
                    Zu(e.before, Gu(i.beforeLabel.call(this, t))), Zu(e.lines, i.label.call(this, t)), Zu(e.after, Gu(i.afterLabel.call(this, t))), s.push(e)
                }), s
            }
            getAfterBody(t, e) {
                return sp(e.callbacks.afterBody.apply(this, [t]))
            }
            getFooter(t, e) {
                const i = e["callbacks"];
                var n = i.beforeFooter.apply(this, [t]),
                    s = i.footer.apply(this, [t]),
                    e = i.afterFooter.apply(this, [t]),
                    t = Zu(t = [], Gu(n));
                return t = Zu(t, Gu(s)), t = Zu(t, Gu(e))
            }
            _createItems(n) {
                var t = this._active;
                const s = this.chart.data,
                    i = [],
                    o = [],
                    a = [];
                let e = [],
                    r, l;
                for (r = 0, l = t.length; r < l; ++r) e.push(function(t, e) {
                    var {
                        element: i,
                        datasetIndex: n,
                        index: s
                    } = e;
                    const o = t.getDatasetMeta(n).controller;
                    var {
                        label: a,
                        value: e
                    } = o.getLabelAndValue(s);
                    return {
                        chart: t,
                        label: a,
                        parsed: o.getParsed(s),
                        raw: t.data.datasets[n].data[s],
                        formattedValue: e,
                        dataset: o.getDataset(),
                        dataIndex: s,
                        datasetIndex: n,
                        element: i
                    }
                }(this.chart, t[r]));
                return n.filter && (e = e.filter((t, e, i) => n.filter(t, e, i, s))), n.itemSort && (e = e.sort((t, e) => n.itemSort(t, e, s))), pr(e, t => {
                    const e = op(n.callbacks, t);
                    i.push(e.labelColor.call(this, t)), o.push(e.labelPointStyle.call(this, t)), a.push(e.labelTextColor.call(this, t))
                }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = e, e
            }
            update(t, e) {
                const i = this.options.setContext(this.getContext());
                var n, s, o, a = this._active;
                let r, l = [];
                a.length ? (n = qu[i.position].call(this, a, this._eventPosition), l = this._createItems(i), this.title = this.getTitle(l, i), this.beforeBody = this.getBeforeBody(l, i), this.body = this.getBody(l, i), this.afterBody = this.getAfterBody(l, i), this.footer = this.getFooter(l, i), s = this._size = Ju(this, i), o = Object.assign({}, n, s), a = ep(this.chart, i, o), o = ip(i, o, a, this.chart), this.xAlign = a.xAlign, this.yAlign = a.yAlign, r = {
                    opacity: 1,
                    x: o.x,
                    y: o.y,
                    width: s.width,
                    height: s.height,
                    caretX: n.x,
                    caretY: n.y
                }) : 0 !== this.opacity && (r = {
                    opacity: 0
                }), this._tooltipItems = l, this.$context = void 0, r && this._resolveAnimations().update(this, r), t && i.external && i.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay: e
                })
            }
            drawCaret(t, e, i, n) {
                n = this.getCaretPosition(t, i, n);
                e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3)
            }
            getCaretPosition(t, e, i) {
                var {
                    xAlign: n,
                    yAlign: s
                } = this, {
                    caretSize: o,
                    cornerRadius: a
                } = i, {
                    topLeft: r,
                    topRight: l,
                    bottomLeft: c,
                    bottomRight: h
                } = oc(a), {
                    x: i,
                    y: a
                } = t, {
                    width: t,
                    height: e
                } = e;
                let d, u, p, f, g, _;
                return "center" === s ? (g = a + e / 2, _ = "left" === n ? (d = i, u = d - o, f = g + o, g - o) : (d = i + t, u = d + o, f = g - o, g + o), p = d) : (u = "left" === n ? i + Math.max(r, c) + o : "right" === n ? i + t - Math.max(l, h) - o : this.caretX, p = "top" === s ? (f = a, g = f - o, d = u - o, u + o) : (f = a + e, g = f + o, d = u + o, u - o), _ = f), {
                    x1: d,
                    x2: u,
                    x3: p,
                    y1: f,
                    y2: g,
                    y3: _
                }
            }
            drawTitle(t, e, i) {
                var n = this.title,
                    s = n.length;
                let o, a, r;
                if (s) {
                    const l = Zc(i.rtl, this.x, this.width);
                    for (t.x = np(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "middle", o = rc(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < s; ++r) e.fillText(n[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === s && (t.y += i.titleMarginBottom - a)
                }
            }
            _drawColorBox(t, e, i, n, s) {
                var o, a = this.labelColors[i],
                    r = this.labelPointStyles[i],
                    {
                        boxHeight: l,
                        boxWidth: c,
                        boxPadding: h
                    } = s,
                    d = rc(s.bodyFont),
                    u = np(this, "left", s),
                    u = n.x(u),
                    d = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0,
                    e = e.y + d;
                s.usePointStyle ? (d = {
                    radius: Math.min(c, l) / 2,
                    pointStyle: r.pointStyle,
                    rotation: r.rotation,
                    borderWidth: 1
                }, r = n.leftForLtr(u, c) + c / 2, o = e + l / 2, t.strokeStyle = s.multiKeyBackground, t.fillStyle = s.multiKeyBackground, Ul(t, d, r, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Ul(t, d, r, o)) : (t.lineWidth = a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0, o = n.leftForLtr(u, c - h), u = n.leftForLtr(n.xPlus(u, 1), c - h - 2), h = oc(a.borderRadius), Object.values(h).some(t => 0 !== t) ? (t.beginPath(), t.fillStyle = s.multiKeyBackground, Jl(t, {
                    x: o,
                    y: e,
                    w: c,
                    h: l,
                    radius: h
                }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), Jl(t, {
                    x: u,
                    y: e + 1,
                    w: c - 2,
                    h: l - 2,
                    radius: h
                }), t.fill()) : (t.fillStyle = s.multiKeyBackground, t.fillRect(o, e, c, l), t.strokeRect(o, e, c, l), t.fillStyle = a.backgroundColor, t.fillRect(u, e + 1, c - 2, l - 2))), t.fillStyle = this.labelTextColors[i]
            }
            drawBody(e, i, t) {
                var n = this["body"];
                const {
                    bodySpacing: s,
                    bodyAlign: o,
                    displayColors: a,
                    boxHeight: r,
                    boxWidth: l,
                    boxPadding: c
                } = t;
                var h = rc(t.bodyFont);
                let d = h.lineHeight,
                    u = 0;
                const p = Zc(t.rtl, this.x, this.width);

                function f(t) {
                    i.fillText(t, p.x(e.x + u), e.y + d / 2), e.y += d + s
                }
                var g = p.textAlign(o);
                let _, m, v, b, y, x, w;
                for (i.textAlign = o, i.textBaseline = "middle", i.font = h.string, e.x = np(this, g, t), i.fillStyle = t.bodyColor, pr(this.beforeBody, f), u = a && "right" !== g ? "center" === o ? l / 2 + c : l + 2 + c : 0, b = 0, x = n.length; b < x; ++b) {
                    for (_ = n[b], m = this.labelTextColors[b], i.fillStyle = m, pr(_.before, f), v = _.lines, a && v.length && (this._drawColorBox(i, e, b, p, t), d = Math.max(h.lineHeight, r)), y = 0, w = v.length; y < w; ++y) f(v[y]), d = h.lineHeight;
                    pr(_.after, f)
                }
                u = 0, d = h.lineHeight, pr(this.afterBody, f), e.y -= s
            }
            drawFooter(t, e, i) {
                var n = this.footer,
                    s = n.length;
                let o, a;
                if (s) {
                    const r = Zc(i.rtl, this.x, this.width);
                    for (t.x = np(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = "middle", o = rc(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < s; ++a) e.fillText(n[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing
                }
            }
            drawBackground(t, e, i, n) {
                var {
                    xAlign: s,
                    yAlign: o
                } = this, {
                    x: a,
                    y: r
                } = t, {
                    width: l,
                    height: c
                } = i, {
                    topLeft: h,
                    topRight: d,
                    bottomLeft: u,
                    bottomRight: p
                } = oc(n.cornerRadius);
                e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + h, r), "top" === o && this.drawCaret(t, e, i, n), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), "center" === o && "right" === s && this.drawCaret(t, e, i, n), e.lineTo(a + l, r + c - p), e.quadraticCurveTo(a + l, r + c, a + l - p, r + c), "bottom" === o && this.drawCaret(t, e, i, n), e.lineTo(a + u, r + c), e.quadraticCurveTo(a, r + c, a, r + c - u), "center" === o && "left" === s && this.drawCaret(t, e, i, n), e.lineTo(a, r + h), e.quadraticCurveTo(a, r, a + h, r), e.closePath(), e.fill(), 0 < n.borderWidth && e.stroke()
            }
            _updateAnimationTarget(t) {
                var e, i, n = this.chart,
                    s = this.$animations,
                    o = s && s.x,
                    a = s && s.y;
                !o && !a || (e = qu[t.position].call(this, this._active, this._eventPosition)) && (i = this._size = Ju(this, t), n = ip(t, s = Object.assign({}, e, this._size), s = ep(n, t, s), n), o._to === n.x && a._to === n.y || (this.xAlign = s.xAlign, this.yAlign = s.yAlign, this.width = i.width, this.height = i.height, this.caretX = e.x, this.caretY = e.y, this._resolveAnimations().update(this, n)))
            }
            draw(t) {
                var e = this.options.setContext(this.getContext());
                let i = this.opacity;
                if (i) {
                    this._updateAnimationTarget(e);
                    var n = {
                        width: this.width,
                        height: this.height
                    };
                    const a = {
                        x: this.x,
                        y: this.y
                    };
                    i = Math.abs(i) < .001 ? 0 : i;
                    var s = ac(e.padding),
                        o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                    e.enabled && o && (t.save(), t.globalAlpha = i, this.drawBackground(a, t, n, e), Gc(t, e.textDirection), a.y += s.top, this.drawTitle(a, t, e), this.drawBody(a, t, e), this.drawFooter(a, t, e), Jc(t, e.textDirection), t.restore())
                }
            }
            getActiveElements() {
                return this._active || []
            }
            setActiveElements(t, e) {
                var i = this._active,
                    n = t.map(({
                        datasetIndex: t,
                        index: e
                    }) => {
                        var i = this.chart.getDatasetMeta(t);
                        if (!i) throw new Error("Cannot find a dataset at index " + t);
                        return {
                            datasetIndex: t,
                            element: i.data[e],
                            index: e
                        }
                    }),
                    t = !fr(i, n),
                    i = this._positionChanged(n, e);
                (t || i) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0))
            }
            handleEvent(t, e, i = !0) {
                if (e && this._ignoreReplayEvents) return !1;
                this._ignoreReplayEvents = !1;
                var n = this.options,
                    s = this._active || [],
                    o = this._getActiveElements(t, s, e, i),
                    i = this._positionChanged(o, t),
                    i = e || !fr(o, s) || i;
                return i && (this._active = o, (n.enabled || n.external) && (this._eventPosition = {
                    x: t.x,
                    y: t.y
                }, this.update(!0, e))), i
            }
            _getActiveElements(t, e, i, n) {
                var s = this.options;
                if ("mouseout" === t.type) return [];
                if (!n) return e;
                const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i);
                return s.reverse && o.reverse(), o
            }
            _positionChanged(t, e) {
                var {
                    caretX: i,
                    caretY: n,
                    options: s
                } = this, e = qu[s.position].call(this, t, e);
                return !1 !== e && (i !== e.x || n !== e.y)
            }
        }
        ap.positioners = qu;
        Rt = {
            id: "tooltip",
            _element: ap,
            positioners: qu,
            afterInit(t, e, i) {
                i && (t.tooltip = new ap({
                    chart: t,
                    options: i
                }))
            },
            beforeUpdate(t, e, i) {
                t.tooltip && t.tooltip.initialize(i)
            },
            reset(t, e, i) {
                t.tooltip && t.tooltip.initialize(i)
            },
            afterDraw(t) {
                const e = t.tooltip;
                var i = {
                    tooltip: e
                };
                !1 !== t.notifyPlugins("beforeTooltipDraw", i) && (e && e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i))
            },
            afterEvent(t, e) {
                var i;
                t.tooltip && (i = e.replay, t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0))
            },
            defaults: {
                enabled: !0,
                external: null,
                position: "average",
                backgroundColor: "rgba(0,0,0,0.8)",
                titleColor: "#fff",
                titleFont: {
                    weight: "bold"
                },
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleAlign: "left",
                bodyColor: "#fff",
                bodySpacing: 2,
                bodyFont: {},
                bodyAlign: "left",
                footerColor: "#fff",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFont: {
                    weight: "bold"
                },
                footerAlign: "left",
                padding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                boxHeight: (t, e) => e.bodyFont.size,
                boxWidth: (t, e) => e.bodyFont.size,
                multiKeyBackground: "#fff",
                displayColors: !0,
                boxPadding: 0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                animation: {
                    duration: 400,
                    easing: "easeOutQuart"
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["x", "y", "width", "height", "caretX", "caretY"]
                    },
                    opacity: {
                        easing: "linear",
                        duration: 200
                    }
                },
                callbacks: {
                    beforeTitle: nr,
                    title(t) {
                        if (0 < t.length) {
                            var e = t[0],
                                i = e.chart.data.labels,
                                t = i ? i.length : 0;
                            if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || "";
                            if (e.label) return e.label;
                            if (0 < t && e.dataIndex < t) return i[e.dataIndex]
                        }
                        return ""
                    },
                    afterTitle: nr,
                    beforeBody: nr,
                    beforeLabel: nr,
                    label(t) {
                        if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue;
                        let e = t.dataset.label || "";
                        e && (e += ": ");
                        t = t.formattedValue;
                        return or(t) || (e += t), e
                    },
                    labelColor(t) {
                        const e = t.chart.getDatasetMeta(t.datasetIndex);
                        t = e.controller.getStyle(t.dataIndex);
                        return {
                            borderColor: t.borderColor,
                            backgroundColor: t.backgroundColor,
                            borderWidth: t.borderWidth,
                            borderDash: t.borderDash,
                            borderDashOffset: t.borderDashOffset,
                            borderRadius: 0
                        }
                    },
                    labelTextColor() {
                        return this.options.bodyColor
                    },
                    labelPointStyle(t) {
                        const e = t.chart.getDatasetMeta(t.datasetIndex);
                        t = e.controller.getStyle(t.dataIndex);
                        return {
                            pointStyle: t.pointStyle,
                            rotation: t.rotation
                        }
                    },
                    afterLabel: nr,
                    afterBody: nr,
                    beforeFooter: nr,
                    footer: nr,
                    afterFooter: nr
                }
            },
            defaultRoutes: {
                bodyFont: "font",
                footerFont: "font",
                titleFont: "font"
            },
            descriptors: {
                _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
                _indexable: !1,
                callbacks: {
                    _scriptable: !1,
                    _indexable: !1
                },
                animation: {
                    _fallback: !1
                },
                animations: {
                    _fallback: "animation"
                }
            },
            additionalOptionScopes: ["interaction"]
        };

        function rp(t, e, i, n) {
            var s, o, a, r = t.indexOf(e);
            return -1 === r ? (s = t, o = i, a = n, "string" == typeof(n = e) ? (o = s.push(n) - 1, a.unshift({
                index: o,
                label: n
            })) : isNaN(n) && (o = null), o) : r !== t.lastIndexOf(e) ? i : r
        }
        class lp extends Bd {
            constructor(t) {
                super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
            }
            init(t) {
                var e = this._addedLabels;
                if (e.length) {
                    const s = this.getLabels();
                    for (var {
                            index: i,
                            label: n
                        } of e) s[i] === n && s.splice(i, 1);
                    this._addedLabels = []
                }
                super.init(t)
            }
            parse(t, e) {
                if (or(t)) return null;
                var i = this.getLabels();
                return e = isFinite(e) && i[e] === t ? e : rp(i, t, hr(e, t), this._addedLabels), e = e, i = i.length - 1, null === e ? null : Zr(Math.round(e), 0, i)
            }
            determineDataLimits() {
                var {
                    minDefined: t,
                    maxDefined: e
                } = this.getUserBounds();
                let {
                    min: i,
                    max: n
                } = this.getMinMax(!0);
                "ticks" === this.options.bounds && (t || (i = 0), e || (n = this.getLabels().length - 1)), this.min = i, this.max = n
            }
            buildTicks() {
                var e = this.min,
                    i = this.max,
                    t = this.options.offset;
                const n = [];
                let s = this.getLabels();
                s = 0 === e && i === s.length - 1 ? s : s.slice(e, i + 1), this._valueRange = Math.max(s.length - (t ? 0 : 1), 1), this._startValue = this.min - (t ? .5 : 0);
                for (let t = e; t <= i; t++) n.push({
                    value: t
                });
                return n
            }
            getLabelForValue(t) {
                var e = this.getLabels();
                return 0 <= t && t < e.length ? e[t] : t
            }
            configure() {
                super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
            }
            getPixelForValue(t) {
                return null === (t = "number" != typeof t ? this.parse(t) : t) ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
            }
            getPixelForTick(t) {
                var e = this.ticks;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
            }
            getValueForPixel(t) {
                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
            }
            getBasePixel() {
                return this.bottom
            }
        }

        function cp(t, e) {
            const i = [];
            var {
                bounds: n,
                step: s,
                min: o,
                max: a,
                precision: r,
                count: l,
                maxTicks: c,
                maxDigits: h,
                includeBounds: d
            } = t, u = s || 1, p = c - 1, {
                min: f,
                max: g
            } = e, _ = !or(o), m = !or(a), e = !or(l), h = (g - f) / (h + 1);
            let v = jr((g - f) / p / u) * u,
                b, y, x, w;
            if (v < 1e-14 && !_ && !m) return [{
                value: f
            }, {
                value: g
            }];
            w = Math.ceil(g / v) - Math.floor(f / v), w > p && (v = jr(w * v / p / u) * u), or(r) || (b = Math.pow(10, r), v = Math.ceil(v * b) / b), x = "ticks" === n ? (y = Math.floor(f / v) * v, Math.ceil(g / v) * v) : (y = f, g), _ && m && s && (f = (a - o) / s, g = v / 1e3, (s = Math.round(f)) - g <= f && f <= s + g) ? (w = Math.round(Math.min((a - o) / v, c)), v = (a - o) / w, y = o, x = a) : e ? (y = _ ? o : y, x = m ? a : x, w = l - 1, v = (x - y) / w) : (w = (x - y) / v, w = Fr(w, Math.round(w), v / 1e3) ? Math.round(w) : Math.ceil(w));
            l = Math.max(Xr(v), Xr(y));
            b = Math.pow(10, or(r) ? l : r), y = Math.round(y * b) / b, x = Math.round(x * b) / b;
            let C = 0;
            for (_ && (d && y !== o ? (i.push({
                    value: o
                }), y < o && C++, Fr(Math.round((y + C * v) * b) / b, o, hp(o, h, t)) && C++) : y < o && C++); C < w; ++C) i.push({
                value: Math.round((y + C * v) * b) / b
            });
            return m && d && x !== a ? i.length && Fr(i[i.length - 1].value, a, hp(a, h, t)) ? i[i.length - 1].value = a : i.push({
                value: a
            }) : m && x !== a || i.push({
                value: x
            }), i
        }

        function hp(t, e, {
            horizontal: i,
            minRotation: n
        }) {
            n = zr(n), n = (i ? Math.sin(n) : Math.cos(n)) || .001;
            return Math.min(e / n, .75 * e * ("" + t).length)
        }
        lp.id = "category", lp.defaults = {
            ticks: {
                callback: lp.prototype.getLabelForValue
            }
        };
        class dp extends Bd {
            constructor(t) {
                super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
            }
            parse(t, e) {
                return or(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
            }
            handleTickRangeOptions() {
                var e = this.options["beginAtZero"];
                const {
                    minDefined: i,
                    maxDefined: n
                } = this.getUserBounds();
                let {
                    min: s,
                    max: o
                } = this;
                var t, a, r = t => s = i ? s : t,
                    l = t => o = n ? o : t;
                if (e && (t = Hr(s), a = Hr(o), t < 0 && a < 0 ? l(0) : 0 < t && 0 < a && r(0)), s === o) {
                    let t = 1;
                    (o >= Number.MAX_SAFE_INTEGER || s <= Number.MIN_SAFE_INTEGER) && (t = Math.abs(.05 * o)), l(o + t), e || r(s - t)
                }
                this.min = s, this.max = o
            }
            getTickLimit() {
                let {
                    maxTicksLimit: t,
                    stepSize: e
                } = this.options.ticks, i;
                return e ? (i = Math.ceil(this.max / e) - Math.floor(this.min / e) + 1, 1e3 < i && (console.warn(`scales.${this.id}.ticks.stepSize: ${e} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), t = t || 11), t && (i = Math.min(t, i)), i
            }
            computeTickLimit() {
                return Number.POSITIVE_INFINITY
            }
            buildTicks() {
                var t = this.options,
                    e = t.ticks,
                    i = this.getTickLimit();
                const n = cp({
                    maxTicks: i = Math.max(2, i),
                    bounds: t.bounds,
                    min: t.min,
                    max: t.max,
                    precision: e.precision,
                    step: e.stepSize,
                    count: e.count,
                    maxDigits: this._maxDigits(),
                    horizontal: this.isHorizontal(),
                    minRotation: e.minRotation || 0,
                    includeBounds: !1 !== e.includeBounds
                }, this._range || this);
                return "ticks" === t.bounds && Vr(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n
            }
            configure() {
                var t = this.ticks;
                let e = this.min,
                    i = this.max;
                super.configure(), this.options.offset && t.length && (t = (i - e) / Math.max(t.length - 1, 1) / 2, e -= t, i += t), this._startValue = e, this._endValue = i, this._valueRange = i - e
            }
            getLabelForValue(t) {
                return qc(t, this.chart.options.locale, this.options.ticks.format)
            }
        }
        class up extends dp {
            determineDataLimits() {
                var {
                    min: t,
                    max: e
                } = this.getMinMax(!0);
                this.min = lr(t) ? t : 0, this.max = lr(e) ? e : 1, this.handleTickRangeOptions()
            }
            computeTickLimit() {
                var t = this.isHorizontal(),
                    e = t ? this.width : this.height,
                    i = zr(this.options.ticks.minRotation),
                    t = (t ? Math.sin(i) : Math.cos(i)) || .001,
                    i = this._resolveTickFontOptions(0);
                return Math.ceil(e / Math.min(40, i.lineHeight / t))
            }
            getPixelForValue(t) {
                return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
            }
            getValueForPixel(t) {
                return this._startValue + this.getDecimalForPixel(t) * this._valueRange
            }
        }

        function pp(t) {
            return 1 == t / Math.pow(10, Math.floor(Nr(t)))
        }
        up.id = "linear", up.defaults = {
            ticks: {
                callback: Dt.formatters.numeric
            }
        };
        class fp extends Bd {
            constructor(t) {
                super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
            }
            parse(t, e) {
                e = dp.prototype.parse.apply(this, [t, e]);
                if (0 !== e) return lr(e) && 0 < e ? e : null;
                this._zero = !0
            }
            determineDataLimits() {
                var {
                    min: t,
                    max: e
                } = this.getMinMax(!0);
                this.min = lr(t) ? Math.max(0, t) : null, this.max = lr(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions()
            }
            handleTickRangeOptions() {
                const {
                    minDefined: e,
                    maxDefined: i
                } = this.getUserBounds();
                let n = this.min,
                    s = this.max;
                var t = t => n = e ? n : t,
                    o = t => s = i ? s : t,
                    a = (t, e) => Math.pow(10, Math.floor(Nr(t)) + e);
                n === s && (n <= 0 ? (t(1), o(10)) : (t(a(n, -1)), o(a(s, 1)))), n <= 0 && t(a(s, -1)), s <= 0 && o(a(n, 1)), this._zero && this.min !== this._suggestedMin && n === a(this.min, 0) && t(a(n, -1)), this.min = n, this.max = s
            }
            buildTicks() {
                var t = this.options;
                const e = function(t, e) {
                    var i = Math.floor(Nr(e.max)),
                        n = Math.ceil(e.max / Math.pow(10, i));
                    const s = [];
                    let o = cr(t.min, Math.pow(10, Math.floor(Nr(e.min)))),
                        a = Math.floor(Nr(o)),
                        r = Math.floor(o / Math.pow(10, a)),
                        l = a < 0 ? Math.pow(10, Math.abs(a)) : 1;
                    for (; s.push({
                            value: o,
                            major: pp(o)
                        }), ++r, 10 === r && (r = 1, ++a, l = 0 <= a ? 1 : l), o = Math.round(r * Math.pow(10, a) * l) / l, a < i || a === i && r < n;);
                    return t = cr(t.max, o), s.push({
                        value: t,
                        major: pp(o)
                    }), s
                }({
                    min: this._userMin,
                    max: this._userMax
                }, this);
                return "ticks" === t.bounds && Vr(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e
            }
            getLabelForValue(t) {
                return void 0 === t ? "0" : qc(t, this.chart.options.locale, this.options.ticks.format)
            }
            configure() {
                var t = this.min;
                super.configure(), this._startValue = Nr(t), this._valueRange = Nr(this.max) - Nr(t)
            }
            getPixelForValue(t) {
                return null === (t = void 0 === t || 0 === t ? this.min : t) || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Nr(t) - this._startValue) / this._valueRange)
            }
            getValueForPixel(t) {
                t = this.getDecimalForPixel(t);
                return Math.pow(10, this._startValue + t * this._valueRange)
            }
        }

        function gp(t) {
            var e = t.ticks;
            if (e.display && t.display) {
                t = ac(e.backdropPadding);
                return hr(e.font && e.font.size, Vl.font.size) + t.height
            }
            return 0
        }

        function _p(t, e, i) {
            return i = ar(i) ? i : [i], {
                w: function(t, e, i, n) {
                    let s = (n = n || {}).data = n.data || {},
                        o = n.garbageCollect = n.garbageCollect || [];
                    n.font !== e && (s = n.data = {}, o = n.garbageCollect = [], n.font = e), t.save(), t.font = e;
                    let a = 0;
                    var r = i.length;
                    let l, c, h, d, u;
                    for (l = 0; l < r; l++)
                        if (null != (d = i[l]) && !0 !== ar(d)) a = zl(t, s, o, a, d);
                        else if (ar(d))
                        for (c = 0, h = d.length; c < h; c++) null == (u = d[c]) || ar(u) || (a = zl(t, s, o, a, u));
                    t.restore();
                    var p = o.length / 2;
                    if (p > i.length) {
                        for (l = 0; l < p; l++) delete s[o[l]];
                        o.splice(0, p)
                    }
                    return a
                }(t, e.string, i),
                h: i.length * e.lineHeight
            }
        }

        function mp(t, e, i, n, s) {
            return t === n || t === s ? {
                start: e - i / 2,
                end: e + i / 2
            } : t < n || s < t ? {
                start: e - i,
                end: e
            } : {
                start: e,
                end: e + i
            }
        }

        function vp(e) {
            var i = {
                    l: e.left + e._padding.left,
                    r: e.right - e._padding.right,
                    t: e.top + e._padding.top,
                    b: e.bottom - e._padding.bottom
                },
                n = Object.assign({}, i);
            const s = [],
                o = [];
            var a = e._pointLabels.length;
            const r = e.options.pointLabels;
            var l = r.centerPointLabels ? Mr / a : 0;
            for (let t = 0; t < a; t++) {
                var c = r.setContext(e.getPointLabelContext(t));
                o[t] = c.padding;
                var h = e.getPointPosition(t, e.drawingArea + o[t], l),
                    d = rc(c.font),
                    u = _p(e.ctx, d, e._pointLabels[t]);
                s[t] = u;
                c = Qr(e.getIndexAngle(t) + l), d = Math.round(Yr(c));
                ! function(t, e, i, n, s) {
                    var o = Math.abs(Math.sin(i)),
                        i = Math.abs(Math.cos(i));
                    let a = 0,
                        r = 0;
                    n.start < e.l ? (a = (e.l - n.start) / o, t.l = Math.min(t.l, e.l - a)) : n.end > e.r && (a = (n.end - e.r) / o, t.r = Math.max(t.r, e.r + a));
                    s.start < e.t ? (r = (e.t - s.start) / i, t.t = Math.min(t.t, e.t - r)) : s.end > e.b && (r = (s.end - e.b) / i, t.b = Math.max(t.b, e.b + r))
                }(n, i, c, mp(d, h.x, u.w, 0, 180), mp(d, h.y, u.h, 90, 270))
            }
            e.setCenterPoint(i.l - n.l, n.r - i.r, i.t - n.t, n.b - i.b), e._pointLabelItems = function(e, i, n) {
                const s = [],
                    o = e._pointLabels.length,
                    t = e.options,
                    a = gp(t) / 2,
                    r = e.drawingArea,
                    l = t.pointLabels.centerPointLabels ? Mr / o : 0;
                for (let t = 0; t < o; t++) {
                    var c = e.getPointPosition(t, r + a + n[t], l),
                        h = Math.round(Yr(Qr(c.angle + Pr))),
                        d = i[t],
                        u = function(t, e, i) {
                            90 === i || 270 === i ? t -= e / 2 : (270 < i || i < 90) && (t -= e);
                            return t
                        }(c.y, d.h, h),
                        p = function(t) {
                            {
                                if (0 === t || 180 === t) return "center";
                                if (t < 180) return "left"
                            }
                            return "right"
                        }(h),
                        h = function(t, e, i) {
                            "right" === i ? t -= e : "center" === i && (t -= e / 2);
                            return t
                        }(c.x, d.w, p);
                    s.push({
                        x: c.x,
                        y: u,
                        textAlign: p,
                        left: h,
                        top: u,
                        right: h + d.w,
                        bottom: u + d.h
                    })
                }
                return s
            }(e, s, o)
        }

        function bp(e, i, t, n) {
            const s = e["ctx"];
            if (t) s.arc(e.xCenter, e.yCenter, i, 0, Or);
            else {
                var o = e.getPointPosition(0, i);
                s.moveTo(o.x, o.y);
                for (let t = 1; t < n; t++) o = e.getPointPosition(t, i), s.lineTo(o.x, o.y)
            }
        }
        fp.id = "logarithmic", fp.defaults = {
            ticks: {
                callback: Dt.formatters.logarithmic,
                major: {
                    enabled: !0
                }
            }
        };
        class yp extends dp {
            constructor(t) {
                super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
            }
            setDimensions() {
                var t = this._padding = ac(gp(this.options) / 2),
                    e = this.width = this.maxWidth - t.width,
                    i = this.height = this.maxHeight - t.height;
                this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2)
            }
            determineDataLimits() {
                var {
                    min: t,
                    max: e
                } = this.getMinMax(!1);
                this.min = lr(t) && !isNaN(t) ? t : 0, this.max = lr(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions()
            }
            computeTickLimit() {
                return Math.ceil(this.drawingArea / gp(this.options))
            }
            generateTickLabels(t) {
                dp.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e) => {
                    e = ur(this.options.pointLabels.callback, [t, e], this);
                    return e || 0 === e ? e : ""
                }).filter((t, e) => this.chart.getDataVisibility(e))
            }
            fit() {
                var t = this.options;
                t.display && t.pointLabels.display ? vp(this) : this.setCenterPoint(0, 0, 0, 0)
            }
            setCenterPoint(t, e, i, n) {
                this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, n))
            }
            getIndexAngle(t) {
                return Qr(t * (Or / (this._pointLabels.length || 1)) + zr(this.options.startAngle || 0))
            }
            getDistanceFromCenterForValue(t) {
                if (or(t)) return NaN;
                var e = this.drawingArea / (this.max - this.min);
                return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
            }
            getValueForDistanceFromCenter(t) {
                if (or(t)) return NaN;
                t /= this.drawingArea / (this.max - this.min);
                return this.options.reverse ? this.max - t : this.min + t
            }
            getPointLabelContext(t) {
                var e = this._pointLabels || [];
                if (0 <= t && t < e.length) {
                    e = e[t];
                    return cc(this.getContext(), {
                        label: e,
                        index: t,
                        type: "pointLabel"
                    })
                }
            }
            getPointPosition(t, e, i = 0) {
                i = this.getIndexAngle(t) - Pr + i;
                return {
                    x: Math.cos(i) * e + this.xCenter,
                    y: Math.sin(i) * e + this.yCenter,
                    angle: i
                }
            }
            getPointPositionForValue(t, e) {
                return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
            }
            getBasePosition(t) {
                return this.getPointPositionForValue(t || 0, this.getBaseValue())
            }
            getPointLabelPosition(t) {
                var {
                    left: e,
                    top: i,
                    right: n,
                    bottom: t
                } = this._pointLabelItems[t];
                return {
                    left: e,
                    top: i,
                    right: n,
                    bottom: t
                }
            }
            drawBackground() {
                var {
                    backgroundColor: t,
                    grid: {
                        circular: e
                    }
                } = this.options;
                if (t) {
                    const i = this.ctx;
                    i.save(), i.beginPath(), bp(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore()
                }
            }
            drawGrid() {
                const t = this.ctx;
                var e = this.options;
                const {
                    angleLines: i,
                    grid: n
                } = e, s = this._pointLabels.length;
                let o, a, r;
                if (e.pointLabels.display && function(e, i) {
                        const {
                            ctx: n,
                            options: {
                                pointLabels: s
                            }
                        } = e;
                        for (let t = i - 1; 0 <= t; t--) {
                            var o, a = s.setContext(e.getPointLabelContext(t)),
                                r = rc(a.font),
                                {
                                    x: l,
                                    y: c,
                                    textAlign: h,
                                    left: d,
                                    top: u,
                                    right: p,
                                    bottom: f
                                } = e._pointLabelItems[t],
                                g = a["backdropColor"];
                            or(g) || (o = ac(a.backdropPadding), n.fillStyle = g, n.fillRect(d - o.left, u - o.top, p - d + o.width, f - u + o.height)), Gl(n, e._pointLabels[t], l, c + r.lineHeight / 2, r, {
                                color: a.color,
                                textAlign: h,
                                textBaseline: "middle"
                            })
                        }
                    }(this, s), n.display && this.ticks.forEach((t, e) => {
                        0 !== e && (a = this.getDistanceFromCenterForValue(t.value), e = n.setContext(this.getContext(e - 1)), function(t, e, i, n) {
                            const s = t.ctx;
                            var o = e.circular,
                                {
                                    color: a,
                                    lineWidth: r
                                } = e;
                            !o && !n || !a || !r || i < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = r, s.setLineDash(e.borderDash), s.lineDashOffset = e.borderDashOffset, s.beginPath(), bp(t, i, o, n), s.closePath(), s.stroke(), s.restore())
                        }(this, e, a, s))
                    }), i.display) {
                    for (t.save(), o = s - 1; 0 <= o; o--) {
                        var l = i.setContext(this.getPointLabelContext(o)),
                            {
                                color: c,
                                lineWidth: h
                            } = l;
                        h && c && (t.lineWidth = h, t.strokeStyle = c, t.setLineDash(l.borderDash), t.lineDashOffset = l.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), r = this.getPointPosition(o, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(r.x, r.y), t.stroke())
                    }
                    t.restore()
                }
            }
            drawBorder() {}
            drawLabels() {
                const a = this.ctx,
                    r = this.options,
                    l = r.ticks;
                if (l.display) {
                    var t = this.getIndexAngle(0);
                    let s, o;
                    a.save(), a.translate(this.xCenter, this.yCenter), a.rotate(t), a.textAlign = "center", a.textBaseline = "middle", this.ticks.forEach((t, e) => {
                        var i, n;
                        0 === e && !r.reverse || (n = rc((i = l.setContext(this.getContext(e))).font), s = this.getDistanceFromCenterForValue(this.ticks[e].value), i.showLabelBackdrop && (a.font = n.string, o = a.measureText(t.label).width, a.fillStyle = i.backdropColor, e = ac(i.backdropPadding), a.fillRect(-o / 2 - e.left, -s - n.size / 2 - e.top, o + e.width, n.size + e.height)), Gl(a, t.label, 0, -s, n, {
                            color: i.color
                        }))
                    }), a.restore()
                }
            }
            drawTitle() {}
        }
        yp.id = "radialLinear", yp.defaults = {
            display: !0,
            animate: !0,
            position: "chartArea",
            angleLines: {
                display: !0,
                lineWidth: 1,
                borderDash: [],
                borderDashOffset: 0
            },
            grid: {
                circular: !1
            },
            startAngle: 0,
            ticks: {
                showLabelBackdrop: !0,
                callback: Dt.formatters.numeric
            },
            pointLabels: {
                backdropColor: void 0,
                backdropPadding: 2,
                display: !0,
                font: {
                    size: 10
                },
                callback(t) {
                    return t
                },
                padding: 5,
                centerPointLabels: !1
            }
        }, yp.defaultRoutes = {
            "angleLines.color": "borderColor",
            "pointLabels.color": "color",
            "ticks.color": "color"
        };
        const xp = {
                millisecond: {
                    common: !0,
                    size: 1,
                    steps: 1e3
                },
                second: {
                    common: !0,
                    size: 1e3,
                    steps: 60
                },
                minute: {
                    common: !0,
                    size: 6e4,
                    steps: 60
                },
                hour: {
                    common: !0,
                    size: 36e5,
                    steps: 24
                },
                day: {
                    common: !0,
                    size: 864e5,
                    steps: 30
                },
                week: {
                    common: !(yp.descriptors = {
                        angleLines: {
                            _fallback: "grid"
                        }
                    }),
                    size: 6048e5,
                    steps: 4
                },
                month: {
                    common: !0,
                    size: 2628e6,
                    steps: 12
                },
                quarter: {
                    common: !1,
                    size: 7884e6,
                    steps: 4
                },
                year: {
                    common: !0,
                    size: 3154e7
                }
            },
            wp = Object.keys(xp);

        function Cp(t, e) {
            return t - e
        }

        function kp(t, e) {
            if (or(e)) return null;
            const i = t._adapter,
                {
                    parser: n,
                    round: s,
                    isoWeekday: o
                } = t._parseOpts;
            let a = e;
            return "function" == typeof n && (a = n(a)), lr(a) || (a = "string" == typeof n ? i.parse(a, n) : i.parse(a)), null === a ? null : (s && (a = "week" !== s || !Wr(o) && !0 !== o ? i.startOf(a, s) : i.startOf(a, "isoWeek", o)), +a)
        }

        function Tp(e, i, n, s) {
            var o = wp.length;
            for (let t = wp.indexOf(e); t < o - 1; ++t) {
                var a = xp[wp[t]],
                    r = a.steps || Number.MAX_SAFE_INTEGER;
                if (a.common && Math.ceil((n - i) / (r * a.size)) <= s) return wp[t]
            }
            return wp[o - 1]
        }

        function Sp(t, e, i) {
            var n, s;
            i ? i.length && ({
                lo: n,
                hi: s
            } = hc(i, e), t[i[n] >= e ? i[n] : i[s]] = !0) : t[e] = !0
        }

        function Ep(t, e, i) {
            const n = [],
                s = {};
            var o = e.length;
            let a, r;
            for (a = 0; a < o; ++a) r = e[a], s[r] = a, n.push({
                value: r,
                major: !1
            });
            return 0 !== o && i ? function(t, e, i, n) {
                const s = t._adapter;
                var t = +s.startOf(e[0].value, n),
                    o = e[e.length - 1].value;
                let a, r;
                for (a = t; a <= o; a = +s.add(a, 1, n)) 0 <= (r = i[a]) && (e[r].major = !0);
                return e
            }(t, n, s, i) : n
        }
        class Ap extends Bd {
            constructor(t) {
                super(t), this._cache = {
                    data: [],
                    labels: [],
                    all: []
                }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
            }
            init(t, e) {
                var i = t.time || (t.time = {});
                const n = this._adapter = new Fh._date(t.adapters.date);
                br(i.displayFormats, n.formats()), this._parseOpts = {
                    parser: i.parser,
                    round: i.round,
                    isoWeekday: i.isoWeekday
                }, super.init(t), this._normalized = e.normalized
            }
            parse(t, e) {
                return void 0 === t ? null : kp(this, t)
            }
            beforeLayout() {
                super.beforeLayout(), this._cache = {
                    data: [],
                    labels: [],
                    all: []
                }
            }
            determineDataLimits() {
                var t = this.options;
                const e = this._adapter;
                var i = t.time.unit || "day";
                let {
                    min: n,
                    max: s,
                    minDefined: o,
                    maxDefined: a
                } = this.getUserBounds();

                function r(t) {
                    o || isNaN(t.min) || (n = Math.min(n, t.min)), a || isNaN(t.max) || (s = Math.max(s, t.max))
                }
                o && a || (r(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || r(this.getMinMax(!1))), n = lr(n) && !isNaN(n) ? n : +e.startOf(Date.now(), i), s = lr(s) && !isNaN(s) ? s : +e.endOf(Date.now(), i) + 1, this.min = Math.min(n, s - 1), this.max = Math.max(n + 1, s)
            }
            _getLabelBounds() {
                var t = this.getLabelTimestamps();
                let e = Number.POSITIVE_INFINITY,
                    i = Number.NEGATIVE_INFINITY;
                return t.length && (e = t[0], i = t[t.length - 1]), {
                    min: e,
                    max: i
                }
            }
            buildTicks() {
                var t = this.options,
                    e = t.time,
                    i = t.ticks,
                    n = "labels" === i.source ? this.getLabelTimestamps() : this._generate();
                "ticks" === t.bounds && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);
                var s = this.min;
                const o = function(t, e, i) {
                    let n = 0,
                        s = t.length;
                    for (; n < s && t[n] < e;) n++;
                    for (; s > n && t[s - 1] > i;) s--;
                    return 0 < n || s < t.length ? t.slice(n, s) : t
                }(n, s, this.max);
                return this._unit = e.unit || (i.autoSkip ? Tp(e.minUnit, this.min, this.max, this._getLabelCapacity(s)) : function(e, i, n, s, o) {
                    for (let t = wp.length - 1; t >= wp.indexOf(n); t--) {
                        var a = wp[t];
                        if (xp[a].common && e._adapter.diff(o, s, a) >= i - 1) return a
                    }
                    return wp[n ? wp.indexOf(n) : 0]
                }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function(i) {
                    for (let t = wp.indexOf(i) + 1, e = wp.length; t < e; ++t)
                        if (xp[wp[t]].common) return wp[t]
                }(this._unit) : void 0, this.initOffsets(n), t.reverse && o.reverse(), Ep(this, o, this._majorUnit)
            }
            initOffsets(t) {
                let e = 0,
                    i = 0;
                var n;
                this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), e = 1 === t.length ? 1 - n : (this.getDecimalForValue(t[1]) - n) / 2, n = this.getDecimalForValue(t[t.length - 1]), i = 1 === t.length ? n : (n - this.getDecimalForValue(t[t.length - 2])) / 2);
                t = t.length < 3 ? .5 : .25;
                e = Zr(e, 0, t), i = Zr(i, 0, t), this._offsets = {
                    start: e,
                    end: i,
                    factor: 1 / (e + 1 + i)
                }
            }
            _generate() {
                const t = this._adapter;
                var e = this.min,
                    i = this.max,
                    n = this.options,
                    s = n.time,
                    o = s.unit || Tp(s.minUnit, e, i, this._getLabelCapacity(e)),
                    a = hr(s.stepSize, 1),
                    r = "week" === o && s.isoWeekday,
                    s = Wr(r) || !0 === r,
                    l = {};
                let c = e,
                    h, d;
                if (s && (c = +t.startOf(c, "isoWeek", r)), c = +t.startOf(c, s ? "day" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + " and " + i + " are too far apart with stepSize of " + a + " " + o);
                var u = "data" === n.ticks.source && this.getDataTimestamps();
                for (h = c, d = 0; h < i; h = +t.add(h, a, o), d++) Sp(l, h, u);
                return h !== i && "ticks" !== n.bounds && 1 !== d || Sp(l, h, u), Object.keys(l).sort((t, e) => t - e).map(t => +t)
            }
            getLabelForValue(t) {
                const e = this._adapter;
                var i = this.options.time;
                return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
            }
            _tickFormatFunction(t, e, i, n) {
                var s = this.options,
                    o = s.time.displayFormats,
                    a = this._unit,
                    r = this._majorUnit,
                    l = a && o[a],
                    a = r && o[r],
                    o = i[e],
                    o = r && a && o && o.major,
                    l = this._adapter.format(t, n || (o ? a : l)),
                    s = s.ticks.callback;
                return s ? ur(s, [l, e, i], this) : l
            }
            generateTickLabels(t) {
                let e, i, n;
                for (e = 0, i = t.length; e < i; ++e) n = t[e], n.label = this._tickFormatFunction(n.value, e, t)
            }
            getDecimalForValue(t) {
                return null === t ? NaN : (t - this.min) / (this.max - this.min)
            }
            getPixelForValue(t) {
                var e = this._offsets,
                    t = this.getDecimalForValue(t);
                return this.getPixelForDecimal((e.start + t) * e.factor)
            }
            getValueForPixel(t) {
                var e = this._offsets,
                    e = this.getDecimalForPixel(t) / e.factor - e.end;
                return this.min + e * (this.max - this.min)
            }
            _getLabelSize(t) {
                var e = this.options.ticks,
                    i = this.ctx.measureText(t).width,
                    n = zr(this.isHorizontal() ? e.maxRotation : e.minRotation),
                    t = Math.cos(n),
                    e = Math.sin(n),
                    n = this._resolveTickFontOptions(0).size;
                return {
                    w: i * t + n * e,
                    h: i * e + n * t
                }
            }
            _getLabelCapacity(t) {
                var e = this.options.time,
                    i = e.displayFormats,
                    i = i[e.unit] || i.millisecond,
                    i = this._tickFormatFunction(t, 0, Ep(this, [t], this._majorUnit), i),
                    i = this._getLabelSize(i),
                    i = Math.floor(this.isHorizontal() ? this.width / i.w : this.height / i.h) - 1;
                return 0 < i ? i : 1
            }
            getDataTimestamps() {
                let t = this._cache.data || [],
                    e, i;
                if (t.length) return t;
                const n = this.getMatchingVisibleMetas();
                if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);
                for (e = 0, i = n.length; e < i; ++e) t = t.concat(n[e].controller.getAllParsedValues(this));
                return this._cache.data = this.normalize(t)
            }
            getLabelTimestamps() {
                const t = this._cache.labels || [];
                let e, i;
                if (t.length) return t;
                var n = this.getLabels();
                for (e = 0, i = n.length; e < i; ++e) t.push(kp(this, n[e]));
                return this._cache.labels = this._normalized ? t : this.normalize(t)
            }
            normalize(t) {
                return gc(t.sort(Cp))
            }
        }

        function Mp(t, e, i) {
            let n = 0,
                s = t.length - 1,
                o, a, r, l;
            i ? (e >= t[n].pos && e <= t[s].pos && ({
                lo: n,
                hi: s
            } = dc(t, "pos", e)), {
                pos: o,
                time: r
            } = t[n], {
                pos: a,
                time: l
            } = t[s]) : (e >= t[n].time && e <= t[s].time && ({
                lo: n,
                hi: s
            } = dc(t, "time", e)), {
                time: o,
                pos: r
            } = t[n], {
                time: a,
                pos: l
            } = t[s]);
            t = a - o;
            return t ? r + (l - r) * (e - o) / t : r
        }
        Ap.id = "time", Ap.defaults = {
            bounds: "data",
            adapters: {},
            time: {
                parser: !1,
                unit: !1,
                round: !1,
                isoWeekday: !1,
                minUnit: "millisecond",
                displayFormats: {}
            },
            ticks: {
                source: "auto",
                major: {
                    enabled: !1
                }
            }
        };
        class Op extends Ap {
            constructor(t) {
                super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0
            }
            initOffsets() {
                var t = this._getTimestampsForTable(),
                    e = this._table = this.buildLookupTable(t);
                this._minPos = Mp(e, this.min), this._tableRange = Mp(e, this.max) - this._minPos, super.initOffsets(t)
            }
            buildLookupTable(t) {
                var {
                    min: e,
                    max: i
                } = this;
                const n = [],
                    s = [];
                let o, a, r, l, c;
                for (o = 0, a = t.length; o < a; ++o) l = t[o], l >= e && l <= i && n.push(l);
                if (n.length < 2) return [{
                    time: e,
                    pos: 0
                }, {
                    time: i,
                    pos: 1
                }];
                for (o = 0, a = n.length; o < a; ++o) c = n[o + 1], r = n[o - 1], l = n[o], Math.round((c + r) / 2) !== l && s.push({
                    time: l,
                    pos: o / (a - 1)
                });
                return s
            }
            _getTimestampsForTable() {
                let t = this._cache.all || [];
                if (t.length) return t;
                const e = this.getDataTimestamps();
                var i = this.getLabelTimestamps();
                return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t
            }
            getDecimalForValue(t) {
                return (Mp(this._table, t) - this._minPos) / this._tableRange
            }
            getValueForPixel(t) {
                var e = this._offsets,
                    e = this.getDecimalForPixel(t) / e.factor - e.end;
                return Mp(this._table, e * this._tableRange + this._minPos, !0)
            }
        }
        Op.id = "timeseries", Op.defaults = Ap.defaults;
        var Ip = function() {
                if ("undefined" != typeof window) {
                    if (window.devicePixelRatio) return window.devicePixelRatio;
                    var t = window.screen;
                    if (t) return (t.deviceXDPI || 1) / (t.logicalXDPI || 1)
                }
                return 1
            }(),
            Dp = function(t) {
                var e, i = [];
                for (t = [].concat(t); t.length;) "string" == typeof(e = t.pop()) ? i.unshift.apply(i, e.split("\n")) : Array.isArray(e) ? t.push.apply(t, e) : or(t) || i.unshift("" + e);
                return i
            },
            Lp = function(t, e, i) {
                var n, s = [].concat(e),
                    o = s.length,
                    e = t.font,
                    a = 0;
                for (t.font = i.string, n = 0; n < o; ++n) a = Math.max(t.measureText(s[n]).width, a);
                return t.font = e, {
                    height: o * i.lineHeight,
                    width: a
                }
            },
            Pp = function(t, e, i) {
                return Math.max(t, Math.min(e, i))
            },
            Rp = function(t, e) {
                for (var i, n, s = t.slice(), o = [], a = 0, r = e.length; a < r; ++a) n = e[a], -1 === (i = s.indexOf(n)) ? o.push([n, 1]) : s.splice(i, 1);
                for (a = 0, r = s.length; a < r; ++a) o.push([s[a], -1]);
                return o
            };

        function Bp(t, e) {
            var i = e.x,
                e = e.y;
            if (null === i) return {
                x: 0,
                y: -1
            };
            if (null === e) return {
                x: 1,
                y: 0
            };
            i = t.x - i, t = t.y - e, e = Math.sqrt(i * i + t * t);
            return {
                x: e ? i / e : 0,
                y: e ? t / e : -1
            }
        }
        var Np = 0,
            Hp = 1,
            jp = 2,
            Wp = 4,
            Fp = 8;

        function Vp(t, e, i) {
            var n = Np;
            return t < i.left ? n |= Hp : t > i.right && (n |= jp), e < i.top ? n |= Fp : e > i.bottom && (n |= Wp), n
        }

        function zp(t, e) {
            var i, n = e.anchor,
                s = t;
            return e.clamp && (s = function(t, e) {
                    for (var i, n, s, o = t.x0, a = t.y0, r = t.x1, l = t.y1, c = Vp(o, a, e), h = Vp(r, l, e);;) {
                        if (!(c | h) || c & h) break;
                        (i = c || h) & Fp ? (n = o + (r - o) * (e.top - a) / (l - a), s = e.top) : i & Wp ? (n = o + (r - o) * (e.bottom - a) / (l - a), s = e.bottom) : i & jp ? (s = a + (l - a) * (e.right - o) / (r - o), n = e.right) : i & Hp && (s = a + (l - a) * (e.left - o) / (r - o), n = e.left), i === c ? c = Vp(o = n, a = s, e) : h = Vp(r = n, l = s, e)
                    }
                    return {
                        x0: o,
                        x1: r,
                        y0: a,
                        y1: l
                    }
                }(s, e.area)), s = "start" === n ? (i = s.x0, s.y0) : "end" === n ? (i = s.x1, s.y1) : (i = (s.x0 + s.x1) / 2, (s.y0 + s.y1) / 2),
                function(t, e, i, n, s) {
                    switch (s) {
                        case "center":
                            i = n = 0;
                            break;
                        case "bottom":
                            i = 0, n = 1;
                            break;
                        case "right":
                            i = 1, n = 0;
                            break;
                        case "left":
                            i = -1, n = 0;
                            break;
                        case "top":
                            i = 0, n = -1;
                            break;
                        case "start":
                            i = -i, n = -n;
                            break;
                        case "end":
                            break;
                        default:
                            s *= Math.PI / 180, i = Math.cos(s), n = Math.sin(s)
                    }
                    return {
                        x: t,
                        y: e,
                        vx: i,
                        vy: n
                    }
                }(i, s, t.vx, t.vy, e.align)
        }
        var Yp = function(t, e) {
                var i = (t.startAngle + t.endAngle) / 2,
                    n = Math.cos(i),
                    s = Math.sin(i),
                    o = t.innerRadius,
                    i = t.outerRadius;
                return zp({
                    x0: t.x + n * o,
                    y0: t.y + s * o,
                    x1: t.x + n * i,
                    y1: t.y + s * i,
                    vx: n,
                    vy: s
                }, e)
            },
            Xp = function(t, e) {
                var i = Bp(t, e.origin),
                    n = i.x * t.options.radius,
                    s = i.y * t.options.radius;
                return zp({
                    x0: t.x - n,
                    y0: t.y - s,
                    x1: t.x + n,
                    y1: t.y + s,
                    vx: i.x,
                    vy: i.y
                }, e)
            },
            Up = function(t, e) {
                var i = Bp(t, e.origin),
                    n = t.x,
                    s = t.y,
                    o = 0,
                    a = 0;
                return t.horizontal ? (n = Math.min(t.x, t.base), o = Math.abs(t.base - t.x)) : (s = Math.min(t.y, t.base), a = Math.abs(t.base - t.y)), zp({
                    x0: n,
                    y0: s + a,
                    x1: n + o,
                    y1: s,
                    vx: i.x,
                    vy: i.y
                }, e)
            },
            Kp = function(t, e) {
                var i = Bp(t, e.origin);
                return zp({
                    x0: t.x,
                    y0: t.y,
                    x1: t.x,
                    y1: t.y,
                    vx: i.x,
                    vy: i.y
                }, e)
            },
            $p = function(t) {
                return Math.round(t * Ip) / Ip
            };

        function Qp(t, e, i) {
            var n, s, o, a, r, l, c, h, d, u = i.backgroundColor,
                p = i.borderColor,
                f = i.borderWidth;
            (u || p && f) && (t.beginPath(), n = t, s = $p(e.x) + f / 2, o = $p(e.y) + f / 2, a = $p(e.w) - f, r = $p(e.h) - f, l = i.borderRadius, d = Math.PI / 2, l ? (h = s + (c = Math.min(l, r / 2, a / 2)), e = s + a - c, i = o + r - c, n.moveTo(s, l = o + c), h < e && l < i ? (n.arc(h, l, c, -Math.PI, -d), n.arc(e, l, c, -d, 0), n.arc(e, i, c, 0, d), n.arc(h, i, c, d, Math.PI)) : h < e ? (n.moveTo(h, o), n.arc(e, l, c, -d, d), n.arc(h, l, c, d, Math.PI + d)) : l < i ? (n.arc(h, l, c, -Math.PI, 0), n.arc(h, i, c, 0, Math.PI)) : n.arc(h, l, c, -Math.PI, Math.PI), n.closePath(), n.moveTo(s, o)) : n.rect(s, o, a, r), t.closePath(), u && (t.fillStyle = u, t.fill()), p && f && (t.strokeStyle = p, t.lineWidth = f, t.lineJoin = "miter", t.stroke()))
        }

        function qp(t, e, i, n) {
            var s, o, a, r, l, c, h, d, u, p, f, g, _, m, v = n.textAlign,
                b = n.color,
                y = !!b,
                x = n.font,
                w = e.length,
                C = n.textStrokeColor,
                k = n.textStrokeWidth,
                T = C && k;
            if (w && (y || T))
                for (o = i, a = v, l = (r = x).lineHeight, c = o.w, r = o.x, "center" === a ? r += c / 2 : "end" !== a && "right" !== a || (r += c), i = {
                        h: l,
                        w: c,
                        x: r,
                        y: o.y + l / 2
                    }, t.font = x.string, t.textAlign = v, t.textBaseline = "middle", t.shadowBlur = n.textShadowBlur, t.shadowColor = n.textShadowColor, y && (t.fillStyle = b), T && (t.lineJoin = "round", t.lineWidth = k, t.strokeStyle = C), s = 0, w = e.length; s < w; ++s) h = t, d = e[s], u = {
                    stroked: T,
                    filled: y,
                    w: i.w,
                    x: i.x,
                    y: i.y + i.h * s
                }, m = _ = g = f = p = void 0, p = h.shadowBlur, f = u.stroked, g = $p(u.x), _ = $p(u.y), m = $p(u.w), f && h.strokeText(d, g, _, m), u.filled && (p && f && (h.shadowBlur = 0), h.fillText(d, g, _, m), p && f && (h.shadowBlur = p))
        }

        function Zp(t, e, i, n) {
            this._config = t, this._index = n, this._model = null, this._rects = null, this._ctx = e, this._el = i
        }
        vr(Zp.prototype, {
            _modelize: function(t, e, i, n) {
                var s, o = this._index,
                    a = rc(lc([i.font, {}], n, o)),
                    r = lc([i.color, Vl.color], n, o);
                return {
                    align: lc([i.align, "center"], n, o),
                    anchor: lc([i.anchor, "center"], n, o),
                    area: n.chart.chartArea,
                    backgroundColor: lc([i.backgroundColor, null], n, o),
                    borderColor: lc([i.borderColor, null], n, o),
                    borderRadius: lc([i.borderRadius, 0], n, o),
                    borderWidth: lc([i.borderWidth, 0], n, o),
                    clamp: lc([i.clamp, !1], n, o),
                    clip: lc([i.clip, !1], n, o),
                    color: r,
                    display: t,
                    font: a,
                    lines: e,
                    offset: lc([i.offset, 0], n, o),
                    opacity: lc([i.opacity, 1], n, o),
                    origin: (s = this._el, (t = (t = n).chart.getDatasetMeta(t.datasetIndex).vScale) ? void 0 !== t.xCenter && void 0 !== t.yCenter ? {
                        x: t.xCenter,
                        y: t.yCenter
                    } : (t = t.getBasePixel(), s.horizontal ? {
                        x: t,
                        y: null
                    } : {
                        x: null,
                        y: t
                    }) : null),
                    padding: ac(lc([i.padding, 0], n, o)),
                    positioner: (t = this._el) instanceof pu ? Yp : t instanceof ku ? Xp : t instanceof Iu ? Up : Kp,
                    rotation: lc([i.rotation, 0], n, o) * (Math.PI / 180),
                    size: Lp(this._ctx, e, a),
                    textAlign: lc([i.textAlign, "start"], n, o),
                    textShadowBlur: lc([i.textShadowBlur, 0], n, o),
                    textShadowColor: lc([i.textShadowColor, r], n, o),
                    textStrokeColor: lc([i.textStrokeColor, r], n, o),
                    textStrokeWidth: lc([i.textStrokeWidth, 0], n, o)
                }
            },
            update: function(t) {
                var e, i, n = null,
                    s = null,
                    o = this._index,
                    a = this._config,
                    r = lc([a.display, !0], t, o);
                r && (e = t.dataset.data[o], (o = or(i = hr(ur(a.formatter, [e, t]), e)) ? [] : Dp(i)).length && (n = this._modelize(r, o, a, t), i = (e = n).borderWidth || 0, r = e.padding, o = e.size.height, a = e.size.width, e = -o / 2, s = {
                    frame: {
                        x: (t = -a / 2) - r.left - i,
                        y: e - r.top - i,
                        w: a + r.width + 2 * i,
                        h: o + r.height + 2 * i
                    },
                    text: {
                        x: t,
                        y: e,
                        w: a,
                        h: o
                    }
                })), this._model = n, this._rects = s
            },
            geometry: function() {
                return this._rects ? this._rects.frame : {}
            },
            rotation: function() {
                return this._model ? this._model.rotation : 0
            },
            visible: function() {
                return this._model && this._model.opacity
            },
            model: function() {
                return this._model
            },
            draw: function(t, e) {
                var i = t.ctx,
                    n = this._model,
                    s = this._rects;
                this.visible() && (i.save(), n.clip && (t = n.area, i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip()), i.globalAlpha = Pp(0, n.opacity, 1), i.translate($p(e.x), $p(e.y)), i.rotate(n.rotation), Qp(i, s.frame, n), qp(i, n.lines, s.text, n), i.restore())
            }
        });
        var Gp = Number.MIN_SAFE_INTEGER || -9007199254740991,
            Jp = Number.MAX_SAFE_INTEGER || 9007199254740991;

        function tf(t, e, i) {
            var n = Math.cos(i),
                s = Math.sin(i),
                i = e.x,
                e = e.y;
            return {
                x: i + n * (t.x - i) - s * (t.y - e),
                y: e + s * (t.x - i) + n * (t.y - e)
            }
        }

        function ef(t, e) {
            for (var i, n, s = Jp, o = Gp, a = e.origin, r = 0; r < t.length; ++r) i = (n = t[r]).x - a.x, n = n.y - a.y, n = e.vx * i + e.vy * n, s = Math.min(s, n), o = Math.max(o, n);
            return {
                min: s,
                max: o
            }
        }

        function nf(t, e) {
            var i = e.x - t.x,
                n = e.y - t.y,
                n = Math.sqrt(i * i + n * n);
            return {
                vx: (e.x - t.x) / n,
                vy: (e.y - t.y) / n,
                origin: t,
                ln: n
            }
        }

        function sf() {
            this._rotation = 0, this._rect = {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            }
        }

        function of (t, e, i) {
            var n = e.positioner(t, e),
                s = n.vx,
                o = n.vy;
            if (!s && !o) return {
                x: n.x,
                y: n.y
            };
            var a = i.w,
                r = i.h,
                t = e.rotation,
                i = Math.abs(a / 2 * Math.cos(t)) + Math.abs(r / 2 * Math.sin(t)),
                r = Math.abs(a / 2 * Math.sin(t)) + Math.abs(r / 2 * Math.cos(t)),
                t = 1 / Math.max(Math.abs(s), Math.abs(o));
            return i *= s * t, r *= o * t, i += e.offset * s, r += e.offset * o, {
                x: n.x + i,
                y: n.y + r
            }
        }

        function af(t) {
            for (var e, i, n, s, o = 0, a = t.length; o < a; ++o)(i = (e = t[o]).$layout)._visible && (s = new Proxy(e._el, {
                get: (t, e) => t.getProps([e], !0)[e]
            }), n = e.geometry(), s = of (s, e.model(), n), i._box.update(s, n, e.rotation()));
            return function(t, e) {
                for (var i, n, s, o = t.length - 1; 0 <= o; --o)
                    for (n = t[o].$layout, i = o - 1; 0 <= i && n._visible; --i)(s = t[i].$layout)._visible && n._box.intersects(s._box) && e(n, s);
                return t
            }(t, function(t, e) {
                var i = t._hidable,
                    n = e._hidable;
                i && n || n ? e._visible = !1 : i && (t._visible = !1)
            })
        }
        vr(sf.prototype, {
            center: function() {
                var t = this._rect;
                return {
                    x: t.x + t.w / 2,
                    y: t.y + t.h / 2
                }
            },
            update: function(t, e, i) {
                this._rotation = i, this._rect = {
                    x: e.x + t.x,
                    y: e.y + t.y,
                    w: e.w,
                    h: e.h
                }
            },
            contains: function(t) {
                var e = this._rect;
                return !((t = tf(t, this.center(), -this._rotation)).x < e.x - 1 || t.y < e.y - 1 || t.x > e.x + e.w + 2 || t.y > e.y + e.h + 2)
            },
            intersects: function(t) {
                var e, i, n, s = this._points(),
                    o = t._points(),
                    a = [nf(s[0], s[1]), nf(s[0], s[3])];
                for (this._rotation !== t._rotation && a.push(nf(o[0], o[1]), nf(o[0], o[3])), e = 0; e < a.length; ++e)
                    if (i = ef(s, a[e]), n = ef(o, a[e]), i.max < n.min || n.max < i.min) return !1;
                return !0
            },
            _points: function() {
                var t = this._rect,
                    e = this._rotation,
                    i = this.center();
                return [tf({
                    x: t.x,
                    y: t.y
                }, i, e), tf({
                    x: t.x + t.w,
                    y: t.y
                }, i, e), tf({
                    x: t.x + t.w,
                    y: t.y + t.h
                }, i, e), tf({
                    x: t.x,
                    y: t.y + t.h
                }, i, e)]
            }
        });
        var rf = {
                prepare: function(t) {
                    for (var e, i, n, s = [], o = 0, a = t.length; o < a; ++o)
                        for (e = 0, i = t[o].length; e < i; ++e) n = t[o][e], s.push(n), n.$layout = {
                            _box: new sf,
                            _hidable: !1,
                            _visible: !0,
                            _set: o,
                            _idx: e
                        };
                    return s.sort(function(t, e) {
                        t = t.$layout, e = e.$layout;
                        return t._idx === e._idx ? e._set - t._set : e._idx - t._idx
                    }), this.update(s), s
                },
                update: function(t) {
                    for (var e, i, n, s = !1, o = 0, a = t.length; o < a; ++o) i = (e = t[o]).model(), (n = e.$layout)._hidable = i && "auto" === i.display, n._visible = e.visible(), s |= n._hidable;
                    s && af(t)
                },
                lookup: function(t, e) {
                    for (var i, n = t.length - 1; 0 <= n; --n)
                        if ((i = t[n].$layout) && i._visible && i._box.contains(e)) return t[n];
                    return null
                },
                draw: function(t, e) {
                    for (var i, n, s, o, a = 0, r = e.length; a < r; ++a)(n = (i = e[a]).$layout)._visible && (s = i.geometry(), o = of (i._el, i.model(), s), n._box.update(o, s, i.rotation()), i.draw(t, o))
                }
            },
            lf = "$datalabels";

        function cf(t, e, i) {
            var n, s, o;
            e && (n = i.$context, e[(s = i.$groups)._set] && (o = e[s._set][s._key]) && !0 === ur(o, [n]) && (t[lf]._dirty = !0, i.update(n)))
        }

        function hf(t, e) {
            var i = t[lf],
                n = i._listeners;
            if (n.enter || n.leave) {
                if ("mousemove" === e.type) s = rf.lookup(i._labels, e);
                else if ("mouseout" !== e.type) return;
                var s, o, a, e = i._hovered;
                i._hovered = s, t = t, n = n, s = s, ((e = e) || s) && (e ? s ? e !== s && (a = o = !0) : a = !0 : o = !0, a && cf(t, n.leave, e), o && cf(t, n.enter, s))
            }
        }
        var df = {
            id: "datalabels",
            defaults: {
                align: "center",
                anchor: "center",
                backgroundColor: null,
                borderColor: null,
                borderRadius: 0,
                borderWidth: 0,
                clamp: !1,
                clip: !1,
                color: void 0,
                display: !0,
                font: {
                    family: void 0,
                    lineHeight: 1.2,
                    size: void 0,
                    style: void 0,
                    weight: null
                },
                formatter: function(t) {
                    if (or(t)) return null;
                    var e, i, n, s = t;
                    if (rr(t))
                        if (or(t.label))
                            if (or(t.r))
                                for (s = "", n = 0, i = (e = Object.keys(t)).length; n < i; ++n) s += (0 !== n ? ", " : "") + e[n] + ": " + t[e[n]];
                            else s = t.r;
                    else s = t.label;
                    return "" + s
                },
                labels: void 0,
                listeners: {},
                offset: 4,
                opacity: 1,
                padding: {
                    top: 4,
                    right: 4,
                    bottom: 4,
                    left: 4
                },
                rotation: 0,
                textAlign: "start",
                textStrokeColor: void 0,
                textStrokeWidth: 0,
                textShadowBlur: 0,
                textShadowColor: void 0
            },
            beforeInit: function(t) {
                t[lf] = {
                    _actives: []
                }
            },
            beforeUpdate: function(t) {
                t = t[lf];
                t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = []
            },
            afterDatasetUpdate: function(t, n, e) {
                var i, s, o, a, r, l, c, h, d, u, p, f = n.index,
                    g = t[lf],
                    _ = g._datasets[f] = [],
                    m = t.isDatasetVisible(f),
                    v = t.data.datasets[f],
                    b = (s = e, e = (i = v).datalabels, i = {}, !(a = []) === e ? null : (s = vr({}, [s, e = !0 === e ? {} : e]), o = s.labels || {}, e = Object.keys(o), delete s.labels, e.length ? e.forEach(function(t) {
                        o[t] && a.push(vr({}, [s, o[t], {
                            _key: t
                        }]))
                    }) : a.push(s), i = a.reduce(function(i, n) {
                        return pr(n.listeners || {}, function(t, e) {
                            i[e] = i[e] || {}, i[e][n._key || "$default"] = t
                        }), delete n.listeners, i
                    }, {}), {
                        labels: a,
                        listeners: i
                    })),
                    y = n.meta.data || [],
                    x = t.ctx;
                for (x.save(), r = 0, c = y.length; r < c; ++r)
                    if ((u = y[r])[lf] = [], m && u && t.getDataVisibility(r) && !u.skip)
                        for (l = 0, h = b.labels.length; l < h; ++l) d = (p = b.labels[l])._key, (p = new Zp(p, x, u, r)).$groups = {
                            _set: f,
                            _key: d || "$default"
                        }, p.$context = {
                            active: !1,
                            chart: t,
                            dataIndex: r,
                            dataset: v,
                            datasetIndex: f
                        }, p.update(p.$context), u[lf].push(p), _.push(p);
                x.restore(), vr(g._listeners, b.listeners, {
                    merger: function(t, e, i) {
                        e[t] = e[t] || {}, e[t][n.index] = i[t], g._listened = !0
                    }
                })
            },
            afterUpdate: function(t, e) {
                t[lf]._labels = rf.prepare(t[lf]._datasets, e)
            },
            afterDatasetsDraw: function(t) {
                rf.draw(t, t[lf]._labels)
            },
            beforeEvent: function(t, e) {
                if (t[lf]._listened) {
                    var i = e.event;
                    switch (i.type) {
                        case "mousemove":
                        case "mouseout":
                            hf(t, i);
                            break;
                        case "click":
                            s = i, o = (n = t)[lf], a = o._listeners.click, (s = a && rf.lookup(o._labels, s)) && cf(n, a, s)
                    }
                }
                var n, s, o, a
            },
            afterEvent: function(t) {
                for (var e, i, n, s, o, a = t[lf], r = a._actives, l = a._actives = t.getActiveElements(), c = Rp(r, l), h = 0, d = c.length; h < d; ++h)
                    if ((n = c[h])[1])
                        for (i = (o = n[e = 0].element[lf] || []).length; e < i; ++e)(s = o[e]).$context.active = 1 === n[1], s.update(s.$context);
                (a._dirty || c.length) && (rf.update(a._labels), t.render()), delete a._dirty
            }
        };
        au.register(pu, wu, Iu, ku, Ih, Dh, Lh, Ph, Bh, Rh, Nh, Hh, lp, up, fp, yp, Ap, Op, St, $t, Ae, e, Rt, Ot);
        const uf = i(106),
            pf = "chart",
            ff = "mdb.chart",
            gf = {
                line: {
                    options: {
                        elements: {
                            line: {
                                backgroundColor: "rgba(59, 112, 202, 0.0)",
                                borderColor: "rgb(59, 112, 202)",
                                borderWidth: 2,
                                tension: 0
                            },
                            point: {
                                borderColor: "rgb(59, 112, 202)",
                                backgroundColor: "rgb(59, 112, 202)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        },
                        tooltips: {
                            intersect: !1,
                            mode: "index"
                        },
                        datasets: {
                            borderColor: "red"
                        },
                        scales: {
                            x: {
                                stacked: !0,
                                grid: {
                                    display: !1
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            },
                            y: {
                                stacked: !1,
                                grid: {
                                    borderDash: [2],
                                    drawBorder: !1,
                                    zeroLineColor: "rgba(0,0,0,0)",
                                    zeroLineBorderDash: [2],
                                    zeroLineBorderDashOffset: [2]
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            }
                        }
                    }
                },
                bar: {
                    options: {
                        backgroundColor: "rgb(59, 112, 202)",
                        borderWidth: 0,
                        responsive: !0,
                        legend: {
                            display: !0
                        },
                        tooltips: {
                            intersect: !1,
                            mode: "index"
                        },
                        scales: {
                            x: {
                                stacked: !0,
                                grid: {
                                    display: !1
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            },
                            y: {
                                stacked: !0,
                                grid: {
                                    borderDash: [2],
                                    drawBorder: !1,
                                    zeroLineColor: "rgba(0,0,0,0)",
                                    zeroLineBorderDash: [2],
                                    zeroLineBorderDashOffset: [2]
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            }
                        }
                    }
                },
                pie: {
                    options: {
                        elements: {
                            arc: {
                                backgroundColor: "rgb(59, 112, 202)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        }
                    }
                },
                doughnut: {
                    options: {
                        elements: {
                            arc: {
                                backgroundColor: "rgb(59, 112, 202)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        }
                    }
                },
                polarArea: {
                    options: {
                        elements: {
                            arc: {
                                backgroundColor: "rgba(59, 112, 202, 0.5)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        }
                    }
                },
                radar: {
                    options: {
                        elements: {
                            line: {
                                backgroundColor: "rgba(59, 112, 202, 0.5)",
                                borderColor: "rgb(59, 112, 202)",
                                borderWidth: 2
                            },
                            point: {
                                borderColor: "rgb(59, 112, 202)",
                                backgroundColor: "rgb(59, 112, 202)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        }
                    }
                },
                scatter: {
                    options: {
                        elements: {
                            line: {
                                backgroundColor: "rgba(59, 112, 202, 0.5)",
                                borderColor: "rgb(59, 112, 202)",
                                borderWidth: 2,
                                tension: 0
                            },
                            point: {
                                borderColor: "rgb(59, 112, 202)",
                                backgroundColor: "rgba(59, 112, 202, 0.5)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        },
                        tooltips: {
                            intersect: !1,
                            mode: "index"
                        },
                        datasets: {
                            borderColor: "red"
                        },
                        scales: {
                            x: {
                                stacked: !0,
                                grid: {
                                    display: !1
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            },
                            y: {
                                stacked: !1,
                                grid: {
                                    borderDash: [2],
                                    drawBorder: !1,
                                    zeroLineColor: "rgba(0,0,0,0)",
                                    zeroLineBorderDash: [2],
                                    zeroLineBorderDashOffset: [2]
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            }
                        }
                    }
                },
                bubble: {
                    options: {
                        elements: {
                            point: {
                                borderColor: "rgb(59, 112, 202)",
                                backgroundColor: "rgba(59, 112, 202, 0.5)"
                            }
                        },
                        responsive: !0,
                        legend: {
                            display: !0
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: !1
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            },
                            y: {
                                grid: {
                                    borderDash: [2],
                                    drawBorder: !1,
                                    zeroLineColor: "rgba(0,0,0,0)",
                                    zeroLineBorderDash: [2],
                                    zeroLineBorderDashOffset: [2]
                                },
                                ticks: {
                                    fontColor: "rgba(0,0,0, 0.5)"
                                }
                            }
                        }
                    }
                }
            },
            _f = (t, e, i) => {
                return uf(i[e], t, {
                    arrayMerge: (i, t, n) => {
                        const s = i.slice();
                        return t.forEach((t, e) => {
                            void 0 === s[e] ? s[e] = n.cloneUnlessOtherwiseSpecified(t, n) : n.isMergeableObject(t) ? s[e] = uf(i[e], t, n) : -1 === i.indexOf(t) && s.push(t)
                        }), s
                    }
                })
            };
        class mf {
            constructor(t, e, i = {}) {
                this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._element && (p.setData(t, ff, this), P.addClass(this._element, "chart"), this._chartConstructor())
            }
            static get NAME() {
                return pf
            }
            dispose() {
                p.removeData(this._element, ff), this._element = null
            }
            update(t, e) {
                this._data = { ...this._data,
                    ...t
                }, this._chart.data = this._data, this._options = { ...this._options,
                    ...e
                }, this._chart.options = uf(this._chart.options, this._options), this._chart.update()
            }
            _chartConstructor() {
                if (this._data) {
                    this._createCanvas();
                    var t = _f(this._options, this._type, gf);
                    const e = [];
                    t.dataLabelsPlugin && e.push(df), this._chart = new au(this._canvas, { ...this._data,
                        ...t,
                        plugins: e
                    })
                }
            }
            _createCanvas() {
                this._canvas || ("CANVAS" === this._element.nodeName ? this._canvas = this._element : (this._canvas = y("canvas"), this._element.appendChild(this._canvas)))
            }
            static jQueryInterface(i, n, s) {
                return this.each(function() {
                    let t = p.getData(this, ff);
                    var e;
                    if ((t || !/dispose/.test(i)) && (t || (e = n ? _f(n, s, gf) : gf[s], t = new mf(this, { ...i,
                            ...e
                        })), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n, s)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, ff)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        const vf = t => "{" === t[0] && "}" === t[t.length - 1] || "[" === t[0] && "]" === t[t.length - 1],
            bf = i => {
                const n = {};
                return Object.keys(i).forEach(t => {
                    var e;
                    t.match(/dataset.*/) && (e = t.slice(7, 8).toLowerCase().concat(t.slice(8)), n[e] = "string" == typeof(t = i[t]) && vf(t) ? JSON.parse(t.replace(/'/g, '"')) : t)
                }), n
            };
        R.find("[data-mdb-chart]").forEach(t => {
            if ("bubble" === P.getDataAttribute(t, "chart") || "scatter" === P.getDataAttribute(t, "chart")) return null; {
                const e = P.getDataAttributes(t),
                    i = {
                        data: {
                            datasets: [bf(e)]
                        }
                    };
                return e.chart && (i.type = e.chart), e.labels && (i.data.labels = JSON.parse(e.labels.replace(/'/g, '"'))), new mf(t, { ...i,
                    ...gf[i.type]
                })
            }
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[pf];
                t.fn[pf] = mf.jQueryInterface, t.fn[pf].Constructor = mf, t.fn[pf].noConflict = () => (t.fn[pf] = e, mf.jQueryInterface)
            }
        });
        var yf = mf;
        i(74), i(82);
        const xf = "lightbox",
            wf = "mdb.lightbox",
            Cf = "lightbox",
            kf = "lightbox-gallery-caption",
            Tf = "fontawesome-pro",
            Sf = ".".concat(Cf, " img:not(.lightbox-disabled)"),
            Ef = {
                container: "string",
                zoomLevel: "(number|string)",
                fontAwesome: "string"
            },
            Af = {
                container: "body",
                zoomLevel: 1,
                fontAwesome: "free"
            };
        class Mf {
            constructor(t, e = {}) {
                this._element = t, this._options = e, this._getContainer(), this._id = "lightbox-".concat(Math.random().toString(36).substr(2, 9)), this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (p.setData(t, wf, this), this.init())
            }
            static get NAME() {
                return xf
            }
            get activeImg() {
                return this._activeImg
            }
            get currentImg() {
                return R.findOne(".active", this._galleryContent)
            }
            get options() {
                var t = { ...Af,
                    ...P.getDataAttributes(this._element),
                    ...this._options
                };
                return a(xf, t, Ef), t
            }
            init() {
                this._initiated || (this._appendTemplate(), this._initiated = !0)
            }
            open(t = 0) {
                this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then(t => {
                    this._resizeImages(t), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn()
                })
            }
            close() {
                this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed")
            }
            slide(t = "right") {
                !0 === this._animating || this._images.length <= 1 || (this._triggerEvents("slide", "slided"), this._beforeSlideEvents(), "right" === t && this._slideHorizontally(t), "left" === t && this._slideHorizontally(t), "first" === t && this._slideToTarget(t), "last" === t && this._slideToTarget(t), this._afterSlideEvents())
            }
            zoomIn() {
                3 <= this._zoom || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), P.style(this.currentImg.parentNode, {
                    transform: "scale(".concat(this._zoom, ")")
                }), this._updateZoomBtn())
            }
            zoomOut() {
                this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), P.style(this.currentImg.parentNode, {
                    transform: "scale(".concat(this._zoom, ")")
                }), this._updateZoomBtn(), this._updateImgPosition())
            }
            toggleFullscreen() {
                !1 === this._fullscreen ? (P.addClass(this._fullscreenBtn, "active"), this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (P.removeClass(this._fullscreenBtn, "active"), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1)
            }
            reset() {
                this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer)
            }
            dispose() {
                I.off(document, "click", Sf, this.toggle), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), p.removeData(this._element, wf), this._element = null
            }
            _getImages() {
                const t = R.find("img", this._element);
                var e = t.filter(t => !t.classList.contains("lightbox-disabled"));
                this._images = e
            }
            _getContainer() {
                this._container = R.findOne(this.options.container)
            }
            _setActiveImg(t) {
                this._activeImg = "number" == typeof t ? t : this._images.indexOf(t.target)
            }
            _appendTemplate() {
                this._gallery = y("div"), P.addClass(this._gallery, "lightbox-gallery"), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery)
            }
            _appendToolbar() {
                this._galleryToolbar = y("div"), this._imgCounter = y("p"), this._fullscreenBtn = y("button"), this._zoomBtn = y("button");
                const t = y("div"),
                    e = y("div"),
                    i = y("button");
                P.addClass(this._galleryToolbar, "lightbox-gallery-toolbar"), P.addClass(this._imgCounter, "lightbox-gallery-counter"), P.addClass(this._fullscreenBtn, "lightbox-gallery-fullscreen-btn"), P.addClass(this._zoomBtn, "lightbox-gallery-zoom-btn"), P.addClass(t, "lightbox-gallery-left-tools"), P.addClass(e, "lightbox-gallery-right-tools"), P.addClass(i, "lightbox-gallery-close-btn"), "pro" === this.options.fontAwesome && (P.addClass(this._fullscreenBtn, Tf), P.addClass(this._zoomBtn, Tf), P.addClass(i, Tf)), this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), i.setAttribute("aria-label", "Close"), I.on(this._fullscreenBtn, "click", () => this.toggleFullscreen()), I.on(this._zoomBtn, "click", () => this._toggleZoom()), I.on(i, "click", () => this.close()), t.append(this._imgCounter), e.append(this._fullscreenBtn), e.append(this._zoomBtn), e.append(i), this._galleryToolbar.append(t), this._galleryToolbar.append(e), this._gallery.append(this._galleryToolbar)
            }
            _appendContent() {
                this._galleryContent = y("div"), P.addClass(this._galleryContent, "lightbox-gallery-content"), this._gallery.append(this._galleryContent)
            }
            _appendLoader() {
                this._loader = y("div");
                const t = y("div"),
                    e = y("span");
                P.addClass(this._loader, "lightbox-gallery-loader"), P.addClass(t, "spinner-grow"), P.addClass(t, "text-light"), P.addClass(e, "sr-only"), t.setAttribute("role", "status"), e.innerHTML = "Loading...", t.append(e), this._loader.append(t), this._gallery.append(this._loader)
            }
            _appendArrows() {
                this._leftArrowWrapper = y("div"), P.addClass(this._leftArrowWrapper, "lightbox-gallery-arrow-left");
                const t = y("button");
                t.setAttribute("aria-label", "Previous"), I.on(t, "click", () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = y("div"), P.addClass(this._rightArrowWrapper, "lightbox-gallery-arrow-right"), this._rightArrow = y("button"), this._rightArrow.setAttribute("aria-label", "Next"), I.on(this._rightArrow, "click", () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), "pro" === this.options.fontAwesome && (P.addClass(t, Tf), P.addClass(this._rightArrow, Tf)), this._getImages(), this._images.length <= 1 || (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper))
            }
            _appendCaption() {
                const t = y("div");
                var e = y("p");
                P.addClass(t, "lightbox-gallery-caption-wrapper"), P.addClass(e, kf), t.append(e), this._gallery.append(t)
            }
            _sortImages() {
                for (let t = 0; t < this._activeImg; t++) this._images.push(this._images.shift())
            }
            async _loadImages() {
                const t = [],
                    o = [];
                this._galleryContent.innerHTML = "";
                let a = 0;
                return this._images.forEach((n, s) => {
                    t.push(new Promise(t => {
                        const e = new Image,
                            i = y("div");
                        P.addClass(i, "lightbox-gallery-image"), this._addImgStyles(e, i, a, s, n), i.append(e), this._galleryContent.append(i), e.onload = t, e.src = n.dataset.mdbImg || n.src, o.push(e), a += 100
                    }))
                }), await Promise.all(t), o
            }
            _addImgStyles(t, e, i, n, s) {
                t.alt = s.alt, t.draggable = !1, P.style(e, {
                    position: "absolute",
                    left: "".concat(i, "%"),
                    top: 0
                }), !s.dataset.mdbCaption && "" !== s.dataset.mdbCaption || (t.dataset.caption = s.dataset.mdbCaption), 0 === i ? (t.width < t.height && P.addClass(t, "vertical"), P.style(e, {
                    opacity: 1
                }), P.addClass(t, "active")) : P.removeClass(t, "active"), n === this._images.length - 1 && 1 < this._images.length && P.style(e, {
                    left: "-100%"
                })
            }
            _resizeImages(t) {
                t.forEach(t => {
                    this._calculateImgSize(t)
                })
            }
            _calculateImgSize(t) {
                t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = "".concat((t.parentNode.offsetHeight - t.height) / 2, "px"), t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = "".concat((t.parentNode.offsetWidth - t.width) / 2, "px"), t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = "".concat(t.parentNode.offsetWidth, "px"), t.style.height = "auto", t.style.left = 0, t.style.top = "".concat((t.parentNode.offsetHeight - t.height) / 2, "px")), t.height >= t.parentNode.offsetHeight && (t.style.height = "".concat(t.parentNode.offsetHeight, "px"), t.style.width = "auto", t.style.top = 0, t.style.left = "".concat((t.parentNode.offsetWidth - t.width) / 2, "px")), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0
            }
            _onResize() {
                this._images = R.find("img", this._galleryContent), this._images.forEach(t => {
                    this._calculateImgSize(t)
                })
            }
            _onFullscreenChange() {
                void 0 === (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) && (this._fullscreen = !1, P.removeClass(this._fullscreenBtn, "active"))
            }
            _beforeSlideEvents() {
                this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap()
            }
            _slideHorizontally(i) {
                this._images = R.find("img", this._galleryContent), this._images.forEach(t => {
                    let e;
                    "right" === i ? (e = parseInt(t.parentNode.style.left, 10) - 100, e < -100 && (e = 100 * (this._images.length - 2))) : (e = parseInt(t.parentNode.style.left, 10) + 100, e === 100 * (this._images.length - 1) && (e = -100)), this._slideImg(t, e)
                }), this._updateActiveImg(i)
            }
            _slideImg(t, e) {
                0 === e ? (P.addClass(t, "active"), P.style(t.parentNode, {
                    opacity: 1,
                    transform: "scale(1)"
                })) : (P.removeClass(t, "active"), P.style(t.parentNode, {
                    opacity: 0,
                    transform: "scale(0.25)"
                })), t.parentNode.style.left = "".concat(e, "%")
            }
            _slideToTarget(t) {
                "first" === t && 0 === this._activeImg || "last" === t && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = "first" === t ? 0 : this._images.length - 1, this._sortImages(), P.style(this.currentImg.parentNode, {
                    transform: "scale(0.25)",
                    opacity: 0
                }), setTimeout(() => {
                    this._loadImages().then(t => {
                        this._resizeImages(t), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
                            P.style(this.currentImg.parentNode, {
                                transform: "scale(1)",
                                opacity: 1
                            })
                        }, 10)
                    })
                }, 400))
            }
            _updateActiveImg(t) {
                "right" === t && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), "left" === t && (0 === this._activeImg ? this._activeImg = this._images.length - 1 : this._activeImg--)
            }
            _afterSlideEvents() {
                this._updateCounter(), this._updateCaption()
            }
            _updateCounter() {
                this._images.length <= 1 || setTimeout(() => {
                    this._imgCounter.innerHTML = "".concat(this._activeImg + 1, " / ").concat(this._images.length)
                }, 200)
            }
            _updateCaption() {
                setTimeout(() => {
                    let t = this.currentImg.alt;
                    !this.currentImg.dataset.caption && "" !== this.currentImg.dataset.caption || (t = this.currentImg.dataset.caption), R.findOne(".".concat(kf), this._gallery).innerHTML = t
                }, 200)
            }
            _toggleTemplate() {
                "visible" === this._gallery.style.visibility ? (P.style(this.currentImg.parentNode, {
                    transform: "scale(0.25)"
                }), setTimeout(() => {
                    this._hideGallery(), this._enableScroll(), this._showLoader()
                }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader())
            }
            _showLoader() {
                P.style(this._loader, {
                    opacity: 1
                })
            }
            _hideLoader() {
                P.style(this._loader, {
                    opacity: 0
                })
            }
            _hideGallery() {
                P.style(this._gallery, {
                    opacity: 0,
                    pointerEvents: "none",
                    visibility: "hidden"
                })
            }
            _showGallery() {
                P.style(this._gallery, {
                    opacity: 1,
                    pointerEvents: "initial",
                    visibility: "visible"
                }), setTimeout(() => {
                    P.style(this.currentImg.parentNode, {
                        transform: "scale(1)"
                    })
                }, 50)
            }
            _toggleZoom() {
                1 !== this._zoom ? this._restoreDefaultZoom() : this.zoomIn()
            }
            _updateZoomBtn() {
                1 < this._zoom ? (P.addClass(this._zoomBtn, "active"), this._zoomBtn.setAttribute("aria-label", "Zoom out")) : (P.removeClass(this._zoomBtn, "active"), this._zoomBtn.setAttribute("aria-label", "Zoom in"))
            }
            _updateImgPosition() {
                1 === this._zoom && this._restoreDefaultPosition()
            }
            _addEvents() {
                const t = R.find("img", this._galleryContent);
                this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach(t => {
                    I.on(t, "mousedown", this._onImgMousedown, {
                        passive: !0
                    }), I.on(t, "touchstart", this._onImgMousedown, {
                        passive: !0
                    }), I.on(t, "mousemove", this._onImgMousemove, {
                        passive: !0
                    }), I.on(t, "touchmove", this._onImgMousemove, {
                        passive: !0
                    }), I.on(t, "wheel", this._onImgWheel, {
                        passive: !0
                    }), I.on(t, "dblclick", this._onImgDoubleClick, {
                        passive: !0
                    })
                }), document.addEventListener("touchmove", this._onWindowTouchmove, {
                    passive: !1
                }), I.on(window, "touchstart", this._onWindowTouchstart), I.on(window, "mouseup", this._onImgMouseup), I.on(window, "touchend", this._onImgTouchend), I.on(window, "resize", this._onWindowResize), I.on(window, "orientationchange", this._onWindowResize), I.on(window, "keyup", this._onKeyupEvent), I.on(window, "fullscreenchange", this._onWindowFullscreenChange), I.on(this._gallery, "mousemove", this._onAnyImgAction), I.on(this._gallery, "click", this._onGalleryClick), I.on(this._rightArrow, "keydown", this._onRightArrowKeydownEvent), I.on(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent)
            }
            _removeEvents() {
                const t = R.find("img", this._galleryContent);
                t.forEach(t => {
                    I.off(t, "mousedown", this._onImgMousedown), I.off(t, "touchstart", this._onImgMousedown), I.off(t, "mousemove", this._onImgMousemove), I.off(t, "touchmove", this._onImgMousemove), I.off(t, "wheel", this._onImgWheel), I.off(t, "dblclick", this._onImgDoubleClick)
                }), document.removeEventListener("touchmove", this._onWindowTouchmove, {
                    passive: !1
                }), I.off(window, "touchstart", this._onWindowTouchstart), I.off(window, "mouseup", this._onImgMouseup), I.off(window, "touchend", this._onImgTouchend), I.off(window, "resize", this._onWindowResize), I.off(window, "orientationchange", this._onWindowResize), I.off(window, "keyup", this._onKeyupEvent), I.off(window, "fullscreenchange", this._onWindowFullscreenChange), I.off(this._gallery, "mousemove", this._onAnyImgAction), I.off(this._gallery, "click", this._onGalleryClick), I.off(this._rightArrow, "keydown", this._onRightArrowKeydownEvent), I.off(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent)
            }
            _onMousedown(t) {
                var e = t.touches,
                    i = (e ? e[0] : t).clientX,
                    e = (e ? e[0] : t).clientY;
                this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = e * (1 / this._zoom) - this._positionY, this._mousedown = !0, "touchstart" === t.type && 1 < t.touches.length && (this._multitouch = !0, this._touchZoomPosition = t.touches)
            }
            _onMousemove(t) {
                var e, i;
                this._mousedown && (i = ((e = t.touches) ? e[0] : t).clientX, t = (e ? e[0] : t).clientY, e && this._resetToolsToggler(), this._multitouch || (1 !== this._zoom ? (this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = t * (1 / this._zoom) - this._mousedownPositionY, P.style(this.currentImg, {
                    left: "".concat(this._positionX, "px"),
                    top: "".concat(this._positionY, "px")
                })) : this._images.length <= 1 || (this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, P.style(this.currentImg, {
                    left: "".concat(this._positionX, "px")
                }))))
            }
            _onMouseup(t) {
                this._mousedown = !1, this._moveImg(t.target)
            }
            _onTouchend(t) {
                this._mousedown = !1, this._multitouch ? 0 === t.targetTouches.length && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target))
            }
            _calculateTouchZoom(t) {
                var e = Math.hypot(this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX, this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY),
                    i = Math.hypot(t.touches[1].pageX - t.touches[0].pageX, t.touches[1].pageY - t.touches[0].pageY),
                    n = Math.abs(e - i);
                .03 * t.view.screen.width < n && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches)
            }
            _onWindowTouchstart(t) {
                1 < t.touches.length && (this._multitouch = !0, this._touchZoomPosition = t.touches)
            }
            _onWindowTouchmove(t) {
                t.preventDefault(), "touchmove" === t.type && 1 < t.targetTouches.length && this._calculateTouchZoom(t)
            }
            _onRightArrowKeydown(t) {
                switch (t.keyCode) {
                    case 9:
                        if (t.shiftKey) break;
                        t.preventDefault(), this._focusFullscreenBtn()
                }
            }
            _onFullscreenBtnKeydown(t) {
                switch (t.keyCode) {
                    case 9:
                        if (!t.shiftKey) break;
                        t.preventDefault(), this._focusRightArrow()
                }
            }
            _onKeyup(t) {
                switch (this._resetToolsToggler(), t.keyCode) {
                    case 39:
                        h ? this.slide("left") : this.slide();
                        break;
                    case 37:
                        h ? this.slide() : this.slide("left");
                        break;
                    case 27:
                        this.close();
                        break;
                    case 36:
                        this.slide("first");
                        break;
                    case 35:
                        this.slide("last");
                        break;
                    case 38:
                        this.zoomIn();
                        break;
                    case 40:
                        this.zoomOut()
                }
            }
            _focusFullscreenBtn() {
                setTimeout(() => {
                    this._fullscreenBtn.focus()
                }, 100)
            }
            _focusRightArrow() {
                this._rightArrow.focus()
            }
            _moveImg(t) {
                this._multitouch || 1 !== this._zoom || t !== this.currentImg || this._images.length <= 1 || (0 < (t = this._positionX - this._originalPositionX) ? h ? this.slide() : this.slide("left") : t < 0 && (h ? this.slide("left") : this.slide()))
            }
            _checkDoubleTap(t) {
                clearTimeout(this._doubleTapTimer);
                var e = (new Date).getTime() - this._tapTime;
                0 < this._tapCounter && e < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
                    this._tapTime = (new Date).getTime(), this._tapCounter = 0
                }, 300)) : (this._tapCounter++, this._tapTime = (new Date).getTime())
            }
            _resetDoubleTap() {
                this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer)
            }
            _onDoubleClick(t) {
                this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), 1 !== this._zoom ? this._restoreDefaultZoom() : this.zoomIn())
            }
            _onZoom(t) {
                0 < t.deltaY ? this.zoomOut() : 3 <= this._zoom || (this._setNewPositionOnZoomIn(t), this.zoomIn())
            }
            _onBackdropClick(t) {
                this._resetToolsToggler(), "DIV" === t.target.tagName && this.close()
            }
            _setNewPositionOnZoomIn(t) {
                clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = "".concat(this._positionX, "px"), this.currentImg.style.top = "".concat(this._positionY, "px"), this._zoomTimer = setTimeout(() => {
                    this.currentImg.style.transition = "none"
                }, 500)
            }
            _resetToolsToggler() {
                this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout()
            }
            _setToolsToggleTimout() {
                this._toolsToggleTimer = setTimeout(() => {
                    this._hideTools(), clearTimeout(this._toolsToggleTimer)
                }, 4e3)
            }
            _hideTools() {
                P.style(this._galleryToolbar, {
                    opacity: 0
                }), P.style(this._leftArrowWrapper, {
                    opacity: 0
                }), P.style(this._rightArrowWrapper, {
                    opacity: 0
                })
            }
            _showTools() {
                P.style(this._galleryToolbar, {
                    opacity: 1
                }), P.style(this._leftArrowWrapper, {
                    opacity: 1
                }), P.style(this._rightArrowWrapper, {
                    opacity: 1
                })
            }
            _disableScroll() {
                P.addClass(document.body, "disabled-scroll"), document.documentElement.scrollHeight > document.documentElement.clientHeight && P.addClass(document.body, "replace-scrollbar")
            }
            _enableScroll() {
                setTimeout(() => {
                    P.removeClass(document.body, "disabled-scroll"), P.removeClass(document.body, "replace-scrollbar")
                }, 300)
            }
            _animationStart() {
                this._animating = !0, setTimeout(() => {
                    this._animating = !1
                }, 400)
            }
            _restoreDefaultZoom() {
                1 !== this._zoom && (this._zoom = 1, P.style(this.currentImg.parentNode, {
                    transform: "scale(".concat(this._zoom, ")")
                }), this._updateZoomBtn(), this._updateImgPosition())
            }
            _restoreDefaultFullscreen() {
                this._fullscreen && this.toggleFullscreen()
            }
            _restoreDefaultPosition() {
                clearTimeout(this._zoomTimer);
                var t = this.currentImg;
                P.style(this.currentImg.parentNode, {
                    left: 0,
                    top: 0
                }), P.style(this.currentImg, {
                    transition: "all 0.5s ease-out",
                    left: 0,
                    top: 0
                }), this._calculateImgSize(t), setTimeout(() => {
                    P.style(this.currentImg, {
                        transition: "none"
                    })
                }, 500)
            }
            async _triggerEvents(t, e) {
                I.trigger(this._element, "".concat(t, ".mdb.lightbox")), e && await setTimeout(() => {
                    I.trigger(this._element, "".concat(e, ".mdb.lightbox"))
                }, 505)
            }
            static getInstance(t) {
                return p.getData(t, wf)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static toggle() {
                return function(t) {
                    var e = R.closest(t.target, ".".concat(Cf));
                    const i = Mf.getInstance(e) || new Mf(e);
                    i.open(t)
                }
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, wf);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Mf(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
        }
        R.find(".".concat(Cf)).forEach(t => new Mf(t)), I.on(document, "click", Sf, Mf.toggle()), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[xf];
                t.fn[xf] = Mf.jQueryInterface, t.fn[xf].Constructor = Mf, t.fn[xf].noConflict = () => (t.fn[xf] = e, Mf.jQueryInterface)
            }
        });
        var Of = Mf;
        const If = "rating",
            Df = "mdb.rating";
        Ot = ".".concat(Df);
        const Lf = {
                tooltip: "string",
                value: "(string|number)",
                readonly: "boolean",
                after: "string",
                before: "string",
                dynamic: "boolean"
            },
            Pf = {
                tooltip: "top",
                value: "",
                readonly: !1,
                after: "",
                before: "",
                dynamic: !1
            },
            Rf = "onSelect".concat(Ot),
            Bf = "onHover".concat(Ot),
            Nf = "keyup".concat(Ot),
            Hf = "focusout".concat(Ot),
            jf = "keydown".concat(Ot),
            Wf = "mousedown".concat(Ot);
        class Ff {
            constructor(t, e) {
                this._element = t, this._icons = R.find("i", this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._fn = {}, this._tooltips = [], this._element && (p.setData(t, Df, this), this._init())
            }
            static get NAME() {
                return If
            }
            dispose() {
                p.removeData(this._element, Df), this._options.readonly || (I.off(this._element, Nf), I.off(this._element, Hf), I.off(this._element, jf), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
                    I.off(t, Wf), t.removeEventListener("mouseenter", this._fn.mouseenter[e])
                }), this._tooltips.forEach(t => {
                    t.dispose()
                }), this._element.removeAttribute("tabIndex")), this._element = null
            }
            _init() {
                this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost()), this._options.dynamic && this._saveOriginalClassList(), this._setCustomText(), this._setCustomColor(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index))
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...Pf,
                    ...e,
                    ...t
                }, a(If, t, Lf), t
            }
            _bindMouseEnter() {
                this._fn.mouseenter = [], this._icons.forEach((e, t) => {
                    e.addEventListener("mouseenter", this._fn.mouseenter[t] = t => {
                        this._index = this._icons.indexOf(t.target), this._updateRating(this._index), this._triggerEvents(e, Bf)
                    })
                })
            }
            _bindMouseLeave() {
                this._element.addEventListener("mouseleave", this._fn.mouseleave = () => {
                    null !== this._savedIndex ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : (this._index = -1, this._clearRating())
                })
            }
            _bindMouseDown() {
                this._icons.forEach(t => {
                    I.on(t, Wf, () => {
                        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, Rf)
                    })
                })
            }
            _bindKeyDown() {
                this._element.tabIndex = 0, I.on(this._element, jf, t => this._updateAfterKeyDown(t))
            }
            _bindKeyUp() {
                I.on(this._element, Nf, () => this._setElementOutline("auto"))
            }
            _bindFocusLost() {
                I.on(this._element, Hf, () => this._setElementOutline("none"))
            }
            _setElementOutline(t) {
                this._element.style.outline = t
            }
            _triggerEvents(t, e) {
                I.trigger(t, e, {
                    value: this._index + 1
                })
            }
            _updateAfterKeyDown(t) {
                var e = this._icons.length - 1,
                    i = this._index;
                "ArrowRight" === t.key && this._index < e && (this._index += 1), "ArrowLeft" === t.key && -1 < this._index && --this._index, i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Rf))
            }
            _updateRating(i) {
                this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(i), this._icons.forEach((t, e) => {
                    e <= i && (t.classList.add("fas", "active"), t.classList.remove("far"))
                })
            }
            _clearRating() {
                this._icons.forEach((t, e) => {
                    this._options.dynamic ? t.classList = this._originalClassList[e] : (t.classList.remove("fas", "active"), t.classList.add("far"))
                })
            }
            _setToolTips() {
                this._icons.forEach((t, e) => {
                    var i = P.getDataAttribute(t, "toggle");
                    t.title && !i && (P.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new _s(t, {
                        placement: this._options.tooltip
                    }))
                })
            }
            _setCustomText() {
                this._icons.forEach(t => {
                    var e = P.getDataAttribute(t, "after"),
                        i = P.getDataAttribute(t, "before");
                    e && t.insertAdjacentHTML("afterEnd", e), i && t.insertAdjacentHTML("beforeBegin", i)
                })
            }
            _setCustomColor() {
                this._icons.forEach(t => {
                    var e = P.getDataAttribute(t, "color");
                    e && (t.style.color = e)
                })
            }
            _saveOriginalClassList() {
                this._icons.forEach(t => {
                    t = t.classList.value;
                    this._originalClassList.push(t)
                })
            }
            _restoreOriginalIcon(i) {
                const n = this._originalClassList[i],
                    s = P.getDataAttribute(this._icons[i], "color");
                this._icons.forEach((t, e) => {
                    e <= i && (t.classList = n, t.style.color = s)
                })
            }
            static autoInit(t) {
                return new Ff(t)
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Df);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new Ff(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Df)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find('[data-mdb-toggle="rating"]').forEach(t => {
            Ff.autoInit(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[If];
                t.fn[If] = Ff.jQueryInterface, t.fn[If].Constructor = Ff, t.fn[If].noConflict = () => (t.fn[If] = e, Ff.jQueryInterface)
            }
        });
        var Vf = Ff;
        i(118), i(52);
        /*!
         * perfect-scrollbar v1.5.2
         * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
         * Licensed under MIT
         */
        function zf(t) {
            return getComputedStyle(t)
        }

        function Yf(t, e) {
            for (var i in e) {
                var n = e[i];
                "number" == typeof n && (n += "px"), t.style[i] = n
            }
            return t
        }

        function Xf(t) {
            var e = document.createElement("div");
            return e.className = t, e
        }
        var Uf = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);

        function Kf(t, e) {
            if (!Uf) throw new Error("No element matching method supported");
            return Uf.call(t, e)
        }

        function $f(t) {
            t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t)
        }

        function Qf(t, e) {
            return Array.prototype.filter.call(t.children, function(t) {
                return Kf(t, e)
            })
        }
        var qf = {
                main: "ps",
                rtl: "ps__rtl",
                element: {
                    thumb: function(t) {
                        return "ps__thumb-" + t
                    },
                    rail: function(t) {
                        return "ps__rail-" + t
                    },
                    consuming: "ps__child--consume"
                },
                state: {
                    focus: "ps--focus",
                    clicking: "ps--clicking",
                    active: function(t) {
                        return "ps--active-" + t
                    },
                    scrolling: function(t) {
                        return "ps--scrolling-" + t
                    }
                }
            },
            Zf = {
                x: null,
                y: null
            };

        function Gf(t, e) {
            var i = t.element.classList,
                t = qf.state.scrolling(e);
            i.contains(t) ? clearTimeout(Zf[e]) : i.add(t)
        }

        function Jf(t, e) {
            Zf[e] = setTimeout(function() {
                return t.isAlive && t.element.classList.remove(qf.state.scrolling(e))
            }, t.settings.scrollingThreshold)
        }

        function tg(t) {
            this.element = t, this.handlers = {}
        }
        Ot = {
            isEmpty: {
                configurable: !0
            }
        };
        tg.prototype.bind = function(t, e) {
            void 0 === this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1)
        }, tg.prototype.unbind = function(e, i) {
            var n = this;
            this.handlers[e] = this.handlers[e].filter(function(t) {
                return !(!i || t === i) || (n.element.removeEventListener(e, t, !1), !1)
            })
        }, tg.prototype.unbindAll = function() {
            for (var t in this.handlers) this.unbind(t)
        }, Ot.isEmpty.get = function() {
            var e = this;
            return Object.keys(this.handlers).every(function(t) {
                return 0 === e.handlers[t].length
            })
        }, Object.defineProperties(tg.prototype, Ot);

        function eg() {
            this.eventElements = []
        }

        function ig(t) {
            if ("function" == typeof window.CustomEvent) return new CustomEvent(t);
            var e = document.createEvent("CustomEvent");
            return e.initCustomEvent(t, !1, !1, void 0), e
        }

        function ng(t, e, i, n, s) {
            var o;
            if (void 0 === n && (n = !0), void 0 === s && (s = !1), "top" === e) o = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
            else {
                if ("left" !== e) throw new Error("A proper axis should be provided");
                o = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"]
            }! function(t, e, i, n, s) {
                var o = i[0],
                    a = i[1],
                    r = i[2],
                    l = i[3],
                    c = i[4],
                    h = i[5];
                void 0 === n && (n = !0);
                void 0 === s && (s = !1);
                i = t.element;
                t.reach[l] = null, i[r] < 1 && (t.reach[l] = "start");
                i[r] > t[o] - t[a] - 1 && (t.reach[l] = "end");
                e && (i.dispatchEvent(ig("ps-scroll-" + l)), e < 0 ? i.dispatchEvent(ig("ps-scroll-" + c)) : 0 < e && i.dispatchEvent(ig("ps-scroll-" + h)), n && function(t, e) {
                    Gf(t, e), Jf(t, e)
                }(t, l));
                t.reach[l] && (e || s) && i.dispatchEvent(ig("ps-" + l + "-reach-" + t.reach[l]))
            }(t, i, o, n, s)
        }

        function sg(t) {
            return parseInt(t, 10) || 0
        }
        eg.prototype.eventElement = function(e) {
            var t = this.eventElements.filter(function(t) {
                return t.element === e
            })[0];
            return t || (t = new tg(e), this.eventElements.push(t)), t
        }, eg.prototype.bind = function(t, e, i) {
            this.eventElement(t).bind(e, i)
        }, eg.prototype.unbind = function(t, e, i) {
            t = this.eventElement(t);
            t.unbind(e, i), t.isEmpty && this.eventElements.splice(this.eventElements.indexOf(t), 1)
        }, eg.prototype.unbindAll = function() {
            this.eventElements.forEach(function(t) {
                return t.unbindAll()
            }), this.eventElements = []
        }, eg.prototype.once = function(t, e, i) {
            var n = this.eventElement(t),
                s = function(t) {
                    n.unbind(e, s), i(t)
                };
            n.bind(e, s)
        };
        var og = {
            isWebKit: "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style,
            supportsTouch: "undefined" != typeof window && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && 0 < window.navigator.maxTouchPoints || window.DocumentTouch && document instanceof window.DocumentTouch),
            supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
            isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
        };

        function ag(t) {
            var e = t.element,
                i = Math.floor(e.scrollTop),
                n = e.getBoundingClientRect();
            t.containerWidth = Math.round(n.width), t.containerHeight = Math.round(n.height), t.contentWidth = e.scrollWidth, t.contentHeight = e.scrollHeight, e.contains(t.scrollbarXRail) || (Qf(e, qf.element.rail("x")).forEach($f), e.appendChild(t.scrollbarXRail)), e.contains(t.scrollbarYRail) || (Qf(e, qf.element.rail("y")).forEach($f), e.appendChild(t.scrollbarYRail)), !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0, t.railXWidth = t.containerWidth - t.railXMarginWidth, t.railXRatio = t.containerWidth / t.railXWidth, t.scrollbarXWidth = rg(t, sg(t.railXWidth * t.containerWidth / t.contentWidth)), t.scrollbarXLeft = sg((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1, !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0, t.railYHeight = t.containerHeight - t.railYMarginHeight, t.railYRatio = t.containerHeight / t.railYHeight, t.scrollbarYHeight = rg(t, sg(t.railYHeight * t.containerHeight / t.contentHeight)), t.scrollbarYTop = sg(i * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1, t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth), t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight),
                function(t, e) {
                    var i = {
                            width: e.railXWidth
                        },
                        n = Math.floor(t.scrollTop);
                    e.isRtl ? i.left = e.negativeScrollAdjustment + t.scrollLeft + e.containerWidth - e.contentWidth : i.left = t.scrollLeft;
                    e.isScrollbarXUsingBottom ? i.bottom = e.scrollbarXBottom - n : i.top = e.scrollbarXTop + n;
                    Yf(e.scrollbarXRail, i);
                    n = {
                        top: n,
                        height: e.railYHeight
                    };
                    e.isScrollbarYUsingRight ? e.isRtl ? n.right = e.contentWidth - (e.negativeScrollAdjustment + t.scrollLeft) - e.scrollbarYRight - e.scrollbarYOuterWidth - 9 : n.right = e.scrollbarYRight - t.scrollLeft : e.isRtl ? n.left = e.negativeScrollAdjustment + t.scrollLeft + 2 * e.containerWidth - e.contentWidth - e.scrollbarYLeft - e.scrollbarYOuterWidth : n.left = e.scrollbarYLeft + t.scrollLeft;
                    Yf(e.scrollbarYRail, n), Yf(e.scrollbarX, {
                        left: e.scrollbarXLeft,
                        width: e.scrollbarXWidth - e.railBorderXWidth
                    }), Yf(e.scrollbarY, {
                        top: e.scrollbarYTop,
                        height: e.scrollbarYHeight - e.railBorderYWidth
                    })
                }(e, t), t.scrollbarXActive ? e.classList.add(qf.state.active("x")) : (e.classList.remove(qf.state.active("x")), t.scrollbarXWidth = 0, t.scrollbarXLeft = 0, e.scrollLeft = !0 === t.isRtl ? t.contentWidth : 0), t.scrollbarYActive ? e.classList.add(qf.state.active("y")) : (e.classList.remove(qf.state.active("y")), t.scrollbarYHeight = 0, t.scrollbarYTop = 0, e.scrollTop = 0)
        }

        function rg(t, e) {
            return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)), e = t.settings.maxScrollbarLength ? Math.min(e, t.settings.maxScrollbarLength) : e
        }

        function lg(i, t) {
            var n = t[0],
                s = t[1],
                o = t[2],
                a = t[3],
                e = t[4],
                r = t[5],
                l = t[6],
                c = t[7],
                h = t[8],
                d = i.element,
                u = null,
                p = null,
                f = null;

            function g(t) {
                t.touches && t.touches[0] && (t[o] = t.touches[0].pageY), d[l] = u + f * (t[o] - p), Gf(i, c), ag(i), t.stopPropagation(), t.preventDefault()
            }

            function _() {
                Jf(i, c), i[h].classList.remove(qf.state.clicking), i.event.unbind(i.ownerDocument, "mousemove", g)
            }

            function m(t, e) {
                u = d[l], e && t.touches && (t[o] = t.touches[0].pageY), p = t[o], f = (i[s] - i[n]) / (i[a] - i[r]), e ? i.event.bind(i.ownerDocument, "touchmove", g) : (i.event.bind(i.ownerDocument, "mousemove", g), i.event.once(i.ownerDocument, "mouseup", _), t.preventDefault()), i[h].classList.add(qf.state.clicking), t.stopPropagation()
            }
            i.event.bind(i[e], "mousedown", function(t) {
                m(t)
            }), i.event.bind(i[e], "touchstart", function(t) {
                m(t, !0)
            })
        }
        var cg = {
                "click-rail": function(i) {
                    i.element, i.event.bind(i.scrollbarY, "mousedown", function(t) {
                        return t.stopPropagation()
                    }), i.event.bind(i.scrollbarYRail, "mousedown", function(t) {
                        var e = t.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top > i.scrollbarYTop ? 1 : -1;
                        i.element.scrollTop += e * i.containerHeight, ag(i), t.stopPropagation()
                    }), i.event.bind(i.scrollbarX, "mousedown", function(t) {
                        return t.stopPropagation()
                    }), i.event.bind(i.scrollbarXRail, "mousedown", function(t) {
                        var e = t.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left > i.scrollbarXLeft ? 1 : -1;
                        i.element.scrollLeft += e * i.containerWidth, ag(i), t.stopPropagation()
                    })
                },
                "drag-thumb": function(t) {
                    lg(t, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]), lg(t, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"])
                },
                keyboard: function(o) {
                    var a = o.element;
                    o.event.bind(o.ownerDocument, "keydown", function(t) {
                        if (!(t.isDefaultPrevented && t.isDefaultPrevented() || t.defaultPrevented) && (Kf(a, ":hover") || Kf(o.scrollbarX, ":focus") || Kf(o.scrollbarY, ":focus"))) {
                            var e, i = document.activeElement || o.ownerDocument.activeElement;
                            if (i) {
                                if ("IFRAME" === i.tagName) i = i.contentDocument.activeElement;
                                else
                                    for (; i.shadowRoot;) i = i.shadowRoot.activeElement;
                                if (Kf(e = i, "input,[contenteditable]") || Kf(e, "select,[contenteditable]") || Kf(e, "textarea,[contenteditable]") || Kf(e, "button,[contenteditable]")) return
                            }
                            var n = 0,
                                s = 0;
                            switch (t.which) {
                                case 37:
                                    n = t.metaKey ? -o.contentWidth : t.altKey ? -o.containerWidth : -30;
                                    break;
                                case 38:
                                    s = t.metaKey ? o.contentHeight : t.altKey ? o.containerHeight : 30;
                                    break;
                                case 39:
                                    n = t.metaKey ? o.contentWidth : t.altKey ? o.containerWidth : 30;
                                    break;
                                case 40:
                                    s = t.metaKey ? -o.contentHeight : t.altKey ? -o.containerHeight : -30;
                                    break;
                                case 32:
                                    s = t.shiftKey ? o.containerHeight : -o.containerHeight;
                                    break;
                                case 33:
                                    s = o.containerHeight;
                                    break;
                                case 34:
                                    s = -o.containerHeight;
                                    break;
                                case 36:
                                    s = o.contentHeight;
                                    break;
                                case 35:
                                    s = -o.contentHeight;
                                    break;
                                default:
                                    return
                            }
                            o.settings.suppressScrollX && 0 !== n || o.settings.suppressScrollY && 0 !== s || (a.scrollTop -= s, a.scrollLeft += n, ag(o), function(t, e) {
                                var i = Math.floor(a.scrollTop);
                                if (0 === t) {
                                    if (!o.scrollbarYActive) return;
                                    if (0 === i && 0 < e || i >= o.contentHeight - o.containerHeight && e < 0) return !o.settings.wheelPropagation
                                }
                                if (i = a.scrollLeft, 0 === e) {
                                    if (!o.scrollbarXActive) return;
                                    if (0 === i && t < 0 || i >= o.contentWidth - o.containerWidth && 0 < t) return !o.settings.wheelPropagation
                                }
                                return 1
                            }(n, s) && t.preventDefault())
                        }
                    })
                },
                wheel: function(l) {
                    var c = l.element;

                    function t(t) {
                        var e, i, n, s, o = (n = (i = t).deltaX, s = -1 * i.deltaY, void 0 !== n && void 0 !== s || (n = -1 * i.wheelDeltaX / 6, s = i.wheelDeltaY / 6), i.deltaMode && 1 === i.deltaMode && (n *= 10, s *= 10), n != n && s != s && (n = 0, s = i.wheelDelta), i.shiftKey ? [-s, -n] : [n, s]),
                            a = o[0],
                            r = o[1];
                        ! function(t, e, i) {
                            if (!og.isWebKit && c.querySelector("select:focus")) return 1;
                            if (c.contains(t))
                                for (var n = t; n && n !== c;) {
                                    if (n.classList.contains(qf.element.consuming)) return 1;
                                    var s = zf(n);
                                    if (i && s.overflowY.match(/(scroll|auto)/)) {
                                        var o = n.scrollHeight - n.clientHeight;
                                        if (0 < o && (0 < n.scrollTop && i < 0 || n.scrollTop < o && 0 < i)) return 1
                                    }
                                    if (e && s.overflowX.match(/(scroll|auto)/)) {
                                        s = n.scrollWidth - n.clientWidth;
                                        if (0 < s && (0 < n.scrollLeft && e < 0 || n.scrollLeft < s && 0 < e)) return 1
                                    }
                                    n = n.parentNode
                                }
                        }(t.target, a, r) && (e = !1, l.settings.useBothWheelAxes ? l.scrollbarYActive && !l.scrollbarXActive ? (r ? c.scrollTop -= r * l.settings.wheelSpeed : c.scrollTop += a * l.settings.wheelSpeed, e = !0) : l.scrollbarXActive && !l.scrollbarYActive && (a ? c.scrollLeft += a * l.settings.wheelSpeed : c.scrollLeft -= r * l.settings.wheelSpeed, e = !0) : (c.scrollTop -= r * l.settings.wheelSpeed, c.scrollLeft += a * l.settings.wheelSpeed), ag(l), (e = e || (i = a, n = r, s = Math.floor(c.scrollTop), o = 0 === c.scrollTop, a = s + c.offsetHeight === c.scrollHeight, r = 0 === c.scrollLeft, s = c.scrollLeft + c.offsetWidth === c.scrollWidth, !(s = Math.abs(n) > Math.abs(i) ? o || a : r || s) || !l.settings.wheelPropagation)) && !t.ctrlKey && (t.stopPropagation(), t.preventDefault()))
                    }
                    void 0 !== window.onwheel ? l.event.bind(c, "wheel", t) : void 0 !== window.onmousewheel && l.event.bind(c, "mousewheel", t)
                },
                touch: function(a) {
                    var r, o, l, c, e;

                    function h(t, e) {
                        r.scrollTop -= e, r.scrollLeft -= t, ag(a)
                    }

                    function d(t) {
                        return t.targetTouches ? t.targetTouches[0] : t
                    }

                    function u(t) {
                        return (!t.pointerType || "pen" !== t.pointerType || 0 !== t.buttons) && (t.targetTouches && 1 === t.targetTouches.length || !(!t.pointerType || "mouse" === t.pointerType || t.pointerType === t.MSPOINTER_TYPE_MOUSE))
                    }

                    function t(t) {
                        u(t) && (t = d(t), o.pageX = t.pageX, o.pageY = t.pageY, l = (new Date).getTime(), null !== e && clearInterval(e))
                    }

                    function i(t) {
                        var e, i, n, s;
                        u(t) && (e = (s = {
                            pageX: (n = d(t)).pageX,
                            pageY: n.pageY
                        }).pageX - o.pageX, i = s.pageY - o.pageY, function(t, e, i) {
                            if (r.contains(t))
                                for (var n = t; n && n !== r;) {
                                    if (n.classList.contains(qf.element.consuming)) return 1;
                                    var s = zf(n);
                                    if (i && s.overflowY.match(/(scroll|auto)/)) {
                                        var o = n.scrollHeight - n.clientHeight;
                                        if (0 < o && (0 < n.scrollTop && i < 0 || n.scrollTop < o && 0 < i)) return 1
                                    }
                                    if (e && s.overflowX.match(/(scroll|auto)/)) {
                                        s = n.scrollWidth - n.clientWidth;
                                        if (0 < s && (0 < n.scrollLeft && e < 0 || n.scrollLeft < s && 0 < e)) return 1
                                    }
                                    n = n.parentNode
                                }
                        }(t.target, e, i) || (h(e, i), o = s, 0 < (s = (n = (new Date).getTime()) - l) && (c.x = e / s, c.y = i / s, l = n), function(t, e) {
                            var i = Math.floor(r.scrollTop),
                                n = r.scrollLeft,
                                s = Math.abs(t),
                                o = Math.abs(e);
                            if (s < o) {
                                if (e < 0 && i === a.contentHeight - a.containerHeight || 0 < e && 0 === i) return 0 === window.scrollY && 0 < e && og.isChrome
                            } else if (o < s && (t < 0 && n === a.contentWidth - a.containerWidth || 0 < t && 0 === n)) return 1;
                            return 1
                        }(e, i) && t.preventDefault()))
                    }

                    function n() {
                        a.settings.swipeEasing && (clearInterval(e), e = setInterval(function() {
                            !a.isInitialized && (c.x || c.y) && !(Math.abs(c.x) < .01 && Math.abs(c.y) < .01) && a.element ? (h(30 * c.x, 30 * c.y), c.x *= .8, c.y *= .8) : clearInterval(e)
                        }, 10))
                    }(og.supportsTouch || og.supportsIePointer) && (r = a.element, o = {}, l = 0, c = {}, e = null, og.supportsTouch ? (a.event.bind(r, "touchstart", t), a.event.bind(r, "touchmove", i), a.event.bind(r, "touchend", n)) : og.supportsIePointer && (window.PointerEvent ? (a.event.bind(r, "pointerdown", t), a.event.bind(r, "pointermove", i), a.event.bind(r, "pointerup", n)) : window.MSPointerEvent && (a.event.bind(r, "MSPointerDown", t), a.event.bind(r, "MSPointerMove", i), a.event.bind(r, "MSPointerUp", n))))
                }
            },
            Ot = function(t, e) {
                var i, n = this;
                if (void 0 === e && (e = {}), !(t = "string" == typeof t ? document.querySelector(t) : t) || !t.nodeName) throw new Error("no element is specified to initialize PerfectScrollbar");
                for (i in (this.element = t).classList.add(qf.main), this.settings = {
                        handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
                        maxScrollbarLength: null,
                        minScrollbarLength: null,
                        scrollingThreshold: 1e3,
                        scrollXMarginOffset: 0,
                        scrollYMarginOffset: 0,
                        suppressScrollX: !1,
                        suppressScrollY: !1,
                        swipeEasing: !0,
                        useBothWheelAxes: !1,
                        wheelPropagation: !0,
                        wheelSpeed: 1
                    }, e) this.settings[i] = e[i];
                this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
                var s, o = function() {
                        return t.classList.add(qf.state.focus)
                    },
                    a = function() {
                        return t.classList.remove(qf.state.focus)
                    };
                this.isRtl = "rtl" === zf(t).direction, !0 === this.isRtl && t.classList.add(qf.rtl), this.isNegativeScroll = (s = t.scrollLeft, t.scrollLeft = -1, r = t.scrollLeft < 0, t.scrollLeft = s, r), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new eg, this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = Xf(qf.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = Xf(qf.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", a), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
                var r = zf(this.scrollbarXRail);
                this.scrollbarXBottom = parseInt(r.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = sg(r.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = sg(r.borderLeftWidth) + sg(r.borderRightWidth), Yf(this.scrollbarXRail, {
                    display: "block"
                }), this.railXMarginWidth = sg(r.marginLeft) + sg(r.marginRight), Yf(this.scrollbarXRail, {
                    display: ""
                }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = Xf(qf.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = Xf(qf.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", a), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
                o = zf(this.scrollbarYRail);
                this.scrollbarYRight = parseInt(o.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = sg(o.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? sg((a = zf(a = this.scrollbarY)).width) + sg(a.paddingLeft) + sg(a.paddingRight) + sg(a.borderLeftWidth) + sg(a.borderRightWidth) : null, this.railBorderYWidth = sg(o.borderTopWidth) + sg(o.borderBottomWidth), Yf(this.scrollbarYRail, {
                    display: "block"
                }), this.railYMarginHeight = sg(o.marginTop) + sg(o.marginBottom), Yf(this.scrollbarYRail, {
                    display: ""
                }), this.railYHeight = null, this.railYRatio = null, this.reach = {
                    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
                    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
                }, this.isAlive = !0, this.settings.handlers.forEach(function(t) {
                    return cg[t](n)
                }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(t) {
                    return n.onScroll(t)
                }), ag(this)
            };
        Ot.prototype.update = function() {
            this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, Yf(this.scrollbarXRail, {
                display: "block"
            }), Yf(this.scrollbarYRail, {
                display: "block"
            }), this.railXMarginWidth = sg(zf(this.scrollbarXRail).marginLeft) + sg(zf(this.scrollbarXRail).marginRight), this.railYMarginHeight = sg(zf(this.scrollbarYRail).marginTop) + sg(zf(this.scrollbarYRail).marginBottom), Yf(this.scrollbarXRail, {
                display: "none"
            }), Yf(this.scrollbarYRail, {
                display: "none"
            }), ag(this), ng(this, "top", 0, !1, !0), ng(this, "left", 0, !1, !0), Yf(this.scrollbarXRail, {
                display: ""
            }), Yf(this.scrollbarYRail, {
                display: ""
            }))
        }, Ot.prototype.onScroll = function(t) {
            this.isAlive && (ag(this), ng(this, "top", this.element.scrollTop - this.lastScrollTop), ng(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft)
        }, Ot.prototype.destroy = function() {
            this.isAlive && (this.event.unbindAll(), $f(this.scrollbarX), $f(this.scrollbarY), $f(this.scrollbarXRail), $f(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1)
        }, Ot.prototype.removePsClasses = function() {
            this.element.className = this.element.className.split(" ").filter(function(t) {
                return !t.match(/^ps([-_].+|)$/)
            }).join(" ")
        };
        var hg = Ot;
        var dg = class {
            constructor(t, e = {}, i) {
                this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = t => {
                    this._condition(t) && t.target === this._lastElement && (t.preventDefault(), this._firstElement.focus())
                }
            }
            trap() {
                this._setElements(), this._init(), this._setFocusTrap()
            }
            disable() {
                this._focusableElements.forEach(t => {
                    t.removeEventListener(this._event, this.handler)
                }), this._toggler && this._toggler.focus()
            }
            update() {
                this._setElements(), this._setFocusTrap()
            }
            _init() {
                const e = t => {
                    this._firstElement && "Tab" === t.key && !this._focusableElements.includes(t.target) && (t.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", e))
                };
                window.addEventListener("keydown", e)
            }
            _filterVisible(t) {
                return t.filter(t => {
                    if (!r(t)) return !1;
                    var e = R.parents(t, "*");
                    for (let t = 0; t < e.length; t++) {
                        var i = window.getComputedStyle(e[t]);
                        if (i && ("none" === i.display || "hidden" === i.visibility)) return !1
                    }
                    return !0
                })
            }
            _setElements() {
                this._focusableElements = R.find(this._selector, this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1]
            }
            _setFocusTrap() {
                this._focusableElements.forEach((t, e) => {
                    e === this._focusableElements.length - 1 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler)
                })
            }
        };
        const ug = {
            threshold: 10,
            direction: "all"
        };
        var pg = class {
            constructor(t, e) {
                this._element = t, this._startPosition = null, this._options = { ...ug,
                    ...e
                }
            }
            handleTouchStart(t) {
                this._startPosition = this._getCoordinates(t)
            }
            handleTouchMove(t) {
                if (this._startPosition) {
                    t = this._getCoordinates(t), t = {
                        x: t.x - this._startPosition.x,
                        y: t.y - this._startPosition.y
                    }, t = this._getDirection(t);
                    if ("all" === this._options.direction) {
                        if (t.y.value < this._options.threshold && t.x.value < this._options.threshold) return;
                        var e = (t.y.value > t.x.value ? t.y : t.x).direction;
                        return I.trigger(this._element, "swipe".concat(e)), I.trigger(this._element, "swipe", {
                            direction: e
                        }), void(this._startPosition = null)
                    }
                    e = "left" === this._options.direction || "right" === this._options ? "x" : "y";
                    t[e].direction === this._options.direction && t[e].value > this._options.threshold && (I.trigger(this._element, "swipe".concat(t[e].direction)), this._startPosition = null)
                }
            }
            handleTouchEnd() {
                this._startPosition = null
            }
            _getCoordinates(t) {
                var [t] = t.touches;
                return {
                    x: t.clientX,
                    y: t.clientY
                }
            }
            _getDirection(t) {
                return {
                    x: {
                        direction: t.x < 0 ? "left" : "right",
                        value: Math.abs(t.x)
                    },
                    y: {
                        direction: t.y < 0 ? "up" : "down",
                        value: Math.abs(t.y)
                    }
                }
            }
        };
        var fg = class {
            constructor(t, e = "swipe", i = {}) {
                this._element = t, this._event = e, this.swipe = new pg(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this)
            }
            dispose() {
                this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler)
            }
            init() {
                this._element.addEventListener("touchstart", t => this._handleTouchStart(t)), this._element.addEventListener("touchmove", t => this._handleTouchMove(t)), window.addEventListener("touchend", t => this._handleTouchEnd(t))
            }
            _handleTouchStart(t) {
                this[this._event].handleTouchStart(t)
            }
            _handleTouchMove(t) {
                this[this._event].handleTouchMove(t)
            }
            _handleTouchEnd(t) {
                this[this._event].handleTouchEnd(t)
            }
        };
        const gg = "sidenav",
            _g = "mdb.sidenav",
            mg = "rotate-icon";
        const vg = '[data-mdb-toggle="sidenav"]',
            bg = ".sidenav-collapse",
            yg = ".sidenav-link",
            xg = h ? 100 : -100,
            wg = h ? -100 : 100;
        let Cg = 0;
        const kg = {
                accordion: "(boolean)",
                backdrop: "(boolean)",
                backdropClass: "(null|string)",
                closeOnEsc: "(boolean)",
                color: "(string)",
                content: "(null|string)",
                expandable: "(boolean)",
                expandOnHover: "(boolean)",
                focusTrap: "(boolean)",
                hidden: "(boolean)",
                mode: "(string)",
                scrollContainer: "(null|string)",
                slim: "(boolean)",
                slimCollapsed: "(boolean)",
                slimWidth: "(number)",
                position: "(string)",
                right: "(boolean)",
                transitionDuration: "(number)",
                width: "(number)"
            },
            Tg = {
                accordion: !1,
                backdrop: !0,
                backdropClass: null,
                closeOnEsc: !0,
                color: "primary",
                content: null,
                expandable: !0,
                expandOnHover: !1,
                focusTrap: !0,
                hidden: !0,
                mode: "over",
                scrollContainer: null,
                slim: !1,
                slimCollapsed: !1,
                slimWidth: 77,
                position: "fixed",
                right: !1,
                transitionDuration: 300,
                width: 240
            };
        class Sg {
            constructor(t, e = {}) {
                this._element = t, this._options = e, Cg++, this._ID = Cg, this._backdrop = null, this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this.escHandler = t => {
                    27 === t.keyCode && this.toggler && r(this.toggler) && (this._update(!1), I.off(window, "keydown", this.escHandler))
                }, this.hashHandler = () => {
                    this._setActiveElements()
                }, t && (p.setData(t, _g, this), this._setup())
            }
            static get NAME() {
                return gg
            }
            get container() {
                if ("fixed" === this.options.position) return R.findOne("body");
                const e = t => t.parentNode && t.parentNode !== document ? "relative" === t.parentNode.style.position ? t.parentNode : e(t.parentNode) : t;
                return e(this._element)
            }
            get isVisible() {
                let t = 0,
                    e = window.innerWidth;
                "fixed" !== this.options.position && (i = this.container.getBoundingClientRect(), t = i.x, e = i.x + i.width);
                var i = this._element.getBoundingClientRect()["x"];
                return this.options.right ? 10 < Math.abs(i - e) : Math.abs(i - t) < 10
            }
            get links() {
                return R.find(yg, this._element)
            }
            get navigation() {
                return R.find(".sidenav-menu", this._element)
            }
            get options() {
                var t = { ...Tg,
                    ...P.getDataAttributes(this._element),
                    ...this._options
                };
                return a(gg, t, kg), t
            }
            get sidenavStyle() {
                return {
                    width: "".concat(this.width, "px"),
                    height: "fixed" === this.options.position ? "100vh" : "100%",
                    position: this.options.position,
                    transition: "all ".concat(this.transitionDuration, " linear")
                }
            }
            get toggler() {
                return R.find(vg).find(t => {
                    t = P.getDataAttribute(t, "target");
                    return R.findOne(t) === this._element
                })
            }
            get transitionDuration() {
                return "".concat(this.options.transitionDuration / 1e3, "s")
            }
            get translation() {
                return this.options.right ? wg : xg
            }
            get width() {
                return this._slimCollapsed ? this.options.slimWidth : this.options.width
            }
            changeMode(t) {
                this._setMode(t)
            }
            dispose() {
                this._backdrop && this._removeBackdrop(), I.off(window, "keydown", this.escHandler), I.off(window, "hashchange", this.hashHandler), this._touch.dispose(), p.removeData(this._element, _g), this._element = null
            }
            hide() {
                this._setVisibility(!1), this._update(!1)
            }
            show() {
                this._setVisibility(!0), this._update(!0)
            }
            toggle() {
                this._setVisibility(!this.isVisible), this._update(!this.isVisible)
            }
            toggleSlim() {
                this._setSlim(!this._slimCollapsed)
            }
            update(t) {
                this._options = t, this._setup()
            }
            _appendArrow(t) {
                const e = y("i");
                ["fas", "fa-angle-down", mg].forEach(t => {
                    P.addClass(e, t)
                }), 0 === R.find(".".concat(mg), t).length && t.appendChild(e)
            }
            _collapseItems() {
                this.navigation.forEach(t => {
                    const e = R.find(bg, t);
                    e.forEach(t => {
                        le.getInstance(t).hide()
                    })
                })
            }
            _setupBackdrop() {
                const t = [];
                this.options.backdropClass && t.push(this.options.backdropClass);
                const e = {
                    transition: "opacity ".concat(this.transitionDuration, " ease-out"),
                    position: this.options.position,
                    width: "fixed" === this.options.position ? "100vw" : "100%",
                    height: "fixed" === this.options.position ? "100vh" : "100%"
                };
                var i;
                this._backdrop || (i = y("div"), t.push("sidenav-backdrop"), e.opacity = 0, I.on(i, "click", () => {
                    this._setVisibility(!1), this._update(!1)
                }), this._backdrop = i), this._backdrop.classList.add(...t), P.style(this._backdrop, e)
            }
            _getOffsetValue(t, {
                index: e,
                property: i,
                offsets: n
            }) {
                return this._getPxValue(this._initialContentStyle[e][n[i].property]) + (t ? n[i].value : 0)
            }
            _getProperty(...t) {
                return t.map((t, e) => 0 === e ? t : t[0].toUpperCase().concat(t.slice(1))).join("")
            }
            _getPxValue(t) {
                return t ? parseFloat(t) : 0
            }
            _handleSwipe(t, e) {
                e && this._slimCollapsed && this.options.slim && this.options.expandable ? this.toggleSlim() : e || (!this._slimCollapsed && this.options.slim && this.options.expandable ? this.toggleSlim() : this.toggler && r(this.toggler) && this.toggle())
            }
            _isActive(t, e) {
                return e ? e === t : !!t.attributes.href && new URL(t, window.location.href).href === window.location.href
            }
            _isAllToBeCollapsed() {
                const t = R.find('[data-mdb-toggle="collapse"]', this._element);
                return 0 === t.filter(t => "true" === t.getAttribute("aria-expanded")).length
            }
            _isAllCollapsed() {
                return 0 === R.find(bg, this._element).filter(t => r(t)).length
            }
            _setup() {
                this._setupTouch(), this.options.focusTrap && this._setupFocusTrap(), this.options.backdrop && (this._setupBackdrop(), this.options.hidden || "over" !== this.options.mode || this._appendBackdrop()), this._setupCollapse(), this.options.slim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.content && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.hidden || this._updateOffsets(!0, !0)
            }
            _setupActiveState() {
                this._setActiveElements(), this.links.forEach(e => {
                    I.on(e, "click", () => this._setActiveElements(e)), I.on(e, "keydown", t => {
                        13 === t.keyCode && this._setActiveElements(e)
                    })
                }), I.on(window, "hashchange", this.hashHandler)
            }
            _setupCollapse() {
                this.navigation.forEach((i, n) => {
                    const t = R.find(bg, i);
                    t.forEach((t, e) => this._setupCollapseList({
                        list: t,
                        index: e,
                        menu: i,
                        menuIndex: n
                    }))
                })
            }
            _generateCollpaseID(t, e) {
                return "sidenav-collapse-".concat(this._ID, "-").concat(e, "-").concat(t)
            }
            _setupCollapseList({
                list: e,
                index: t,
                menu: i,
                menuIndex: n
            }) {
                n = this._generateCollpaseID(t, n);
                e.classList.add("collapse"), e.setAttribute("id", n);
                const [s] = R.prev(e, yg);
                P.setDataAttribute(s, "toggle", "collapse"), s.setAttribute("href", "#".concat(n)), s.setAttribute("role", "button");
                const o = le.getInstance(e) || new le(e, {
                    toggle: !1,
                    parent: this.options.accordion ? i : e
                });
                this._appendArrow(s), P.hasClass(e, "show") && this._rotateArrow(s, 180), I.on(s, "click", t => {
                    this._toggleCategory(t, o, e), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
                }), I.on(e, "show.bs.collapse", () => this._rotateArrow(s, 180)), I.on(e, "hide.bs.collapse", () => this._rotateArrow(s, 0)), I.on(e, "shown.bs.collapse", () => {
                    "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
                }), I.on(e, "hidden.bs.collapse", () => {
                    this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
                })
            }
            _setupContent() {
                this._content = R.find(this.options.content), this._initialContentStyle = this._content.map(t => {
                    var {
                        paddingLeft: e,
                        paddingRight: i,
                        marginLeft: n,
                        marginRight: s,
                        transition: t
                    } = window.getComputedStyle(t);
                    return {
                        paddingLeft: e,
                        paddingRight: i,
                        marginLeft: n,
                        marginRight: s,
                        transition: t
                    }
                })
            }
            _setupFocusTrap() {
                this._focusTrap = new dg(this._element, {
                    event: "keydown",
                    condition: t => 9 === t.keyCode,
                    onlyVisible: !0
                }, this.toggler)
            }
            _setupInitialStyling() {
                this._setColor(), P.style(this._element, this.sidenavStyle)
            }
            _setupScrolling() {
                let e = this._element;
                if (this.options.scrollContainer) {
                    e = R.findOne(this.options.scrollContainer, this._element);
                    const i = (t = e.parentNode.children, Array.from(t).filter(t => t !== e));
                    t = i.reduce((t, e) => t + e.clientHeight, 0);
                    P.style(e, {
                        maxHeight: "calc(100% - ".concat(t, "px)"),
                        position: "relative"
                    })
                }
                var t;
                this._perfectScrollbar = new hg(e, {
                    suppressScrollX: !0,
                    handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
                })
            }
            _setupSlim() {
                this._slimCollapsed = this.options.slimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.expandOnHover && (this._element.addEventListener("mouseenter", () => {
                    this._slimCollapsed && this._setSlim(!1)
                }), this._element.addEventListener("mouseleave", () => {
                    this._slimCollapsed || this._setSlim(!0)
                }))
            }
            _setupRippleEffect() {
                this.links.forEach(t => {
                    let e = Wa.getInstance(t);
                    if (e && e._options.color !== this.options.color) e.dispose();
                    else if (e) return;
                    e = new Wa(t, {
                        rippleColor: this.options.color
                    })
                })
            }
            _setupTouch() {
                this._touch = new fg(this._element, "swipe", {
                    threshold: 20
                }), this._touch.init(), I.on(this._element, "swipeleft", t => this._handleSwipe(t, this.options.right)), I.on(this._element, "swiperight", t => this._handleSwipe(t, !this.options.right))
            }
            _setActive(t, e) {
                P.addClass(t, "active"), this._activeNode && this._activeNode.classList.remove("active"), this._activeNode = t;
                var [i] = R.parents(this._activeNode, bg);
                i ? ([t] = R.prev(i, yg), this._setActiveCategory(t), e || this._slimCollapsed || le.getInstance(i).show()) : this._setActiveCategory()
            }
            _setActiveCategory(i) {
                this.navigation.forEach(t => {
                    const e = R.find(bg, t);
                    e.forEach(t => {
                        const [e] = R.prev(t, yg);
                        e !== i ? e.classList.remove("active") : P.addClass(e, "active")
                    })
                })
            }
            _setActiveElements(i) {
                this.navigation.forEach(t => {
                    const e = R.find(yg, t);
                    e.filter(t => 0 === R.next(t, bg).length).forEach(t => {
                        this._isActive(t, i) && t !== this._activeNode && this._setActive(t, i)
                    })
                })
            }
            _setColor() {
                const t = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"];
                var e = this.options["color"],
                    e = t.includes(e) ? e : "primary";
                t.forEach(t => {
                    this._element.classList.remove("sidenav-".concat(t))
                }), P.addClass(this._element, "sidenav-".concat(e))
            }
            _setContentOffsets(o, a, r) {
                this._content.forEach((t, e) => {
                    var i = this._getOffsetValue(o, {
                            index: e,
                            property: "padding",
                            offsets: a
                        }),
                        n = this._getOffsetValue(o, {
                            index: e,
                            property: "margin",
                            offsets: a
                        });
                    const s = {};
                    r || (s.transition = "all ".concat(this.transitionDuration, " linear")), s[a.padding.property] = "".concat(i, "px"), s[a.margin.property] = "".concat(n, "px"), P.style(t, s), o && (r ? P.style(t, {
                        transition: this._initialContentStyle[e].transition
                    }) : I.on(t, "transitionend", () => {
                        P.style(t, {
                            transition: this._initialContentStyle[e].transition
                        })
                    }))
                })
            }
            _setMode(t) {
                this.options.mode !== t && (this._options.mode = t, this._update(this.isVisible))
            }
            _setSlim(t) {
                this._triggerEvents(...t ? ["collapse", "collapsed"] : ["expand", "expanded"]), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), P.style(this._element, {
                    width: "".concat(this.width, "px")
                }), this._updateOffsets(this.isVisible)
            }
            _setTabindex(e) {
                this.links.forEach(t => {
                    t.tabIndex = e ? 1 : -1
                })
            }
            _setVisibility(t) {
                this._triggerEvents(...t ? ["show", "shown"] : ["hide", "hidden"])
            }
            _rotateArrow(t, e) {
                var [t] = R.children(t, ".".concat(mg));
                t && P.style(t, {
                    transform: "rotate(".concat(e, "deg)")
                })
            }
            async _toggleBackdrop(t) {
                t && "over" === this.options.mode ? this._appendBackdrop() : (P.style(this._backdrop, {
                    opacity: 0
                }), await setTimeout(() => {
                    this._removeBackdrop()
                }, this.options.transitionDuration))
            }
            _removeBackdrop() {
                this._backdrop.parentNode === this.container && this.container.removeChild(this._backdrop)
            }
            _appendBackdrop() {
                this.container.appendChild(this._backdrop), setTimeout(() => P.style(this._backdrop, {
                    opacity: 1
                }), 0)
            }
            _toggleCategory(t, e) {
                t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.expandable && (this._tempSlim = !0, this._setSlim(!1))
            }
            _toggleSlimDisplay(t) {
                const e = R.find('[data-mdb-slim="true"]', this._element),
                    i = R.find('[data-mdb-slim="false"]', this._element),
                    n = () => {
                        e.forEach(t => {
                            P.style(t, {
                                display: this._slimCollapsed ? "unset" : "none"
                            })
                        }), i.forEach(t => {
                            P.style(t, {
                                display: this._slimCollapsed ? "none" : "unset"
                            })
                        })
                    };
                t ? setTimeout(() => n(), this.options.transitionDuration) : n()
            }
            async _triggerEvents(t, e) {
                I.trigger(this._element, "".concat(t, ".mdb.sidenav")), e && await setTimeout(() => {
                    I.trigger(this._element, "".concat(e, ".mdb.sidenav"))
                }, this.options.transitionDuration + 5)
            }
            _update(t) {
                this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.backdrop && this._toggleBackdrop(t), this._updateOffsets(t), t && this.options.closeOnEsc && "side" !== this.options.mode && I.on(window, "keydown", this.escHandler), this.options.focusTrap && this._updateFocus(t)
            }
            _updateDisplay(t) {
                t = t ? 0 : this.translation;
                P.style(this._element, {
                    transform: "translateX(".concat(t, "%)")
                })
            }
            _updateFocus(t) {
                if (this._setTabindex(t), "over" === this.options.mode && this.options.focusTrap) {
                    if (t) return void this._focusTrap.trap();
                    this._focusTrap.disable()
                }
                this._focusTrap.disable()
            }
            _updateOffsets(t, e = !1) {
                var [i, n] = this.options.right ? ["right", "left"] : ["left", "right"], i = {
                    property: this._getProperty("padding", i),
                    value: "over" === this.options.mode ? 0 : this.width
                }, n = {
                    property: this._getProperty("margin", n),
                    value: "push" === this.options.mode ? -1 * this.width : 0
                };
                I.trigger(this._element, "update.mdb.sidenav", {
                    margin: n,
                    padding: i
                }), this._content && this._setContentOffsets(t, {
                    padding: i,
                    margin: n
                }, e)
            }
            _updateTogglerAria(t) {
                this.toggler.setAttribute("aria-expanded", t)
            }
            static toggleSidenav() {
                return function(t) {
                    t = R.closest(t.target, vg), t = P.getDataAttributes(t).target;
                    R.find(t).forEach(t => {
                        const e = Sg.getInstance(t) || new Sg(t);
                        e.toggle()
                    })
                }
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, _g);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Sg(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, _g)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        I.on(document, "click", vg, Sg.toggleSidenav()), R.find(".sidenav").forEach(t => {
            let e = Sg.getInstance(t);
            return e = e || new Sg(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[gg];
                t.fn[gg] = Sg.jQueryInterface, t.fn[gg].Constructor = Sg, t.fn[gg].noConflict = () => (t.fn[gg] = e, Sg.jQueryInterface)
            }
        });
        var Eg = Sg;
        Ot = ".".concat("bs.alert");
        const Ag = "close".concat(Ot),
            Mg = "closed".concat(Ot);
        class Og extends Et {
            static get NAME() {
                return "alert"
            }
            close() {
                var t;
                vt.trigger(this._element, Ag).defaultPrevented || (this._element.classList.remove("show"), t = this._element.classList.contains("fade"), this._queueCallback(() => this._destroyElement(), this._element, t))
            }
            _destroyElement() {
                this._element.remove(), vt.trigger(this._element, Mg), this.dispose()
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = Og.getOrCreateInstance(this);
                    if ("string" == typeof e) {
                        if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e](this)
                    }
                })
            }
        }
        Se(Og, "close"), G(Og);
        Ot = Og, i(53);
        const Ig = {
                position: "top",
                container: null,
                refresh: 1e3,
                filter: t => t
            },
            Dg = {
                position: "string",
                container: "(undefined|null|string)",
                refresh: "number",
                filter: "function"
            };
        var Lg = class {
            constructor(t, e, i) {
                this._element = t, this._selector = e, this._options = this._getConfig(i), this._offset = null, this._options.container && (this._parent = R.findOne(this._options.container))
            }
            get stackableElements() {
                return R.find(this._selector).filter((t, e) => this._options.filter(t, e)).map(t => ({
                    el: t,
                    rect: t.getBoundingClientRect()
                })).filter(({
                    el: t,
                    rect: e
                }) => {
                    t = t !== this._element && r(t);
                    return null === this._offset ? t : t && this._getBoundryOffset(e) < this._offset
                }).sort((t, e) => this._getBoundryOffset(e.rect) - this._getBoundryOffset(t.rect))
            }
            get nextElements() {
                return R.find(this._selector).filter(t => t !== this._element).filter((t, e) => this._options.filter(t, e)).filter(t => (this._offset = null, this._getBoundryOffset(t.getBoundingClientRect()) > this._offset))
            }
            _getConfig(t) {
                t = { ...Ig,
                    ...t
                };
                return a("Stack", t, Dg), t
            }
            _getBoundryOffset(t) {
                var e, i = this._options["position"];
                let n = 0,
                    s = window.innerHeight;
                return this._parent && (e = this._parent.getBoundingClientRect(), n = e.top, s = e.bottom), "top" === i ? t.top - n : s - t.bottom
            }
            calculateOffset() {
                var [t] = this.stackableElements;
                return this._offset = t ? this._getBoundryOffset(t.rect) + t.rect.height : 0, this._offset
            }
        };
        const Pg = "alert";
        i = "mdb.".concat(Pg), i = ".".concat(i);
        const Rg = {
                position: "(string || null)",
                delay: "number",
                autohide: "boolean",
                width: "(string || null)",
                offset: "number",
                stacking: "boolean",
                hidden: "boolean",
                appendToBody: "boolean",
                color: "(string || null)",
                container: "(string|null)"
            },
            Bg = {
                position: null,
                delay: 1e3,
                autohide: !1,
                width: null,
                offset: 10,
                stacking: !1,
                hidden: !1,
                appendToBody: !1,
                color: null,
                container: null
            },
            Ng = "close.bs.alert",
            Hg = "closed.bs.alert",
            jg = "close".concat(i),
            Wg = "closed".concat(i);
        class Fg extends Ot {
            constructor(t, e = {}) {
                super(t, e), this._options = this._getConfig(e), this._init()
            }
            dispose() {
                I.off(this._element, Ng), I.off(this._element, Hg), super.dispose()
            }
            get verticalOffset() {
                return this._options.stacking ? this.stackUtil.calculateOffset() : 0
            }
            get parent() {
                var [t] = R.parents(this._element, this._options.container);
                return t
            }
            get position() {
                var [t, e] = this._options.position.split("-");
                return {
                    y: t,
                    x: e
                }
            }
            update(t = {}) {
                null !== this._timeout && (clearTimeout(this._timeout), this._timeout = null), this._options = this._getConfig(t), this._setup()
            }
            hide() {
                if (this._element && this._element.classList.contains("show")) {
                    P.toggleClass(this._element, "show");
                    const e = t => {
                        P.style(t.target, {
                            display: "none"
                        }), null !== this._timeout && (clearTimeout(this._timeout), this._timeout = null), this._options.stacking && this._updateAlertStack(), I.off(t.target, "transitionend", e)
                    };
                    I.on(this._element, "transitionend", e)
                }
            }
            show() {
                if (this._options.autohide && this._setupAutohide(), !this._element.classList.contains("show") && (P.style(this._element, {
                        display: "block"
                    }), r(this._element))) {
                    const e = t => {
                        P.style(t.target, {
                            display: "block"
                        }), I.off(t.target, "transitionend", e)
                    };
                    P.toggleClass(this._element, "show"), this._options.position && this._setupAlignment(), I.on(this._element, "transitionend", e)
                }
            }
            _init() {
                this._options.hidden && P.style(this._element, {
                    display: "none"
                }), this._bindCloseEvent(), this._bindClosedEvent(), this._setup()
            }
            _setup() {
                this._options.color && this._setColor(), this._options.stacking && this._setupStacking(), this._options.autohide && this._setupAutohide(), this._options.width && this._setupWidth(), this._options.appendToBody && this._appendToBody(), this._options.position && (this._setupAlignment(), this._setupPosition())
            }
            _setupStacking() {
                this.stackUtil = new Lg(this._element, ".alert", {
                    position: this.position.y,
                    offset: this._options.offset,
                    container: this._options.container,
                    filter: t => {
                        t = Fg.getInstance(t);
                        return !!t && (t._options.container === this._options.container && t._options.position === this._options.position)
                    }
                }), I.on(this._element, "closed.bs.alert", () => {
                    this._updateAlertStack()
                })
            }
            _setColor() {
                const t = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"];
                var e = t.includes(this._options.color) ? this._options.color : "primary";
                t.forEach(t => {
                    this._element.classList.remove("alert-".concat(t))
                }), P.addClass(this._element, "alert-".concat(e))
            }
            _setupWidth() {
                P.style(this._element, {
                    width: this._options.width
                })
            }
            _setupAutohide() {
                this._timeout = setTimeout(() => {
                    this.hide()
                }, this._options.delay)
            }
            _setupAlignment() {
                var t = "top" === this.position.y ? "bottom" : "top",
                    e = "left" === this.position.x ? "right" : "left";
                "center" === this.position.x ? P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._options.offset, "px"),
                    [t]: "unset",
                    left: "50%",
                    transform: "translate(-50%)"
                }) : P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._options.offset, "px"),
                    [this.position.x]: "".concat(this._options.offset, "px"),
                    [t]: "unset",
                    [e]: "unset",
                    transform: "unset"
                })
            }
            _setupPosition() {
                this._options.container ? (P.addClass(this.parent, "parent-alert-relative"), P.addClass(this._element, "alert-absolute")) : P.addClass(this._element, "alert-fixed")
            }
            _appendToBody() {
                this._element.parentNode.removeChild(this._element), document.body.appendChild(this._element)
            }
            _getConfig(t) {
                t = { ...Bg,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(Pg, t, Rg), t
            }
            _bindCloseEvent() {
                I.on(this._element, Ng, () => {
                    I.trigger(this._element, jg)
                })
            }
            _bindClosedEvent() {
                I.on(this._element, Hg, () => {
                    I.trigger(this._element, Wg)
                })
            }
            _updatePosition() {
                P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._options.offset, "px")
                })
            }
            _updateAlertStack() {
                this.stackUtil.nextElements.forEach(t => {
                    const e = Fg.getInstance(t);
                    e && e._updatePosition()
                })
            }
        }
        R.find(".alert").forEach(t => {
            let e = Fg.getInstance(t);
            return e = e || new Fg(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Pg];
                t.fn[Pg] = Fg.jQueryInterface, t.fn[Pg].Constructor = Fg, t.fn[Pg].noConflict = () => (t.fn[Pg] = e, Fg.jQueryInterface)
            }
        });
        var Vg = Fg;
        i = ".".concat("bs.toast");
        const zg = "mouseover".concat(i),
            Yg = "mouseout".concat(i),
            Xg = "focusin".concat(i),
            Ug = "focusout".concat(i),
            Kg = "hide".concat(i),
            $g = "hidden".concat(i),
            Qg = "show".concat(i),
            qg = "shown".concat(i),
            Zg = "show",
            Gg = "showing",
            Jg = {
                animation: "boolean",
                autohide: "boolean",
                delay: "number"
            },
            t_ = {
                animation: !0,
                autohide: !0,
                delay: 5e3
            };
        class e_ extends Et {
            constructor(t, e) {
                super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
            }
            static get Default() {
                return t_
            }
            static get DefaultType() {
                return Jg
            }
            static get NAME() {
                return "toast"
            }
            show() {
                vt.trigger(this._element, Qg).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), $(this._element), this._element.classList.add(Zg, Gg), this._queueCallback(() => {
                    this._element.classList.remove(Gg), vt.trigger(this._element, qg), this._maybeScheduleHide()
                }, this._element, this._config.animation))
            }
            hide() {
                this.isShown() && (vt.trigger(this._element, Kg).defaultPrevented || (this._element.classList.add(Gg), this._queueCallback(() => {
                    this._element.classList.add("hide"), this._element.classList.remove(Gg, Zg), vt.trigger(this._element, $g)
                }, this._element, this._config.animation)))
            }
            dispose() {
                this._clearTimeout(), this.isShown() && this._element.classList.remove(Zg), super.dispose()
            }
            isShown() {
                return this._element.classList.contains(Zg)
            }
            _maybeScheduleHide() {
                this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
                    this.hide()
                }, this._config.delay)))
            }
            _onInteraction(t, e) {
                switch (t.type) {
                    case "mouseover":
                    case "mouseout":
                        this._hasMouseInteraction = e;
                        break;
                    case "focusin":
                    case "focusout":
                        this._hasKeyboardInteraction = e
                }
                e ? this._clearTimeout() : (t = t.relatedTarget, this._element === t || this._element.contains(t) || this._maybeScheduleHide())
            }
            _setListeners() {
                vt.on(this._element, zg, t => this._onInteraction(t, !0)), vt.on(this._element, Yg, t => this._onInteraction(t, !1)), vt.on(this._element, Xg, t => this._onInteraction(t, !0)), vt.on(this._element, Ug, t => this._onInteraction(t, !1))
            }
            _clearTimeout() {
                clearTimeout(this._timeout), this._timeout = null
            }
            static jQueryInterface(e) {
                return this.each(function() {
                    const t = e_.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e](this)
                    }
                })
            }
        }
        Se(e_), G(e_);
        Ot = e_;
        const i_ = "toast",
            n_ = "show.bs.toast",
            s_ = "shown.bs.toast",
            o_ = "hide.bs.toast",
            a_ = "hidden.bs.toast",
            r_ = {
                position: "(string|null)",
                animation: "boolean",
                autohide: "boolean",
                width: "(string || null)",
                color: "(string|null)",
                delay: "(boolean|number)",
                offset: "number",
                appendToBody: "boolean",
                stacking: "boolean"
            },
            l_ = {
                position: null,
                animation: !0,
                autohide: !0,
                width: null,
                color: null,
                delay: 500,
                offset: 10,
                appendToBody: !1,
                stacking: !0
            };
        class c_ extends Ot {
            constructor(t, e = {}) {
                super(t, e), this._config = this._getConfig(e), this._setup()
            }
            get parent() {
                var [t] = R.parents(this._element, this._config.container);
                return t
            }
            get position() {
                if (!this._config.position) return null;
                var [t, e] = this._config.position.split("-");
                return {
                    y: t,
                    x: e
                }
            }
            get verticalOffset() {
                return this._config.stacking && this.position ? this.stackUtil.calculateOffset() : 0
            }
            update(t = {}) {
                this._config = this._getConfig(t), this._setupColor(), this._config.position && (this._config.stacking && (this._setupStacking(), I.on(this._element, "hidden.bs.toast", () => {
                    setTimeout(() => this._updateToastStack(), 150)
                })), this._setupPosition(), this._setupAlignment())
            }
            dispose() {
                I.off(this._element, n_), I.off(this._element, s_), I.off(this._element, o_), I.off(this._element, a_), super.dispose()
            }
            _setup() {
                this._setupColor(), this._config.width && this._setupWidth(), this._config.position && (this._config.stacking && (this._setupStacking(), I.on(this._element, "hidden.bs.toast", () => {
                    setTimeout(() => this._updateToastStack(), 150)
                })), this._setupPosition(), this._setupDisplay(), !this._config.container && this._config.appendToBody && this._appendToBody(), this._bindShownEvent(), this._bindHideEvent())
            }
            _setupStacking() {
                this.stackUtil = new Lg(this._element, ".toast", {
                    position: this.position.y,
                    offset: this._config.offset,
                    container: this._config.container,
                    filter: t => {
                        t = c_.getInstance(t);
                        return !!t && (t._config.container === this._config.container && t._config.position === this._config.position)
                    }
                }), I.on(this._element, "closed.bs.alert", () => {
                    this._updateAlertStack()
                })
            }
            _setupColor() {
                if (this._config.color) {
                    const e = R.findOne(".toast-header", this._element),
                        i = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"];
                    var t = i.includes(this._config.color) ? this._config.color : "primary";
                    i.forEach(t => {
                        this._element.classList.remove("toast-".concat(t)), e && e.classList.remove("toast-".concat(t))
                    }), P.addClass(this._element, "toast-".concat(t)), e && P.addClass(e, "toast-".concat(t))
                }
            }
            _setupWidth() {
                P.style(this._element, {
                    width: this._config.width
                })
            }
            _setupPosition() {
                this._config.container ? (P.addClass(this.parent, "parent-toast-relative"), P.addClass(this._element, "toast-absolute")) : P.addClass(this._element, "toast-fixed")
            }
            _setupAlignment() {
                var t = "top" === this.position.y ? "bottom" : "top",
                    e = "left" === this.position.x ? "right" : "left";
                "center" === this.position.x ? P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._config.offset, "px"),
                    [t]: "unset",
                    left: "50%",
                    transform: "translate(-50%)"
                }) : P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._config.offset, "px"),
                    [this.position.x]: "".concat(this._config.offset, "px"),
                    [t]: "unset",
                    [e]: "unset",
                    transform: "unset"
                })
            }
            _setupDisplay() {
                this._element.classList.contains("show") || P.style(this._element, {
                    display: "none"
                }), I.on(this._element, a_, () => {
                    I.trigger(this._element, "hidden.mdb.toast"), P.style(this._element, {
                        display: "none"
                    })
                }), I.on(this._element, n_, () => {
                    I.trigger(this._element, "show.mdb.toast"), this._setupAlignment(), P.style(this._element, {
                        display: "block"
                    })
                })
            }
            _bindShownEvent() {
                I.on(this._element, s_, () => {
                    I.trigger(this._element, "shown.mdb.toast")
                })
            }
            _bindHideEvent() {
                I.on(this._element, o_, () => {
                    I.trigger(this._element, "hide.mdb.toast")
                })
            }
            _getConfig(t) {
                t = { ...l_,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(i_, t, r_), t
            }
            _appendToBody() {
                this._element.parentNode.removeChild(this._element), document.body.appendChild(this._element)
            }
            _updatePosition() {
                P.style(this._element, {
                    [this.position.y]: "".concat(this.verticalOffset + this._config.offset, "px")
                })
            }
            _updateToastStack() {
                this.stackUtil.nextElements.forEach(t => {
                    const e = c_.getInstance(t);
                    e && e._updatePosition()
                })
            }
        }
        R.find(".toast").forEach(t => {
            let e = c_.getInstance(t);
            return e = e || new c_(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[i_];
                t.fn[i_] = c_.jQueryInterface, t.fn[i_].Constructor = c_, t.fn[i_].noConflict = () => (t.fn[i_] = e, c_.jQueryInterface)
            }
        });
        var h_ = c_;
        const d_ = s => {
                if ("" !== s) {
                    let t, e, i, n;
                    return u_(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, 0 === t ? i = "AM" : 12 < t && (i = "PM"), t = t || 12, void 0 === i && (i = 12 <= t ? "PM" : "AM"), e = e < 10 ? "0".concat(e) : e) : ([t, e, i] = __(s, !1), n = t, t %= 12, 0 === t && (i = "AM"), t = t || 12, void 0 === i && (i = 12 <= n ? "PM" : "AM")), {
                        hours: t,
                        minutes: e,
                        amOrPm: i
                    }
                }
            },
            u_ = t => t && "[object Date]" === Object.prototype.toString.call(t) && !isNaN(t),
            p_ = i => {
                if ("" !== i) {
                    let t, e;
                    return u_(i) ? (t = i.getHours(), e = i.getMinutes()) : [t, e] = __(i, !1), e = Number(e) < 10 ? "0".concat(Number(e)) : e, {
                        hours: t,
                        minutes: e
                    }
                }
            },
            f_ = ({
                clientX: t,
                clientY: e,
                touches: i
            }, n, s = !1) => {
                var {
                    left: o,
                    top: n
                } = n.getBoundingClientRect();
                let a = {};
                return s && i ? s && 0 < Object.keys(i).length && (a = {
                    x: i[0].clientX - o,
                    y: i[0].clientY - n
                }) : a = {
                    x: t - o,
                    y: e - n
                }, a
            },
            g_ = () => {
                let t = !1;
                return (navigator.maxTouchPoints && 2 < navigator.maxTouchPoints && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) && (t = !0), t
            },
            __ = (t, e = !0) => {
                let i;
                return i = (e ? t.value : t).replace(/:/gi, " "), i.split(" ")
            },
            m_ = (t, e) => {
                var [i, n, s] = __(t, !1), [o, t, e] = __(e, !1);
                return "PM" == s && "AM" == e ? 1 : "AM" == s && "PM" == e ? 2 : s == e && o < i ? 1 : i < o ? 2 : t < n ? 1 : n < t ? 2 : void 0
            },
            v_ = () => {
                const t = new Date;
                var e = t.getHours();
                let i = String(t.getMinutes());
                return 1 === i.length && (i = "0".concat(i)), "".concat(e, ":").concat(i)
            },
            b_ = (t, e, i) => {
                if (!e) return t;
                let n = v_();
                return i && (n = "".concat(d_(n).hours, ":").concat(d_(n).minutes, " ").concat(d_(n).amOrPm)), t = "" != t && 1 == m_(n, t) || "" === t ? n : t
            },
            y_ = (t, e, i) => {
                if (!e) return t;
                let n = v_();
                return i && (n = "".concat(d_(n).hours, ":").concat(d_(n).minutes, " ").concat(d_(n).amOrPm)), t = "" != t && 2 == m_(n, t) || "" === t ? n : t
            },
            x_ = (t, e) => {
                t.forEach(t => {
                    ("00" === t.textContent || Number(t.textContent) > e) && P.addClass(t, "disabled")
                })
            },
            w_ = (t, e) => {
                t.forEach(t => {
                    "00" !== t.textContent && Number(t.textContent) < e && P.addClass(t, "disabled")
                })
            };

        function C_(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }
        const k_ = "timepicker",
            T_ = "mdb.".concat(k_),
            S_ = "active",
            E_ = "".concat(k_, "-am"),
            A_ = "".concat(k_, "-cancel"),
            M_ = "".concat(k_, "-clear"),
            O_ = "".concat(k_, "-submit"),
            I_ = "".concat(k_, "-circle"),
            D_ = "".concat(k_, "-clock-animation"),
            L_ = "".concat(k_, "-clock"),
            P_ = "".concat(k_, "-clock-inner"),
            R_ = "".concat(k_, "-clock-wrapper"),
            B_ = ".".concat(k_, "-current"),
            N_ = "".concat(k_, "-current-inline"),
            H_ = "".concat(k_, "-hand-pointer"),
            j_ = "".concat(k_, "-hour"),
            W_ = "".concat(k_, "-hour-mode"),
            F_ = "".concat(k_, "-icon-down"),
            V_ = "".concat(k_, "-icon-inline-hour"),
            z_ = "".concat(k_, "-icon-inline-minute"),
            Y_ = "".concat(k_, "-icon-up"),
            X_ = "".concat(k_, "-inline-hour-icons"),
            U_ = "".concat(k_, "-middle-dot"),
            K_ = "".concat(k_, "-minute"),
            $_ = "".concat(k_, "-modal"),
            Q_ = "".concat(k_, "-pm"),
            q_ = "".concat(k_, "-tips-element"),
            Z_ = "".concat(k_, "-time-tips-hours"),
            G_ = "".concat(k_, "-tips-inner-element"),
            J_ = "".concat(k_, "-time-tips-inner"),
            tm = "".concat(k_, "-time-tips-minutes"),
            em = "".concat(k_, "-transform"),
            im = "".concat(k_, "-wrapper"),
            nm = "".concat(k_, "-input"),
            sm = {
                appendValidationInfo: !0,
                bodyID: "",
                cancelLabel: "Cancel",
                clearLabel: "Clear",
                closeModalOnBackdropClick: !0,
                closeModalOnMinutesClick: !1,
                container: "body",
                defaultTime: "",
                disabled: !1,
                disablePast: !1,
                disableFuture: !1,
                enableValidation: !0,
                focusInputAfterApprove: !1,
                footerID: "",
                format12: !0,
                format24: !1,
                headID: "",
                increment: !1,
                inline: !1,
                invalidLabel: "Invalid Time Format",
                maxTime: "",
                minTime: "",
                modalID: "",
                okLabel: "Ok",
                overflowHidden: !0,
                pickerID: "",
                readOnly: !1,
                showClearBtn: !0,
                switchHoursToMinutesOnClick: !0,
                iconClass: "far fa-clock fa-sm timepicker-icon",
                withIcon: !0,
                pmLabel: "PM",
                amLabel: "AM",
                animations: !0
            },
            om = {
                appendValidationInfo: "boolean",
                bodyID: "string",
                cancelLabel: "string",
                clearLabel: "string",
                closeModalOnBackdropClick: "boolean",
                closeModalOnMinutesClick: "boolean",
                container: "string",
                disabled: "boolean",
                disablePast: "boolean",
                disableFuture: "boolean",
                enableValidation: "boolean",
                footerID: "string",
                format12: "boolean",
                format24: "boolean",
                headID: "string",
                increment: "boolean",
                inline: "boolean",
                invalidLabel: "string",
                modalID: "string",
                okLabel: "string",
                overflowHidden: "boolean",
                pickerID: "string",
                readOnly: "boolean",
                showClearBtn: "boolean",
                switchHoursToMinutesOnClick: "boolean",
                defaultTime: "(string|date|number)",
                iconClass: "string",
                withIcon: "boolean",
                pmLabel: "string",
                amLabel: "string",
                animations: "boolean"
            };
        class am {
            constructor(t, e = {}) {
                C_(this, "_toggleAmPm", t => {
                    "PM" == t ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : "AM" == t && (this._isPmEnabled = !1, this._isAmEnabled = !0)
                }), C_(this, "_toggleBackgroundColorCircle", t => {
                    null !== this._modal.querySelector(".".concat(t, ".").concat(S_)) ? P.addStyle(this._circle, {
                        backgroundColor: "#1976d2"
                    }) : P.addStyle(this._circle, {
                        backgroundColor: "transparent"
                    })
                }), C_(this, "_toggleClassActive", (t, {
                    textContent: e
                }, i) => {
                    const n = [...t].find(t => Number(t) === Number(e));
                    return i.forEach(t => {
                        P.hasClass(t, "disabled") || (t.textContent === n ? P.addClass(t, S_) : P.removeClass(t, S_))
                    })
                }), C_(this, "_makeMinutesDegrees", (t, e) => {
                    var i = this._options["increment"];
                    return t = t < 0 ? (e = Math.round(360 + t / 6) % 60, 360 + 6 * Math.round(t / 6)) : (e = Math.round(t / 6) % 60, 6 * Math.round(t / 6)), i && (t = 30 * Math.round(t / 30), 60 === (e = 6 * Math.round(t / 6) / 6) && (e = "00")), {
                        degrees: t = 360 <= t ? 0 : t,
                        minute: e,
                        addDegrees: i ? 30 : 6
                    }
                }), C_(this, "_makeHourDegrees", (t, e, i) => {
                    if (t) return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : 12 === (i = Math.round(e / 30) + 12) && (i = "00") : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (0 === (i = Math.round(e / 30) % 12) || 12 < i) && (i = 12), {
                        degrees: e = 360 <= e ? 0 : e,
                        hour: i,
                        addDegrees: 30
                    }
                }), C_(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : 12 === (e = Math.round(t / 30) + 12) && (e = "00"), {
                    degrees: t,
                    hour: e,
                    addDegrees: 30
                })), C_(this, "_getAppendClock", (o = [], t = ".".concat(L_), a) => {
                    var {
                        minTime: e,
                        maxTime: i
                    } = this._options;
                    const {
                        inline: n,
                        format12: s,
                        disablePast: r,
                        disableFuture: l
                    } = this._options;
                    e = b_(e, r, s), i = y_(i, l, s);
                    const [c, h, d] = __(i, !1), [u, p, f] = __(e, !1);
                    n || s && this._isInvalidTimeFormat && !P.hasClass(this._AM, "active") && P.addClass(this._PM, "active");
                    const g = R.findOne(t),
                        _ = 360 / o.length;
                    if (null !== g) {
                        const m = (g.offsetWidth - 32) / 2,
                            v = (g.offsetHeight - 32) / 2,
                            b = m - 4;
                        setTimeout(() => {
                            let t;
                            s && (t = R.findOne(".".concat(W_, ".").concat(S_)).textContent), this._handleDisablingTipsMinTime(t, f, p, u), this._handleDisablingTipsMaxTime(t, d, h, c)
                        }, 0), [...o].forEach((t, e) => {
                            var i = e * _ * (Math.PI / 180);
                            const n = y("span"),
                                s = y("span");
                            s.innerHTML = t, P.addClass(n, a);
                            e = n.offsetWidth, t = n.offsetHeight;
                            return P.addStyle(n, {
                                left: "".concat(m + Math.sin(i) * b - e, "px"),
                                bottom: "".concat(v + Math.cos(i) * b - t, "px")
                            }), o.includes("05") && P.addClass(n, "".concat(tm)), o.includes("13") ? s.classList.add(G_) : s.classList.add(q_), n.appendChild(s), g.appendChild(n)
                        })
                    }
                }), this._element = t, this._element && p.setData(t, T_, this), this._document = document, this._options = this._getConfig(e), this._currentTime = null, this._toggleButtonId = d("timepicker-toggle-"), this.hoursArray = ["12", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"], this.innerHours = ["00", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"], this.minutesArray = ["00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"], this.input = R.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = R.findOne(".timepicker-toggle-button", this._element), this._checkToggleButton(), this.inputFormatShow = R.findOne("[data-mdb-timepicker-format24]", this._element), this.inputFormat = null === this.inputFormatShow ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = R.findOne("[data-mdb-toggle]", this._element), this.toggleElement = Object.values(t.querySelector("[data-mdb-toggle]").dataset)[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = "" !== this._options.defaultTime ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = p_(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = d_(this._inputValue)), this._options.readOnly && this.input.setAttribute("readonly", !0), "true" === this.inputFormat && "" !== this.inputFormat && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = p_(this._inputValue)), this._scrollBar = new pe, this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = {
                    degrees: null
                }
            }
            static get NAME() {
                return k_
            }
            init() {
                var t, e, i, {
                    format12: n,
                    format24: s,
                    enableValidation: o
                } = this._options;
                let a, r, l;
                P.addClass(this.input, nm), void 0 !== this._currentTime ? ({
                    hours: t,
                    minutes: e,
                    amOrPm: i
                } = this._currentTime, a = Number(t) < 10 ? 0 : "", r = "".concat(a).concat(Number(t), ":").concat(e), l = i, n ? this.input.value = "".concat(r, " ").concat(l) : s && (this.input.value = "".concat(r))) : (a = "", r = "", l = "", this.input.value = ""), 0 < this.input.value.length && "" !== this.input.value && P.addClass(this.input, "active"), null === this._options && null === this._element || (o && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown())
            }
            dispose() {
                this._removeModal(), null !== this._element && p.removeData(this._element, T_), setTimeout(() => {
                    this._options = null, this._element = null, this.input = null, this._focusTrap = null
                }, 350), I.off(this._document, "click", "[data-mdb-toggle='".concat(this.toggleElement, "']")), I.off(this._element, "keydown", "[data-mdb-toggle='".concat(this.toggleElement, "']"))
            }
            update(t = {}) {
                this._options = this._getConfig({ ...this._options,
                    ...t
                })
            }
            _checkToggleButton() {
                null === this.customIcon && (void 0 !== this.dataWithIcon && (this._options.withIcon = null, "true" === this.dataWithIcon && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options))
            }
            _appendToggleButton() {
                var t, e, t = (t = this._options, e = this._toggleButtonId, t = t.iconClass, '\n  <button id="'.concat(e, '" tabindex="0" type="button" class="timepicker-toggle-button" data-mdb-toggle="timepicker"  >\n    <i class="').concat(t, '"></i>\n  </button>\n'));
                this.input.insertAdjacentHTML("afterend", t)
            }
            _getDomElements() {
                this._hour = R.findOne(".".concat(j_)), this._minutes = R.findOne(".".concat(K_)), this._AM = R.findOne(".".concat(E_)), this._PM = R.findOne(".".concat(Q_)), this._wrapper = R.findOne(".".concat(im)), this._modal = R.findOne(".".concat($_)), this._hand = R.findOne(".".concat(H_)), this._circle = R.findOne(".".concat(I_)), this._clock = R.findOne(".".concat(L_)), this._clockInner = R.findOne(".".concat(P_))
            }
            _handlerMaxMinHoursOptions(i, n, s, t, e, o) {
                if (!n && !s) return !0;
                var {
                    format24: a,
                    format12: r,
                    disablePast: l,
                    disableFuture: c
                } = this._options;
                const {
                    _isAmEnabled: h,
                    _isPmEnabled: d
                } = this, u = o.keyCode;
                var p = o.target.classList.contains("timepicker-clock-inner") || o.target.classList.contains("timepicker-time-tips-inner") || o.target.classList.contains("timepicker-tips-inner-element");
                s = b_(s, l, r);
                let f = "" !== (n = y_(n, c, r)) ? 30 * n : "",
                    g = "" !== s ? 30 * s : "";
                i <= 0 && (i = 360 + i);
                r = () => {
                    const t = document.querySelectorAll(".timepicker-tips-element"),
                        e = document.querySelectorAll(".timepicker-tips-inner-element");
                    var i = (t => {
                        let e;
                        return e = t.startsWith("0") ? Number(t.slice(1)) : Number(t), e
                    })(this._hour.innerText);
                    let n, s, o;
                    return 38 === u ? s = 1 : 40 === u && (s = -1), o = 12 === i && 38 === u ? 1 : 0 === i && 38 === u ? 13 : 0 === i && 40 === u ? 23 : 13 === i && 40 === u ? 0 : 1 === i && 40 === u ? 12 : i + s, t.forEach(t => {
                        t.textContent == o && (n = t)
                    }), e.forEach(t => {
                        t.textContent == o && (n = t)
                    }), !n.parentElement.classList.contains("disabled")
                };
                if (a && "keydown" !== o.type && p) return (() => {
                    var t = "" !== s && 12 < s ? 30 * (s - 12) : "",
                        e = "" !== n && 12 < n ? 30 * (n - 12) : "";
                    if (!(t && i < t || e && e < i || n && n < 12)) return !0
                })();
                if ("keydown" === o.type) return r();
                const _ = !e || "PM" === e && d || "" !== s && "AM" === e && h,
                    m = !t || "PM" === t && d || "" !== n && "AM" === t && h;
                return !(s && ("PM" === e && h || _ && i < g) || n && ("AM" === t && d || m && i > f)) || void 0
            }
            _handleKeyboard() {
                I.on(this._document, "keydown", "", t => {
                    var {
                        increment: e,
                        maxTime: i,
                        minTime: n,
                        format12: s,
                        disablePast: o,
                        disableFuture: a
                    } = this._options, [r, l] = __(n, !1), [c, h] = __(i, !1), r = b_(r, o, s), c = y_(c, a, s), d = null === R.findOne(".".concat(tm)), u = null !== R.findOne(".".concat(J_)), n = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), i = R.find(".".concat(tm), this._modal), o = R.find(".".concat(Z_), this._modal), a = R.find(".".concat(J_), this._modal);
                    let p = this._makeHourDegrees(t.target, n, void 0).hour;
                    const {
                        degrees: f,
                        addDegrees: g
                    } = this._makeHourDegrees(t.target, n, void 0);
                    let {
                        minute: _,
                        degrees: m
                    } = this._makeMinutesDegrees(n, void 0);
                    s = this._makeMinutesDegrees(n, void 0).addDegrees;
                    let v = this._makeInnerHoursDegrees(n, void 0)["hour"];
                    if (27 === t.keyCode) {
                        n = R.findOne(".".concat(A_), this._modal);
                        I.trigger(n, "click")
                    } else if (d) {
                        if (u && (39 === t.keyCode && (this._isInner = !1, P.addStyle(this._hand, {
                                height: "calc(40% + 1px)"
                            }), this._hour.textContent = this._setHourOrMinute(12 < p ? 1 : p), this._toggleClassActive(this.hoursArray, this._hour, o), this._toggleClassActive(this.innerHours, this._hour, a)), 37 === t.keyCode && (this._isInner = !0, P.addStyle(this._hand, {
                                height: "21.5%"
                            }), this._hour.textContent = this._setHourOrMinute(24 <= v || "00" === v ? 0 : v), this._toggleClassActive(this.innerHours, this._hour, a), this._toggleClassActive(this.hoursArray, this._hour - 1, o))), 38 === t.keyCode) {
                            if (!this._handlerMaxMinHoursOptions(f + 30, c, r, h, l, t)) return;
                            P.addStyle(this._hand, {
                                transform: "rotateZ(".concat(f + g, "deg)")
                            }), this._isInner ? (v += 1, 24 === v ? v = 0 : 25 !== v && "001" !== v || (v = 13), this._hour.textContent = this._setHourOrMinute(v), this._toggleClassActive(this.innerHours, this._hour, a)) : (p += 1, this._hour.textContent = this._setHourOrMinute(12 < p ? 1 : p), this._toggleClassActive(this.hoursArray, this._hour, o))
                        }
                        40 === t.keyCode && this._handlerMaxMinHoursOptions(f - 30, c, r, h, l, t) && (P.addStyle(this._hand, {
                            transform: "rotateZ(".concat(f - g, "deg)")
                        }), this._isInner ? (--v, 12 === v ? v = 0 : -1 === v && (v = 23), this._hour.textContent = this._setHourOrMinute(v), this._toggleClassActive(this.innerHours, this._hour, a)) : (--p, this._hour.textContent = this._setHourOrMinute(0 === p ? 12 : p), this._toggleClassActive(this.hoursArray, this._hour, o)))
                    } else 38 === t.keyCode && (m += s, P.addStyle(this._hand, {
                        transform: "rotateZ(".concat(m, "deg)")
                    }), _ += 1, e && (_ += 4, "0014" === _ && (_ = 5)), this._minutes.textContent = this._setHourOrMinute(59 < _ ? 0 : _), this._toggleClassActive(this.minutesArray, this._minutes, i), this._toggleBackgroundColorCircle("".concat(tm))), 40 === t.keyCode && (m -= s, P.addStyle(this._hand, {
                        transform: "rotateZ(".concat(m, "deg)")
                    }), e ? _ -= 5 : --_, -1 === _ ? _ = 59 : -5 === _ && (_ = 55), this._minutes.textContent = this._setHourOrMinute(_), this._toggleClassActive(this.minutesArray, this._minutes, i), this._toggleBackgroundColorCircle("".concat(tm)))
                })
            }
            _setActiveClassToTipsOnOpen(t, ...e) {
                var i, n;
                this._isInvalidTimeFormat || (this._options.format24 ? (i = R.find(".".concat(Z_), this._modal), n = R.find(".".concat(J_), this._modal), this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t)) : ([...e].filter(t => ("PM" === t ? P.addClass(this._PM, S_) : "AM" === t ? P.addClass(this._AM, S_) : (P.removeClass(this._AM, S_), P.removeClass(this._PM, S_)), t)), e = R.find(".".concat(Z_), this._modal), this._addActiveClassToTip(e, t)))
            }
            _setTipsAndTimesDependOnInputValue(t, e) {
                var {
                    inline: i,
                    format12: n
                } = this._options;
                this._isInvalidTimeFormat ? (this._hour.textContent = "12", this._minutes.textContent = "00", i || P.addStyle(this._hand, {
                    transform: "rotateZ(0deg)"
                }), n && P.addClass(this._PM, S_)) : (n = 12 < t ? 30 * t - 360 : 30 * t, this._hour.textContent = t, this._minutes.textContent = e, i || (P.addStyle(this._hand, {
                    transform: "rotateZ(".concat(n, "deg)")
                }), P.addStyle(this._circle, {
                    backgroundColor: "#1976d2"
                }), (12 < Number(t) || "00" === t) && P.addStyle(this._hand, {
                    height: "21.5%"
                })))
            }
            _listenToToggleKeydown() {
                I.on(this._element, "keydown", "[data-mdb-toggle='".concat(this.toggleElement, "']"), t => {
                    13 === t.keyCode && (t.preventDefault(), I.trigger(this.elementToggle, "click"))
                })
            }
            _handleOpen() {
                const c = this._getContainer();
                O.on(this._element, "click", "[data-mdb-toggle='".concat(this.toggleElement, "']"), l => {
                    var t;
                    null !== this._options && (t = null !== P.getDataAttribute(this.input, "toggle") ? 200 : 0, setTimeout(() => {
                        P.addStyle(this.elementToggle, {
                            pointerEvents: "none"
                        }), this.elementToggle.blur();
                        let t;
                        t = "" === __(this.input)[0] ? ["12", "00", "PM"] : __(this.input);
                        var {
                            modalID: e,
                            inline: i,
                            format12: n
                        } = this._options, [s, o, a] = t;
                        const r = y("div");
                        (12 < Number(s) || "00" === s) && (this._isInner = !0), this.input.blur(), l.target.blur(), r.innerHTML = (({
                            format24: t,
                            okLabel: e,
                            cancelLabel: i,
                            headID: n,
                            footerID: s,
                            bodyID: o,
                            pickerID: a,
                            clearLabel: r,
                            inline: l,
                            showClearBtn: c,
                            amLabel: h,
                            pmLabel: d
                        }) => {
                            i = "<div id='".concat(a, "' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column position-fixed'>\n               <div class=\"d-flex align-items-center justify-content-center flex-column timepicker-container\">\n                  <div class=\"d-flex flex-column timepicker-elements justify-content-around\">\n                  <div id='").concat(n, "' class='timepicker-head d-flex flex-row align-items-center justify-content-center'\n                  style='padding-right:").concat(t ? 50 : 0, "px'>\n                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly'>\n                      <div class=\"timepicker-current-wrapper\">\n                        <span class=\"position-relative h-100\">\n                          <button type='button' class='timepicker-current timepicker-hour active ripple' tabindex=\"0\">21</button>\n                        </span>\n                        <button type='button' class='timepicker-dot' disabled>:</button>\n                      <span class=\"position-relative h-100\">\n                        <button type='button' class='timepicker-current timepicker-minute ripple' tabindex=\"0\">21</button>\n                      </span>\n                      </div>\n                      ").concat(t ? "" : '<div class="d-flex flex-column justify-content-center timepicker-mode-wrapper">\n                              <button type=\'button\' class="timepicker-hour-mode timepicker-am ripple" tabindex="0">'.concat(h, '</button>\n                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">').concat(d, "</button>\n                            </div>"), "\n                  </div>\n                </div>\n                ").concat(l ? "" : "<div id='".concat(o, "' class='timepicker-clock-wrapper d-flex justify-content-center flex-column align-items-center'>\n                        <div class='timepicker-clock'>\n                          <span class='timepicker-middle-dot position-absolute'></span>\n                          <div class='timepicker-hand-pointer position-absolute'>\n                            <div class='timepicker-circle position-absolute'></div>\n                          </div>\n                          ").concat(t ? '<div class="timepicker-clock-inner"></div>' : "", "\n                         </div>\n                      </div>"), "\n\n              </div>\n                <div id='").concat(s, "' class='timepicker-footer'>\n                  <div class=\"w-100 d-flex justify-content-between\">\n                    ").concat(c ? "<button type='button' class='timepicker-button timepicker-clear ripple' tabindex=\"0\">".concat(r, "</button>") : "", "\n                    <button type='button' class='timepicker-button timepicker-cancel ripple' tabindex=\"0\">").concat(i, "</button>\n                    <button type='button' class='timepicker-button timepicker-submit ripple' tabindex=\"0\">").concat(e, "</button>\n                  </div>\n                </div>\n              </div>\n        </div>"), e = "<div id='".concat(a, "' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column timepicker-wrapper-inline'>\n               <div class=\"d-flex align-items-center justify-content-center flex-column timepicker-container\">\n                  <div class=\"d-flex flex-column timepicker-elements justify-content-around timepicker-elements-inline\">\n                  <div id='").concat(n, "' class='timepicker-head d-flex flex-row align-items-center justify-content-center timepicker-head-inline'\n                  style='padding-right:0px'>\n                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly align-items-center'>\n                      <div class=\"timepicker-current-wrapper\">\n                        <span class=\"position-relative h-100 timepicker-inline-hour-icons\">\n                          <i class=\"fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-hour\"></i>\n                          <button type='button' class='timepicker-current timepicker-hour active ripple timepicker-current-inline' tabindex=\"0\">21</button>\n                          <i class=\"fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-hour\"></i>\n                        </span>\n                        <button type='button' class='timepicker-dot timepicker-current-inline' disabled>:</button>\n                      <span class=\"position-relative h-100  timepicker-inline-minutes-icons\">\n                        <i class=\"fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-minute\"></i>\n                        <button type='button' class='timepicker-current timepicker-minute ripple timepicker-current-inline' tabindex=\"0\">21</button>\n                        <i class=\"fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-minute\"></i>\n                      </span>\n                      </div>\n                      ").concat(t ? "" : '<div class="d-flex justify-content-center timepicker-mode-wrapper">\n                              <button type=\'button\' class="timepicker-hour-mode timepicker-am ripple me-2 ms-4" tabindex="0">'.concat(h, '</button>\n                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">').concat(d, "</button>\n                              <button type='button' class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex=\"0\">").concat(e, "</button>\n                            </div>"), "\n                      ").concat(t ? "<button class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex=\"0\">".concat(e, "</button>") : "", "\n                  </div>\n                </div>\n              </div>\n           </div>\n        </div>\n  ");
                            return l ? e : i
                        })(this._options), P.addClass(r, $_), r.setAttribute("role", "dialog"), r.setAttribute("tabIndex", "-1"), r.setAttribute("id", e), i ? (this._popper = Qn(this.input, r, {
                            placement: "bottom-start"
                        }), c.appendChild(r)) : (c.appendChild(r), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : P.addClass(this._wrapper, "opacity-100"), this._setActiveClassToTipsOnOpen(s, o, a), this._appendTimes(), this._setActiveClassToTipsOnOpen(s, o, a), this._setTipsAndTimesDependOnInputValue(s, o), "" === this.input.value && (o = R.find(".".concat(Z_), this._modal), n && P.addClass(this._PM, S_), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(o, Number(this._hour.textContent))), this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), i ? (this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks()) : (this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard(), P.addStyle(this._hour, {
                            pointerEvents: "none"
                        }), P.addStyle(this._minutes, {
                            pointerEvents: ""
                        })), this._focusTrap = new dg(this._wrapper, {
                            event: "keydown",
                            condition: ({
                                key: t
                            }) => "Tab" === t
                        }), this._focusTrap.trap()
                    }, t))
                })
            }
            _handleInlineClicks() {
                O.on(this._modal, "click mousedown mouseup touchstart touchend contextmenu", ".".concat(Y_, ", .").concat(F_), t => {
                    var {
                        target: e,
                        type: i
                    } = t;
                    let n = Number(this._hour.textContent),
                        s = Number(this._minutes.textContent);
                    var o = "mousedown" === i || "touchstart" === i;
                    const a = t => {
                            let e = t;
                            return 59 < e ? e = 0 : e < 0 && (e = 59), e
                        },
                        r = t => {
                            let e = t;
                            return this._options.format24 ? (24 < e ? e = 1 : e < 0 && (e = 23), 23 < e && (e = 0)) : (12 < e ? e = 1 : e < 1 && (e = 12), 12 < e && (e = 1)), e
                        },
                        l = t => {
                            t = r(t);
                            this._hour.textContent = this._setHourOrMinute(t)
                        },
                        c = t => {
                            t = a(t);
                            this._minutes.textContent = this._setHourOrMinute(t)
                        };
                    var h = () => {
                            n += 1, l(n)
                        },
                        d = () => {
                            s += 1, c(s)
                        },
                        u = () => {
                            --n, l(n)
                        },
                        p = () => {
                            --s, c(s)
                        },
                        t = t => {
                            clearInterval(this._interval), this._interval = setInterval(t, 100)
                        };
                    P.hasClass(e, Y_) ? P.hasClass(e.parentNode, X_) ? o ? t(h) : "mouseup" === i || "touchend" === i || "contextmenu" === i ? clearInterval(this._interval) : h() : o ? t(d) : "mouseup" === i || "touchend" === i || "contextmenu" === i ? clearInterval(this._interval) : d() : P.hasClass(e, F_) && (P.hasClass(e.parentNode, X_) ? o ? t(u) : "mouseup" === i || "touchend" === i ? clearInterval(this._interval) : u() : o ? t(p) : "mouseup" === i || "touchend" === i ? clearInterval(this._interval) : p())
                })
            }
            _handleClose() {
                I.on(this._modal, "click", ".".concat(im, ", .").concat(A_, ", .").concat(M_), ({
                    target: t
                }) => {
                    var e = this._options["closeModalOnBackdropClick"],
                        i = () => {
                            P.addStyle(this.elementToggle, {
                                pointerEvents: "auto"
                            }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), this._focusTrap.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus()
                        };
                    if (P.hasClass(t, M_)) {
                        this._toggleAmPm("PM"), this.input.value = "", P.removeClass(this.input, "active");
                        let t;
                        t = "" === __(this.input)[0] ? ["12", "00", "PM"] : __(this.input);
                        var [n, s, o] = t;
                        this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(n, s, o), this._hour.click()
                    } else(P.hasClass(t, A_) || P.hasClass(t, im) && e) && i()
                })
            }
            showValueInput() {
                return this.input.value
            }
            _handleOkButton() {
                O.on(this._modal, "click", ".".concat(O_), () => {
                    var {
                        maxTime: t,
                        minTime: e
                    } = this._options, {
                        format12: i,
                        format24: n,
                        readOnly: s,
                        focusInputAfterApprove: o,
                        disablePast: a,
                        disableFuture: r
                    } = this._options, l = this._document.querySelector(".".concat(W_, ".").concat(S_)), c = "".concat(this._hour.textContent, ":").concat(this._minutes.textContent), h = Number(this._hour.textContent), d = Number(this._minutes.textContent), e = b_(e, a, i), t = y_(t, r, i), [u, p, f] = __(t, !1), [g, _, a] = __(e, !1), r = h < Number(g), i = h > Number(u);
                    let m = !0;
                    l && (m = f === l.textContent);
                    let v = !0;
                    l && (v = a === l.textContent);
                    u = p < d && h === Number(u), g = d < _ && h === Number(g);
                    if (P.addClass(this.input, "active"), P.addStyle(this.elementToggle, {
                            pointerEvents: "auto"
                        }), "" !== t) {
                        if (m && (i || u)) return;
                        if ("AM" === f && "PM" === l.textContent) return
                    }
                    if ("" !== e) {
                        if (v && (r || g)) return;
                        if ("PM" === a && "AM" === l.textContent) return
                    }
                    void 0 !== (({
                        format12: t,
                        maxTime: e,
                        minTime: i,
                        disablePast: n,
                        disableFuture: s
                    }, o, a, r) => {
                        var l = __(o)[1];
                        i = b_(i, n, t), e = y_(e, s, t);
                        var [o, n, s] = __(e, !1), [t, e, i] = __(i, !1);
                        if (void 0 === s && void 0 === i)
                            if (void 0 === s) {
                                if ("" !== o && "" === t) {
                                    if (Number(a) > Number(o)) return;
                                    if ("" !== n && void 0 === e && Number(a) > Number(o)) return
                                } else if ("" === o && "" !== t && void 0 === n && "" !== e && (Number(a) < Number(t) || Number(a) < Number(t) && r < Number(e))) return
                            } else if (void 0 === i)
                            if ("" !== o && "" === t) {
                                if (Number(a) > Number(o)) return;
                                if ("" !== n && void 0 === e && (Number(a) > Number(o) || r > Number(n))) return
                            } else if ("" === o && "" !== t && void 0 === n && "" !== e && (Number(a) < Number(t) || r < Number(e))) return;
                        return [a, l]
                    })(this._options, this.input, this._hour.textContent, this._minutes.textContent) && (this._isInvalidTimeFormat && P.removeClass(this.input, "is-invalid"), !s && o && this.input.focus(), P.addStyle(this.elementToggle, {
                        pointerEvents: "auto"
                    }), this.input.value = n ? c : null === l ? "".concat(c, " PM") : "".concat(c, " ").concat(l.textContent), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), I.trigger(this.input, "input.mdb.timepicker"))
                })
            }
            _handleHoverInlineBtn() {
                O.on(this._modal, "mouseover mouseleave", ".".concat(N_), ({
                    type: t,
                    target: e
                }) => {
                    const i = R.find(".".concat(V_), this._modal),
                        n = R.find(".".concat(z_), this._modal);
                    "mouseover" === t ? P.hasClass(e, j_) ? i.forEach(t => P.addClass(t, S_)) : n.forEach(t => P.addClass(t, S_)) : P.hasClass(e, j_) ? i.forEach(t => P.removeClass(t, S_)) : n.forEach(t => P.removeClass(t, S_))
                })
            }
            _handleDocumentClickInline() {
                I.on(document, "click", ({
                    target: t
                }) => {
                    !this._modal || this._modal.contains(t) || P.hasClass(t, "timepicker-icon") || (clearInterval(this._interval), P.addStyle(this.elementToggle, {
                        pointerEvents: "auto"
                    }), this._removeModal())
                })
            }
            _handleSwitchHourMinute() {
                var t, i;
                t = "click", i = B_, I.on(document, t, i, ({
                    target: t
                }) => {
                    if (!P.hasClass(t, "active")) {
                        const e = document.querySelectorAll(i);
                        e.forEach(t => {
                            P.hasClass(t, "active") && P.removeClass(t, "active")
                        }), P.addClass(t, "active")
                    }
                }), I.on(this._modal, "click", B_, () => {
                    const s = this._options["format24"],
                        t = R.find(B_, this._modal),
                        o = R.find(".".concat(tm), this._modal),
                        a = R.find(".".concat(Z_), this._modal),
                        e = R.find(".".concat(J_), this._modal),
                        r = Number(this._hour.textContent),
                        l = Number(this._minutes.textContent),
                        i = (t, e) => {
                            a.forEach(t => t.remove()), o.forEach(t => t.remove()), P.addClass(this._hand, em), setTimeout(() => {
                                P.removeClass(this._hand, em)
                            }, 401), this._getAppendClock(t, ".".concat(L_), e);
                            const i = () => {
                                var t = R.find(".".concat(Z_), this._modal),
                                    e = R.find(".".concat(tm), this._modal);
                                this._addActiveClassToTip(t, r), this._addActiveClassToTip(e, l)
                            };
                            if (s) {
                                const n = R.find(".".concat(J_), this._modal);
                                setTimeout(() => {
                                    this._addActiveClassToTip(n, r), i()
                                }, 401)
                            } else setTimeout(() => {
                                i()
                            }, 401)
                        };
                    t.forEach(t => {
                        P.hasClass(t, S_) && (P.hasClass(t, K_) ? (P.addClass(this._hand, em), P.addStyle(this._hand, {
                            transform: "rotateZ(".concat(6 * this._minutes.textContent, "deg)"),
                            height: "calc(40% + 1px)"
                        }), s && 0 < e.length && e.forEach(t => t.remove()), i(this.minutesArray, "".concat(tm), o), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : P.hasClass(t, j_) && (P.addStyle(this._hand, {
                            transform: "rotateZ(".concat(30 * this._hour.textContent, "deg)")
                        }), 12 < Number(this._hour.textContent) ? (P.addStyle(this._hand, {
                            transform: "rotateZ(".concat(30 * this._hour.textContent - 360, "deg)"),
                            height: "21.5%"
                        }), 12 < Number(this._hour.textContent) && P.addStyle(this._hand, {
                            height: "21.5%"
                        })) : P.addStyle(this._hand, {
                            height: "calc(40% + 1px)"
                        }), s && this._getAppendClock(this.innerHours, ".".concat(P_), J_), 0 < e.length && e.forEach(t => t.remove()), i(this.hoursArray, "".concat(Z_), a), P.addStyle(this._hour, {
                            pointerEvents: "none"
                        }), P.addStyle(this._minutes, {
                            pointerEvents: ""
                        })))
                    })
                })
            }
            _handleDisablingTipsMaxTime(t, e, i, n) {
                if (this._options.maxTime || this._options.disableFuture) {
                    const l = R.find(".".concat(Z_));
                    var s, o, a, r = R.find(".".concat(J_));
                    const c = R.find(".".concat(tm));
                    if (!e || e === t) return x_(r, n), x_(l, n), r = c, s = i, o = n, a = this._hour.textContent, void r.forEach(t => {
                        Number(t.textContent) > s && Number(a) == o && P.addClass(t, "disabled")
                    });
                    "AM" === e && "PM" === t && (l.forEach(t => {
                        P.addClass(t, "disabled")
                    }), c.forEach(t => {
                        P.addClass(t, "disabled")
                    }))
                }
            }
            _handleDisablingTipsMinTime(t, e, i, n) {
                if (this._options.minTime || this._options.disablePast) {
                    const l = R.find(".".concat(Z_));
                    var s, o, a, r = R.find(".".concat(J_));
                    const c = R.find(".".concat(tm));
                    e && e !== t ? "PM" === e && "AM" === t && (l.forEach(t => P.addClass(t, "disabled")), c.forEach(t => P.addClass(t, "disabled"))) : (w_(l, n), w_(r, n), r = c, s = i, o = n, a = this._hour.textContent, r.forEach(t => {
                        Number(t.textContent) < s && Number(a) == o && P.addClass(t, "disabled")
                    }))
                }
            }
            _handleSwitchTimeMode() {
                I.on(document, "click", ".".concat(W_), ({
                    target: t
                }) => {
                    var {
                        maxTime: e,
                        minTime: i
                    } = this._options, {
                        disablePast: n,
                        disableFuture: s,
                        format12: o
                    } = this._options, i = b_(i, n, o), e = y_(e, s, o), [a, n, s] = __(e, !1), [o, e, i] = __(i, !1);
                    const r = R.find(".".concat(Z_)),
                        l = R.find(".".concat(tm));
                    if (r.forEach(t => {
                            P.removeClass(t, "disabled")
                        }), l.forEach(t => {
                            P.removeClass(t, "disabled")
                        }), this._handleDisablingTipsMinTime(t.textContent, i, e, o), this._handleDisablingTipsMaxTime(t.textContent, s, n, a), this._toggleAmPm(t.textContent), !P.hasClass(t, S_)) {
                        const c = R.find(".".concat(W_));
                        c.forEach(t => {
                            P.hasClass(t, S_) && P.removeClass(t, S_)
                        }), P.addClass(t, S_)
                    }
                })
            }
            _handleClockClick() {
                var {
                    maxTime: t,
                    minTime: e
                } = this._options, {
                    disablePast: i,
                    disableFuture: n,
                    format12: s
                } = this._options, e = b_(e, i, s), t = y_(t, n, s);
                const m = __(t, !1)[2],
                    v = __(e, !1)[2],
                    b = __(t, !1)[0],
                    y = __(e, !1)[0],
                    x = R.findOne(".".concat(R_));
                O.on(document, "mousedown mouseup mousemove mouseleave mouseover touchstart touchmove touchend", "", t => {
                    g_() || t.preventDefault();
                    const {
                        type: e,
                        target: n
                    } = t;
                    var {
                        closeModalOnMinutesClick: i,
                        switchHoursToMinutesOnClick: s
                    } = this._options, o = null !== R.findOne(".".concat(tm), this._modal), a = null !== R.findOne(".".concat(Z_), this._modal), r = null !== R.findOne(".".concat(J_), this._modal), l = R.find(".".concat(tm), this._modal), c = f_(t, x), h = x.offsetWidth / 2;
                    let d = Math.atan2(c.y - h, c.x - h);
                    g_() && (u = f_(t, x, !0), d = Math.atan2(u.y - h, u.x - h));
                    var u = null;
                    let p = null;
                    if ("mousedown" === e || "mousemove" === e || "touchmove" === e || "touchstart" === e) "mousedown" !== e && "touchstart" !== e && "touchmove" !== e || (this._hasTargetInnerClass(n) || P.hasClass(n, R_) || P.hasClass(n, L_) || P.hasClass(n, tm) || P.hasClass(n, Z_) || P.hasClass(n, I_) || P.hasClass(n, H_) || P.hasClass(n, U_) || P.hasClass(n, q_)) && (this._isMouseMove = !0, g_() && t.touches && (u = t.touches[0].clientX, h = t.touches[0].clientY, p = document.elementFromPoint(u, h)));
                    else if ("mouseup" === e || "touchend" === e) {
                        if (this._isMouseMove = !1, this._hasTargetInnerClass(n) || P.hasClass(n, L_) || P.hasClass(n, Z_) || P.hasClass(n, I_) || P.hasClass(n, H_) || P.hasClass(n, U_) || P.hasClass(n, q_)) {
                            if ((a || r) && s) {
                                s = Number(this._hour.textContent) > b || Number(this._hour.textContent) < y;
                                if (this._options.format24 && "" != b && "" != y && s) return;
                                if (this._options.format24 && "" != b && this._hour.textContent > b) return;
                                if (this._options.format24 && "" != y && this._hour.textContent < y) return
                            }
                            I.trigger(this._minutes, "click")
                        }
                        o && i && (f = R.findOne(".".concat(O_), this._modal), I.trigger(f, "click"))
                    }
                    if (o) {
                        var f = Math.trunc(180 * d / Math.PI) + 90,
                            {
                                degrees: o,
                                minute: f
                            } = this._makeMinutesDegrees(f, void 0);
                        if (void 0 === this._handlerMaxMinMinutesOptions(o, f)) return;
                        const {
                            degrees: g,
                            minute: _
                        } = this._handlerMaxMinMinutesOptions(o, f);
                        if (this._isMouseMove) {
                            if (P.addStyle(this._hand, {
                                    transform: "rotateZ(".concat(g, "deg)")
                                }), void 0 === _) return;
                            this._minutes.textContent = 10 <= _ || "00" === _ ? _ : "0".concat(_), this._toggleClassActive(this.minutesArray, this._minutes, l), this._toggleBackgroundColorCircle("".concat(tm)), this._objWithDataOnChange.degreesMinutes = g, this._objWithDataOnChange.minutes = _
                        }
                    }
                    if (a || r) {
                        let i = Math.trunc(180 * d / Math.PI) + 90;
                        if (i = 30 * Math.round(i / 30), P.addStyle(this._circle, {
                                backgroundColor: "#1976d2"
                            }), void 0 === this._makeHourDegrees(n, i, void 0)) return;
                        r = () => {
                            if (g_() && i && p) {
                                var {
                                    degrees: t,
                                    hour: e
                                } = this._makeHourDegrees(p, i, void 0);
                                return this._handleMoveHand(p, e, t)
                            }
                            var {
                                degrees: e,
                                hour: t
                            } = this._makeHourDegrees(n, i, void 0);
                            return this._handleMoveHand(n, t, e)
                        };
                        this._objWithDataOnChange.degreesHours = i, this._handlerMaxMinHoursOptions(i, b, y, m, v, t) && r()
                    }
                    t.stopPropagation()
                })
            }
            _hasTargetInnerClass(t) {
                return P.hasClass(t, P_) || P.hasClass(t, J_) || P.hasClass(t, G_)
            }
            _handleMoveHand(t, e, i) {
                var n = R.find(".".concat(Z_), this._modal),
                    s = R.find(".".concat(J_), this._modal);
                this._isMouseMove && (this._hasTargetInnerClass(t) ? P.addStyle(this._hand, {
                    height: "21.5%"
                }) : P.addStyle(this._hand, {
                    height: "calc(40% + 1px)"
                }), P.addStyle(this._hand, {
                    transform: "rotateZ(".concat(i, "deg)")
                }), this._hour.textContent = 10 <= e || "00" === e ? e : "0".concat(e), this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, s), this._objWithDataOnChange.hour = 10 <= e || "00" === e ? e : "0".concat(e))
            }
            _handlerMaxMinMinutesOptions(t, e) {
                var {
                    maxTime: i,
                    minTime: n
                } = this._options, {
                    format12: s,
                    increment: o,
                    disablePast: a,
                    disableFuture: r
                } = this._options, n = b_(n, a, s), i = y_(i, r, s), l = __(i, !1)[1], c = __(n, !1)[1], h = __(i, !1)[0], d = __(n, !1)[0], a = __(i, !1)[2], r = __(n, !1)[2], s = "" !== l ? 6 * l : "", l = "" !== c ? 6 * c : "", c = Number(this._hour.textContent);
                if (a || r) {
                    if ("" !== n) {
                        if ("PM" === r && this._isAmEnabled) return;
                        if ("PM" === r && this._isPmEnabled) {
                            if (c < Number(d)) return;
                            if (c <= Number(d) && t <= l - 6) return t
                        } else if ("AM" === r && this._isAmEnabled) {
                            if (c < Number(d)) return;
                            if (c <= Number(d) && t <= l - 6) return t
                        }
                    }
                    if ("" !== i) {
                        if ("AM" === a && this._isPmEnabled) return;
                        if ("PM" === a && this._isPmEnabled) {
                            if (c >= Number(h) && s + 6 <= t) return t
                        } else if ("AM" === a && this._isAmEnabled && c >= Number(h) && s + 6 <= t) return t
                    }
                } else if ("" !== i && "" !== n) {
                    if (h == c && s < t || d == c && t < l) return t
                } else if ("" !== n && c <= Number(d)) {
                    if (t <= l - 6) return t
                } else if ("" !== i && c >= Number(h) && s + 6 <= t) return t;
                return (t = o ? 30 * Math.round(t / 30) : t) <= 0 ? t = 360 + t : 360 <= t && (t = 0), {
                    degrees: t,
                    minute: e
                }
            }
            _removeModal() {
                this._animations ? setTimeout(() => {
                    this._removeModalElements(), this._scrollBar.reset()
                }, 300) : (this._removeModalElements(), this._scrollBar.reset()), O.off(this._document, "click keydown mousedown mouseup mousemove mouseleave mouseover touchmove touchend")
            }
            _removeModalElements() {
                this._modal && this._modal.remove()
            }
            _toggleBackdropAnimation(t = !1) {
                t ? (P.addClass(this._wrapper, "animation"), P.addClass(this._wrapper, "fade-out"), this._wrapper.style.animationDuration = "300ms") : (P.addClass(this._wrapper, "animation"), P.addClass(this._wrapper, "fade-in"), this._wrapper.style.animationDuration = "300ms", this._options.inline || P.addClass(this._clock, D_))
            }
            _addActiveClassToTip(t, e) {
                t.forEach(t => {
                    Number(t.textContent) === Number(e) && P.addClass(t, S_)
                })
            }
            _setHourOrMinute(t) {
                return t < 10 ? "0".concat(t) : t
            }
            _appendTimes() {
                var t = this._options["format24"];
                t ? (this._getAppendClock(this.hoursArray, ".".concat(L_), "".concat(Z_)), this._getAppendClock(this.innerHours, ".".concat(P_), J_)) : this._getAppendClock(this.hoursArray, ".".concat(L_), "".concat(Z_))
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...sm,
                    ...e,
                    ...t
                }, a(k_, t, om), t
            }
            _getContainer() {
                return R.findOne(this._options.container)
            }
            _getValidate(t) {
                const {
                    invalidLabel: e,
                    format24: n,
                    format12: s,
                    appendValidationInfo: o
                } = this._options;
                let a;
                o && (a = y("div"), P.addClass(a, "invalid-feedback"), a.innerHTML = e), O.on(this.input, t, ({
                    target: t
                }) => {
                    if (null !== this._options && "" !== this.input.value) {
                        var e = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/.test(t.value);
                        if (!0 !== /^([01]\d|2[0-3])(:[0-5]\d)$/.test(t.value) && n || !0 !== e && s) o && (P.addClass(this.input, "is-invalid"), this.input.parentNode.insertBefore(a, this.input.nextSibling)), P.addStyle(t, {
                            marginBottom: 0
                        }), P.addStyle(a, {
                            bottom: "-23px"
                        }), this._isInvalidTimeFormat = !0;
                        else {
                            P.removeClass(this.input, "is-invalid"), this._isInvalidTimeFormat = !1;
                            const i = R.findOne(".invalid-feedback");
                            null !== i && i.remove()
                        }
                    }
                })
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, T_);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new am(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i]()
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, T_)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        var rm = am;
        I.on(window, "DOMContentLoaded", () => {
            R.find(".".concat(k_)).forEach(t => {
                let e = am.getInstance(t);
                var i = t.dataset["timepickerFormat24"];
                e = e || ("true" === i ? new am(t, {
                    format24: !0
                }) : new am(t))
            })
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[k_];
                t.fn[k_] = am.jQueryInterface, t.fn[k_].Constructor = am, t.fn[k_].noConflict = () => (t.fn[k_] = e, am.jQueryInterface)
            }
        });
        const lm = "mdb.navbar";
        class cm {
            constructor(t) {
                this._element = t, this._element && p.setData(t, lm, this)
            }
            static get NAME() {
                return "navbar"
            }
            init() {
                this._onScroll(), this._addEvent()
            }
            dispose() {
                this._removeEvent(), p.removeData(this._element, lm), this._element = null
            }
            _addEvent() {
                I.on(window, "scroll", () => this._onScroll())
            }
            _removeEvent() {
                I.off(window, "scroll", this._onScroll)
            }
            _onScroll() {
                0 < window.scrollY ? P.addClass(this._element, "navbar-scrolled") : P.removeClass(this._element, "navbar-scrolled")
            }
            static getInstance(t) {
                return p.getData(t, lm)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".".concat("navbar-scroll")).forEach(t => {
            new cm(t).init()
        });
        var hm = cm;
        const dm = "infiniteScroll",
            um = "mdb.infiniteScroll";
        const pm = {
                infiniteDirection: "y"
            },
            fm = {
                infiniteDirection: "string"
            };
        class gm {
            constructor(t, e) {
                this._element = t, this._element && p.setData(t, um, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init()
            }
            static get NAME() {
                return dm
            }
            get rect() {
                return this._element.getBoundingClientRect()
            }
            get condition() {
                return this._element === window ? window.scrollY + window.innerHeight === document.documentElement.scrollHeight : "x" === this._options.infiniteDirection ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : this.rect.height + this._element.scrollTop >= this._element.scrollHeight
            }
            dispose() {
                I.off(this._element, "scroll", this.scrollHandler), p.removeData(this._element, um), this._element = null
            }
            _init() {
                I.on(this._element, "scroll", () => this._scrollHandler())
            }
            _scrollHandler() {
                this.condition && I.trigger(this._element, "complete.mdb.infiniteScroll"), I.off(this._element, "scroll", this.scrollHandler)
            }
            _getConfig(t) {
                t = { ...pm,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(dm, t, fm), t
            }
            static getInstance(t) {
                return p.getData(t, um)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, um);
                    var e = "object" == typeof i && i;
                    if (t = t || new gm(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](this)
                    }
                })
            }
        }
        R.find(".infinite-scroll").forEach(t => {
            let e = gm.getInstance(t);
            return e = e || new gm(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[dm];
                t.fn[dm] = gm.jQueryInterface, t.fn[dm].Constructor = gm, t.fn[dm].noConflict = () => (t.fn[dm] = e, gm.jQueryInterface)
            }
        });
        var _m = gm;
        const mm = "lazyLoad",
            vm = "mdb.lazyLoad",
            bm = ["img", "video"],
            ym = {
                lazySrc: "(string || null)",
                lazyDelay: "number",
                lazyAnimation: "string",
                lazyOffset: "number",
                lazyPlaceholder: "(string || undefined)",
                lazyError: "(string || undefined)"
            },
            xm = {
                lazySrc: null,
                lazyDelay: 500,
                lazyAnimation: "fade-in",
                lazyOffset: 0
            };
        class wm {
            constructor(t, e) {
                this._element = t, this._element && p.setData(t, vm, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init()
            }
            static get NAME() {
                return mm
            }
            get offsetValues() {
                return this._element.getBoundingClientRect()
            }
            get inViewport() {
                if (this.parent) {
                    var t = this.parent.getBoundingClientRect();
                    return 0 < t.y && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight
                }
                return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && 0 <= this.offsetValues.bottom
            }
            get parent() {
                var [t] = R.parents(this._element, ".lazy");
                return t
            }
            get node() {
                return this._element.nodeName
            }
            get isContainer() {
                return !R.matches(this._element, bm)
            }
            dispose() {
                p.removeData(this._element, vm), this._animation && (this._animation.dispose(), this._animation = null), this._element = null, this._childrenInstances && this._childrenInstances.forEach(t => t.dispose())
            }
            _init() {
                P.addClass(this._element, "lazy"), this.isContainer ? this._setupContainer() : this._setupElement()
            }
            _setupElement() {
                I.on(this._element, "error", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new Ga(this._element, {
                    animation: this._options.lazyAnimation,
                    start: "onLoad"
                }), I.one(this._element, "load", () => this._scrollHandler()), this.parent && I.on(this.parent, "scroll", this.scrollHandler), I.on(window, "scroll", this.scrollHandler)
            }
            _scrollHandler() {
                this.inViewport && (this._timeout = setTimeout(() => {
                    this._setSrc(), this._element.classList.remove("lazy"), this._removeAttrs(), this._animation.init()
                }, this._options.lazyDelay), this.parent && I.off(this.parent, "scroll", this.scrollHandler), I.off(window, "scroll", this.scrollHandler))
            }
            _setElementError() {
                this._element.setAttribute("src", this._options.lazyError), I.trigger(this._element, "onError.mdb.lazy")
            }
            _setSrc() {
                this._element.setAttribute("src", this._options.lazySrc), I.trigger(this._element, "onLoad.mdb.lazy")
            }
            _setPlaceholder() {
                "IMG" === this.node ? this._element.setAttribute("src", this._options.lazyPlaceholder) : "VIDEO" === this.node && this._element.setAttribute("poster", this._options.lazyPlaceholder)
            }
            _removeAttrs() {
                ["src", "delay", "animation", "placeholder", "offset", "error"].forEach(t => {
                    P.removeDataAttribute(this._element, "lazy-".concat(t))
                })
            }
            _setupContainer() {
                this._childrenInstances = R.children(this._element, bm).map(t => new wm(t, this._options))
            }
            _getConfig(t) {
                t = { ...xm,
                    ...t,
                    ...P.getDataAttributes(this._element)
                };
                return a(mm, t, ym), t
            }
            static getInstance(t) {
                return p.getData(t, vm)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, vm);
                    var e = "object" == typeof i && i;
                    if (t = t || new wm(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](this)
                    }
                })
            }
        }
        R.find(".lazy").forEach(t => {
            let e = wm.getInstance(t);
            return e = e || new wm(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[mm];
                t.fn[mm] = wm.jQueryInterface, t.fn[mm].Constructor = wm, t.fn[mm].noConflict = () => (t.fn[mm] = e, wm.jQueryInterface)
            }
        });
        var Cm = wm;

        function km(t) {
            return t.getDate()
        }

        function Tm(t) {
            return t.getDay()
        }

        function Sm(t) {
            return t.getMonth()
        }

        function Em(t) {
            return t.getFullYear()
        }

        function Am(t) {
            return Lm((t = t).getFullYear(), t.getMonth() + 1, 0).getDate()
        }

        function Mm() {
            return new Date
        }

        function Om(t, e) {
            return Im(t, 12 * e)
        }

        function Im(t, e) {
            const i = Lm(t.getFullYear(), t.getMonth() + e, t.getDate());
            return km(t) !== km(i) && i.setDate(0), i
        }

        function Dm(t, e) {
            return Lm(t.getFullYear(), t.getMonth(), t.getDate() + e)
        }

        function Lm(t, e, i) {
            const n = new Date(t, e, i);
            return 0 <= t && t < 100 && n.setFullYear(n.getFullYear() - 1900), n
        }

        function Pm(t) {
            t = t.split("-");
            return Lm(t[0], t[1], t[2])
        }

        function Rm(t, e) {
            return Em(t) - Em(e) || Sm(t) - Sm(e) || km(t) - km(e)
        }

        function Bm(t, e) {
            return t.setHours(0, 0, 0, 0), e.setHours(0, 0, 0, 0), t.getTime() === e.getTime()
        }

        function Nm(t, e) {
            return ((Em(t) - function(t, e, i) {
                let n = 0;
                i ? (i = Em(i), n = i - t + 1) : e && (n = Em(e));
                return n
            }()) % e + e) % e
        }

        function Hm(t, e, i, n, s, o) {
            const a = new Date;
            a.setHours(0, 0, 0, 0);
            e = e && Rm(t, e) <= -1, i = i && 1 <= Rm(t, i), s = s && Rm(t, a) <= -1, o = o && 1 <= Rm(t, a), t = n && !1 === n(t);
            return e || i || t || s || o
        }

        function jm(t, e, i, n, s, o) {
            var a = new Date,
                r = n && Em(n),
                l = n && Sm(n),
                c = i && Em(i),
                n = i && Sm(i),
                i = Em(a),
                a = Sm(a);
            return l && r && (r < e || e === r && l < t) || n && c && (e < c || e === c && t < n) || s && (e < i || e === i && t < a) || o && (i < e || e === i && a < t)
        }

        function Wm(t, e, i, n, s) {
            var o = e && Em(e),
                e = i && Em(i),
                i = Em(new Date);
            return e && e < t || o && t < o || n && t < i || s && i < t
        }

        function Fm(t, e, i, n, s, o, a, r) {
            return "days" === i ? Em(t) === Em(e) && Sm(t) === Sm(e) : "months" === i ? Em(t) === Em(e) : "years" === i && (Em(e) >= r && Em(e) <= a)
        }

        function Vm(t, e, i, n, s, o, a, r, l, c) {
            let h;
            return h = a.inline ? '\n    <div class="datepicker-main">\n      '.concat(Ym(e, i, a), '\n      <div class="datepicker-view" tabindex="0">\n        ').concat(zm(t, i, n, s, o, a, r, l, c), "\n      </div>\n    </div>\n  ") : '\n      <div class="datepicker-main">\n        '.concat(Ym(e, i, a), '\n        <div class="datepicker-view" tabindex="0">\n          ').concat(zm(t, i, n, s, o, a, r, l, c), "\n        </div>\n        ").concat('\n        <div class="datepicker-footer">\n          <button class="datepicker-footer-btn datepicker-clear-btn" aria-label="'.concat((a = a).clearBtnLabel, '">').concat(a.clearBtnText, '</button>\n          <button class="datepicker-footer-btn datepicker-cancel-btn" aria-label="').concat(a.cancelBtnLabel, '">').concat(a.cancelBtnText, '</button>\n          <button class="datepicker-footer-btn datepicker-ok-btn" aria-label="').concat(a.okBtnLabel, '">').concat(a.okBtnText, "</button>\n        </div>\n      "), "\n      </div>\n    "), h
        }

        function zm(t, e, i, n, s, o, a, r, l) {
            let c;
            return c = "days" === o.view ? Xm(t, i, o) : "months" === o.view ? Um(e, n, s, o, a) : Km(t, n, o, r, l), c
        }

        function Ym(t, e, i) {
            return '\n    <div class="datepicker-date-controls">\n      <button class="datepicker-view-change-button" aria-label="'.concat(i.switchToMultiYearViewLabel, '">\n        ').concat(i.monthsFull[t], " ").concat(e, '\n      </button>\n      <div class="datepicker-arrow-controls">\n        <button class="datepicker-previous-button" aria-label="').concat(i.prevMonthLabel, '"></button>\n        <button class="datepicker-next-button" aria-label="').concat(i.nextMonthLabel, '"></button>\n      </div>\n    </div>\n    ')
        }

        function Xm(t, e, i) {
            const n = function(t, e, i) {
                    const n = [],
                        s = Sm(t),
                        o = Sm(Im(t, -1)),
                        a = Sm(Im(t, 1)),
                        r = Em(t),
                        l = function(t, e, i) {
                            i = 0 < (i = i.startDay) ? 7 - i : 0;
                            const n = new Date(t, e);
                            return 7 <= (i = n.getDay() + i) ? i - 7 : i
                        }(r, s, i),
                        c = Am(t),
                        h = Am(Im(t, -1));
                    let d = 1,
                        u = !1;
                    for (let t = 1; t < 7; t++) {
                        const m = [];
                        if (1 === t) {
                            for (let t = h - l + 1; t <= h; t++) {
                                var p = Lm(r, o, t);
                                m.push({
                                    date: p,
                                    currentMonth: u,
                                    isSelected: e && Bm(p, e),
                                    isToday: Bm(p, Mm()),
                                    dayNumber: km(p),
                                    disabled: Hm(p, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                                })
                            }
                            u = !0;
                            var f = 7 - m.length;
                            for (let t = 0; t < f; t++) {
                                var g = Lm(r, s, d);
                                m.push({
                                    date: g,
                                    currentMonth: u,
                                    isSelected: e && Bm(g, e),
                                    isToday: Bm(g, Mm()),
                                    dayNumber: km(g),
                                    disabled: Hm(g, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                                }), d++
                            }
                        } else
                            for (let t = 1; t < 8; t++) {
                                d > c && (d = 1, u = !1);
                                var _ = Lm(r, u ? s : a, d);
                                m.push({
                                    date: _,
                                    currentMonth: u,
                                    isSelected: e && Bm(_, e),
                                    isToday: Bm(_, Mm()),
                                    dayNumber: km(_),
                                    disabled: Hm(_, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                                }), d++
                            }
                        n.push(m)
                    }
                    return n
                }(t, e, i),
                s = i.weekdaysNarrow;
            t = "\n      <tr>\n        ".concat(s.map((t, e) => '<th class="datepicker-day-heading" scope="col" aria-label="'.concat(i.weekdaysFull[e], '">').concat(t, "</th>")).join(""), "\n      </tr>\n    "), e = n.map(t => "\n        <tr>\n          ".concat(t.map(t => '\n              <td\n              class="datepicker-cell datepicker-small-cell datepicker-day-cell\n              '.concat(t.currentMonth ? "" : "disabled", " ").concat(t.disabled ? "disabled" : "", "\n              ").concat(t.isToday && "current", " ").concat(t.isSelected && "selected", '"\n              data-mdb-date="').concat(Em(t.date), "-").concat(Sm(t.date), "-").concat(km(t.date), '"\n              aria-label="').concat(t.date, '"\n              aria-selected="').concat(t.isSelected, '">\n                <div\n                  class="datepicker-cell-content datepicker-small-cell-content"\n                  style="').concat(t.currentMonth ? "display: block" : "display: none", '">\n                  ').concat(t.dayNumber, "\n                  </div>\n              </td>\n            ")).join(""), "\n        </tr>\n      ")).join("");
            return '\n      <table class="datepicker-table">\n        <thead>\n          '.concat(t, '\n        </thead>\n        <tbody class="datepicker-table-body">\n         ').concat(e, "\n        </tbody>\n      </table>\n    ")
        }

        function Um(i, n, s, o, t) {
            const e = function(e, i) {
                    const n = [];
                    let s = [];
                    for (let t = 0; t < e.monthsShort.length; t++) {
                        var o;
                        s.push(e.monthsShort[t]), s.length === i && (o = s, n.push(o), s = [])
                    }
                    return n
                }(o, t),
                a = Sm(Mm()),
                r = Em(Mm());
            t = "\n      ".concat(e.map(t => "\n          <tr>\n            ".concat(t.map(t => {
                var e = o.monthsShort.indexOf(t);
                return '\n                <td class="datepicker-cell datepicker-large-cell datepicker-month-cell '.concat(jm(e, i, o.min, o.max, o.disablePast, o.disableFuture) ? "disabled" : "", " ").concat(e === s && i === n ? "selected" : "", " ").concat(e === a && i === r ? "current" : "", '" data-mdb-month="').concat(e, '" data-mdb-year="').concat(i, '" aria-label="').concat(t, ", ").concat(i, '">\n                  <div class="datepicker-cell-content datepicker-large-cell-content">').concat(t, "</div>\n                </td>\n              ")
            }).join(""), "\n          </tr>\n        ")).join(""), "\n    ");
            return '\n      <table class="datepicker-table">\n        <tbody class="datepicker-table-body">\n         '.concat(t, "\n        </tbody>\n      </table>\n    ")
        }

        function Km(t, e, i, n, s) {
            const o = function(t, e, i) {
                    const n = [],
                        s = Em(t),
                        o = Nm(t, e),
                        a = s - o;
                    let r = [];
                    for (let t = 0; t < e; t++) {
                        var l;
                        r.push(a + t), r.length === i && (l = r, n.push(l), r = [])
                    }
                    return n
                }(t, n, s),
                a = Em(Mm());
            s = "\n    ".concat(o.map(t => "\n        <tr>\n          ".concat(t.map(t => '\n              <td class="datepicker-cell datepicker-large-cell datepicker-year-cell '.concat(Wm(t, i.min, i.max, i.disablePast, i.disableFuture) ? "disabled" : "", " ").concat(t === e ? "selected" : "", " ").concat(t === a ? "current" : "", '" aria-label="').concat(t, '" data-mdb-year="').concat(t, '">\n                <div class="datepicker-cell-content datepicker-large-cell-content">').concat(t, "</div>\n              </td>\n            ")).join(""), "\n        </tr>\n      ")).join(""), "\n  ");
            return '\n      <table class="datepicker-table">\n        <tbody class="datepicker-table-body">\n        '.concat(s, "\n        </tbody>\n      </table>\n    ")
        }
        const $m = "datepicker",
            Qm = "mdb.datepicker";
        i = ".".concat(Qm);
        const qm = "close".concat(i),
            Zm = "open".concat(i),
            Gm = "dateChange".concat(i),
            Jm = "click".concat(i).concat(".data-api");
        const tv = '[data-mdb-toggle="datepicker"]',
            ev = {
                title: "Select date",
                container: "body",
                disablePast: !1,
                disableFuture: !1,
                monthsFull: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                weekdaysFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
                okBtnText: "Ok",
                clearBtnText: "Clear",
                cancelBtnText: "Cancel",
                okBtnLabel: "Confirm selection",
                clearBtnLabel: "Clear selection",
                cancelBtnLabel: "Cancel selection",
                nextMonthLabel: "Next month",
                prevMonthLabel: "Previous month",
                nextYearLabel: "Next year",
                prevYearLabel: "Previous year",
                nextMultiYearLabel: "Next 24 years",
                prevMultiYearLabel: "Previous 24 years",
                switchToMultiYearViewLabel: "Choose year and month",
                switchToMonthViewLabel: "Choose date",
                switchToDayViewLabel: "Choose date",
                startDate: null,
                startDay: 0,
                format: "dd/mm/yyyy",
                view: "days",
                min: null,
                max: null,
                filter: null,
                inline: !1,
                toggleButton: !0,
                disableToggleButton: !1,
                disableInput: !1,
                animations: !0
            },
            iv = {
                title: "string",
                container: "string",
                disablePast: "boolean",
                disableFuture: "boolean",
                monthsFull: "array",
                monthsShort: "array",
                weekdaysFull: "array",
                weekdaysShort: "array",
                weekdaysNarrow: "array",
                okBtnText: "string",
                clearBtnText: "string",
                cancelBtnText: "string",
                okBtnLabel: "string",
                clearBtnLabel: "string",
                cancelBtnLabel: "string",
                nextMonthLabel: "string",
                prevMonthLabel: "string",
                nextYearLabel: "string",
                prevYearLabel: "string",
                nextMultiYearLabel: "string",
                prevMultiYearLabel: "string",
                switchToMultiYearViewLabel: "string",
                switchToMonthViewLabel: "string",
                switchToDayViewLabel: "string",
                startDate: "(null|string|date)",
                startDay: "number",
                format: "string",
                view: "string",
                min: "(null|date|string)",
                max: "(null|date|string)",
                filter: "(null|function)",
                inline: "boolean",
                toggleButton: "boolean",
                disableToggleButton: "boolean",
                disableInput: "boolean",
                animations: "boolean"
            };
        class nv {
            constructor(t, e) {
                this._element = t, this._input = R.findOne("input", this._element), this._options = this._getConfig(e), this._activeDate = new Date, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = d("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new pe, this._element && p.setData(t, Qm, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true")
            }
            static get NAME() {
                return $m
            }
            get container() {
                return R.findOne("".concat(".datepicker-modal-container", "-").concat(this._toggleButtonId)) || R.findOne("".concat(".datepicker-dropdown-container", "-").concat(this._toggleButtonId))
            }
            get options() {
                return this._options
            }
            get activeCell() {
                let t;
                return "days" === this._view && (t = this._getActiveDayCell()), "months" === this._view && (t = this._getActiveMonthCell()), "years" === this._view && (t = this._getActiveYearCell()), t
            }
            get activeDay() {
                return km(this._activeDate)
            }
            get activeMonth() {
                return Sm(this._activeDate)
            }
            get activeYear() {
                return Em(this._activeDate)
            }
            get firstYearInView() {
                return this.activeYear - Nm(this._activeDate, 24)
            }
            get lastYearInView() {
                return this.firstYearInView + 24 - 1
            }
            get viewChangeButton() {
                return R.findOne(".datepicker-view-change-button", this.container)
            }
            get previousButton() {
                return R.findOne(".datepicker-previous-button", this.container)
            }
            get nextButton() {
                return R.findOne(".datepicker-next-button", this.container)
            }
            get okButton() {
                return R.findOne(".datepicker-ok-btn", this.container)
            }
            get cancelButton() {
                return R.findOne(".datepicker-cancel-btn", this.container)
            }
            get clearButton() {
                return R.findOne(".datepicker-clear-btn", this.container)
            }
            get datesContainer() {
                return R.findOne(".datepicker-view", this.container)
            }
            get toggleButton() {
                return R.findOne(".datepicker-toggle-button", this._element)
            }
            update(t = {}) {
                this._options = this._getConfig({ ...this._options,
                    ...t
                })
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...ev,
                    ...e,
                    ...t
                }, a($m, t, iv), t.max && "string" == typeof t.max && (t.max = new Date(t.max)), t.min && "string" == typeof t.min && (t.min = new Date(t.min)), t.startDay && 0 !== t.startDay && (e = this._getNewDaysOrderArray(t), t.weekdaysNarrow = e), t
            }
            _getContainer() {
                return R.findOne(this._options.container)
            }
            _getNewDaysOrderArray(t) {
                var e = t.startDay;
                const i = t.weekdaysNarrow;
                return i.slice(e).concat(i.slice(0, e))
            }
            _init() {
                !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown()
            }
            _appendToggleButton() {
                var t = '\n    <button id="'.concat(this._toggleButtonId, '" type="button" class="datepicker-toggle-button" data-mdb-toggle="datepicker">\n      <i class="far fa-calendar datepicker-toggle-icon"></i>\n    </button>\n  ');
                this._element.insertAdjacentHTML("beforeend", t), P.addClass(this._input, "form-icon-trailing")
            }
            open() {
                if (!this._input.readOnly && !this._input.disabled) {
                    var t = I.trigger(this._element, Zm);
                    if (!this._isOpen && !t.defaultPrevented) {
                        this._setInitialDate();
                        const e = (t = y("div"), P.addClass(t, "datepicker-backdrop"), t);
                        t = function(t, e, i, n, s, o, a, r, l) {
                            var c = Sm(t),
                                h = Em(t),
                                d = km(t),
                                u = Tm(t);
                            const p = y("div");
                            var f, g, _ = "\n        ".concat(Vm(t, c, h, e, i, n, s, o, a, r), "\n    "),
                                r = "\n      ".concat((f = d, g = u, d = c, '\n      <div class="datepicker-header">\n        <div class="datepicker-title">\n          <span class="datepicker-title-text">'.concat((u = s).title, '</span>\n        </div>\n        <div class="datepicker-date">\n          <span class="datepicker-date-text">').concat(u.weekdaysShort[g], ", ").concat(u.monthsShort[d], " ").concat(f, "</span>\n        </div>\n      </div>\n    ")), "\n      ").concat(Vm(t, c, h, e, i, n, s, o, a, r), "\n    ");
                            return s.inline ? (P.addClass(p, "datepicker-dropdown-container"), P.addClass(p, "datepicker-dropdown-container-".concat(l)), p.innerHTML = _) : (P.addClass(p, "datepicker-modal-container"), P.addClass(p, "datepicker-modal-container-".concat(l)), p.innerHTML = r), p
                        }(this._activeDate, this._selectedDate, this._selectedYear, this._selectedMonth, this._options, 4, 24, 4, this._toggleButtonId);
                        this._options.inline ? this._openDropdown(t) : (this._openModal(e, t), this._scrollBar.hide()), this._animations && (P.addClass(this.container, "animation"), P.addClass(this.container, "fade-in"), this.container.style.animationDuration = "300ms", P.addClass(e, "animation"), P.addClass(e, "fade-in"), e.style.animationDuration = "150ms"), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
                            this._listenToOutsideClick()
                        }, 0)
                    }
                }
            }
            _openDropdown(t) {
                this._popper = Qn(this._input, t, {
                    placement: "bottom-start"
                });
                const e = this._getContainer();
                e.appendChild(t)
            }
            _openModal(t, e) {
                const i = this._getContainer();
                i.appendChild(t), i.appendChild(e)
            }
            _setFocusTrap(t) {
                this._focusTrap = new dg(t, {
                    event: "keydown",
                    condition: t => "Tab" === t.key
                }), this._focusTrap.trap()
            }
            _listenToUserInput() {
                I.on(this._input, "input", t => {
                    this._handleUserInput(t.target.value)
                })
            }
            _listenToToggleClick() {
                I.on(this._element, Jm, tv, t => {
                    t.preventDefault(), this.open()
                })
            }
            _listenToToggleKeydown() {
                I.on(this._element, "keydown", tv, t => {
                    13 !== t.keyCode || this._isOpen || this.open()
                })
            }
            _listenToDateSelection() {
                I.on(this.datesContainer, "click", t => {
                    this._handleDateSelection(t)
                })
            }
            _handleDateSelection(t) {
                var e = ("DIV" === t.target.nodeName ? t.target.parentNode : t.target).dataset,
                    i = "DIV" === t.target.nodeName ? t.target.parentNode : t.target;
                e.mdbDate && this._pickDay(e.mdbDate, i), e.mdbMonth && e.mdbYear && (t = parseInt(e.mdbMonth, 10), i = parseInt(e.mdbYear, 10), this._pickMonth(t, i)), e.mdbYear && !e.mdbMonth && (e = parseInt(e.mdbYear, 10), this._pickYear(e)), this._options.inline || this._updateHeaderDate(this._activeDate, this._options.monthsShort, this._options.weekdaysShort)
            }
            _updateHeaderDate(t, e, i) {
                const n = R.findOne(".datepicker-date-text", this.container);
                var s = Sm(t),
                    o = km(t),
                    t = Tm(t);
                n.innerHTML = "".concat(i[t], ", ").concat(e[s], " ").concat(o)
            }
            _addControlsListeners() {
                I.on(this.nextButton, "click", () => {
                    "days" === this._view ? this.nextMonth() : "years" === this._view ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState()
                }), I.on(this.previousButton, "click", () => {
                    "days" === this._view ? this.previousMonth() : "years" === this._view ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState()
                }), I.on(this.viewChangeButton, "click", () => {
                    "days" === this._view ? this._changeView("years") : "years" !== this._view && "months" !== this._view || this._changeView("days")
                }), this._options.inline || this._listenToFooterButtonsClick()
            }
            _listenToFooterButtonsClick() {
                I.on(this.okButton, "click", () => this.handleOk()), I.on(this.cancelButton, "click", () => this.handleCancel()), I.on(this.clearButton, "click", () => this.handleClear())
            }
            _listenToOutsideClick() {
                I.on(document, Jm, t => {
                    var e = t.target === this.container,
                        t = this.container && this.container.contains(t.target);
                    e || t || this.close()
                })
            }
            _listenToEscapeClick() {
                I.on(document, "keydown", t => {
                    27 === t.keyCode && this._isOpen && this.close()
                })
            }
            _listenToKeyboardNavigation() {
                I.on(this.datesContainer, "keydown", t => {
                    this._handleKeydown(t)
                })
            }
            _listenToDatesContainerFocus() {
                I.on(this.datesContainer, "focus", () => {
                    this._focusActiveCell(this.activeCell)
                })
            }
            _listenToDatesContainerBlur() {
                I.on(this.datesContainer, "blur", () => {
                    this._removeCurrentFocusStyles()
                })
            }
            _handleKeydown(t) {
                "days" === this._view && this._handleDaysViewKeydown(t), "months" === this._view && this._handleMonthsViewKeydown(t), "years" === this._view && this._handleYearsViewKeydown(t)
            }
            _handleDaysViewKeydown(t) {
                var e = this._activeDate,
                    i = this.activeCell;
                switch (t.keyCode) {
                    case 37:
                        this._activeDate = Dm(this._activeDate, h ? 1 : -1);
                        break;
                    case 39:
                        this._activeDate = Dm(this._activeDate, h ? -1 : 1);
                        break;
                    case 38:
                        this._activeDate = Dm(this._activeDate, -7);
                        break;
                    case 40:
                        this._activeDate = Dm(this._activeDate, 7);
                        break;
                    case 36:
                        this._activeDate = Dm(this._activeDate, 1 - km(this._activeDate));
                        break;
                    case 35:
                        this._activeDate = Dm(this._activeDate, Am(this._activeDate) - km(this._activeDate));
                        break;
                    case 33:
                        this._activeDate = Im(this._activeDate, -1);
                        break;
                    case 34:
                        this._activeDate = Im(this._activeDate, 1);
                        break;
                    case 13:
                    case 32:
                        return this._selectDate(this._activeDate), this._handleDateSelection(t), void t.preventDefault();
                    default:
                        return
                }
                Fm(e, this._activeDate, this._view, 0, this._options.min, this._options.max) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault()
            }
            _asyncFocusDatesContainer() {
                setTimeout(() => {
                    this.datesContainer.focus()
                }, 0)
            }
            _focusActiveCell(t) {
                t && P.addClass(t, "focused")
            }
            _removeHighlightFromCell(t) {
                t && t.classList.remove("focused")
            }
            _getActiveDayCell() {
                var t = R.find("td", this.datesContainer);
                return Array.from(t).find(t => {
                    return Bm(Pm(t.dataset.mdbDate), this._activeDate)
                })
            }
            _handleMonthsViewKeydown(t) {
                var e = this._activeDate,
                    i = this.activeCell;
                switch (t.keyCode) {
                    case 37:
                        this._activeDate = Im(this._activeDate, h ? 1 : -1);
                        break;
                    case 39:
                        this._activeDate = Im(this._activeDate, h ? -1 : 1);
                        break;
                    case 38:
                        this._activeDate = Im(this._activeDate, -4);
                        break;
                    case 40:
                        this._activeDate = Im(this._activeDate, 4);
                        break;
                    case 36:
                        this._activeDate = Im(this._activeDate, -this.activeMonth);
                        break;
                    case 35:
                        this._activeDate = Im(this._activeDate, 11 - this.activeMonth);
                        break;
                    case 33:
                        this._activeDate = Om(this._activeDate, -1);
                        break;
                    case 34:
                        this._activeDate = Om(this._activeDate, 1);
                        break;
                    case 13:
                    case 32:
                        return void this._selectMonth(this.activeMonth);
                    default:
                        return
                }
                Fm(e, this._activeDate, this._view, 0, this._options.min, this._options.max) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault()
            }
            _getActiveMonthCell() {
                var t = R.find("td", this.datesContainer);
                return Array.from(t).find(t => {
                    var e = parseInt(t.dataset.mdbYear, 10),
                        t = parseInt(t.dataset.mdbMonth, 10);
                    return e === this.activeYear && t === this.activeMonth
                })
            }
            _handleYearsViewKeydown(t) {
                var e = this._activeDate,
                    i = this.activeCell;
                switch (t.keyCode) {
                    case 37:
                        this._activeDate = Om(this._activeDate, h ? 1 : -1);
                        break;
                    case 39:
                        this._activeDate = Om(this._activeDate, h ? -1 : 1);
                        break;
                    case 38:
                        this._activeDate = Om(this._activeDate, -4);
                        break;
                    case 40:
                        this._activeDate = Om(this._activeDate, 4);
                        break;
                    case 36:
                        this._activeDate = Om(this._activeDate, -Nm(this._activeDate, 24));
                        break;
                    case 35:
                        this._activeDate = Om(this._activeDate, 24 - Nm(this._activeDate, 24) - 1);
                        break;
                    case 33:
                        this._activeDate = Om(this._activeDate, -24);
                        break;
                    case 34:
                        this._activeDate = Om(this._activeDate, 24);
                        break;
                    case 13:
                    case 32:
                        return void this._selectYear(this.activeYear);
                    default:
                        return
                }
                Fm(e, this._activeDate, this._view, 0, this._options.min, this._options.max) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault()
            }
            _getActiveYearCell() {
                var t = R.find("td", this.datesContainer);
                return Array.from(t).find(t => {
                    return parseInt(t.dataset.mdbYear, 10) === this.activeYear
                })
            }
            _setInitialDate() {
                this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = new Date
            }
            close() {
                var t = I.trigger(this._element, qm);
                this._isOpen && !t.defaultPrevented && (this._removeDatepickerListeners(), this._animations && (P.addClass(this.container, "animation"), P.addClass(this.container, "fade-out")), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, (this.toggleButton || this._input).focus())
            }
            _closeDropdown() {
                const t = R.findOne(".datepicker-dropdown-container"),
                    e = this._getContainer();
                this._animations ? t.addEventListener("animationend", () => {
                    t && e.removeChild(t), this._popper && this._popper.destroy()
                }) : (t && e.removeChild(t), this._popper && this._popper.destroy()), this._removeFocusTrap()
            }
            _closeModal() {
                const t = R.findOne(".datepicker-backdrop"),
                    e = R.findOne(".datepicker-modal-container");
                e && t && (this._animations && (P.addClass(t, "animation"), P.addClass(t, "fade-out")), this._animations ? t.addEventListener("animationend", () => {
                    this._removePicker(t, e), this._scrollBar.reset()
                }) : (this._removePicker(t, e), this._scrollBar.reset()))
            }
            _removePicker(t, e) {
                const i = this._getContainer();
                i.removeChild(t), i.removeChild(e)
            }
            _removeFocusTrap() {
                this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null)
            }
            _removeDatepickerListeners() {
                I.off(this.nextButton, "click"), I.off(this.previousButton, "click"), I.off(this.viewChangeButton, "click"), I.off(this.okButton, "click"), I.off(this.cancelButton, "click"), I.off(this.clearButton, "click"), I.off(this.datesContainer, "click"), I.off(this.datesContainer, "keydown"), I.off(this.datesContainer, "focus"), I.off(this.datesContainer, "blur"), I.off(document, Jm)
            }
            dispose() {
                this._isOpen && this.close(), this._removeInputAndToggleListeners();
                var t = R.findOne("#".concat(this._toggleButtonId));
                t && this._element.removeChild(t), p.removeData(this._element, Qm), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null
            }
            _removeInputAndToggleListeners() {
                I.off(this._input, "input"), I.off(this._element, Jm, tv), I.off(this._element, "keydown", tv)
            }
            handleOk() {
                this._confirmSelection(this._headerDate), this.close()
            }
            _selectDate(t, e = this.activeCell) {
                var {
                    min: i,
                    max: n,
                    filter: s,
                    disablePast: o,
                    disableFuture: a
                } = this._options;
                Hm(t, i, n, s, o, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = Em(t), this._selectedMonth = Sm(t), this._headerDate = t, this._options.inline && (this._confirmSelection(t), this.close()))
            }
            _selectYear(t, e = this.activeCell) {
                this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months")
            }
            _selectMonth(t, e = this.activeCell) {
                this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days")
            }
            _removeSelectedStyles(t) {
                t && t.classList.remove("selected")
            }
            _addSelectedStyles(t) {
                t && P.addClass(t, "selected")
            }
            _confirmSelection(t) {
                var e;
                t && (e = this.formatDate(t), this._input.value = e, P.addClass(this._input, "active"), I.trigger(this._element, Gm, {
                    date: t
                }))
            }
            handleCancel() {
                this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close()
            }
            handleClear() {
                this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._input.classList.remove("active"), this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(this._activeDate, this._options.monthsShort, this._options.weekdaysShort)
            }
            _removeCurrentSelectionStyles() {
                const t = R.findOne(".selected", this.container);
                t && t.classList.remove("selected")
            }
            _removeCurrentFocusStyles() {
                const t = R.findOne(".focused", this.container);
                t && t.classList.remove("focused")
            }
            formatDate(t) {
                const e = km(t),
                    i = this._addLeadingZero(km(t)),
                    n = this._options.weekdaysShort[Tm(t)],
                    s = this._options.weekdaysFull[Tm(t)],
                    o = Sm(t) + 1,
                    a = this._addLeadingZero(Sm(t) + 1),
                    r = this._options.monthsShort[Sm(t)],
                    l = this._options.monthsFull[Sm(t)],
                    c = 2 === Em(t).toString().length ? Em(t) : Em(t).toString().slice(2, 4),
                    h = Em(t),
                    d = this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
                let u = "";
                return d.forEach(t => {
                    switch (t) {
                        case "dddd":
                            t = t.replace(t, s);
                            break;
                        case "ddd":
                            t = t.replace(t, n);
                            break;
                        case "dd":
                            t = t.replace(t, i);
                            break;
                        case "d":
                            t = t.replace(t, e);
                            break;
                        case "mmmm":
                            t = t.replace(t, l);
                            break;
                        case "mmm":
                            t = t.replace(t, r);
                            break;
                        case "mm":
                            t = t.replace(t, a);
                            break;
                        case "m":
                            t = t.replace(t, o);
                            break;
                        case "yyyy":
                            t = t.replace(t, h);
                            break;
                        case "yy":
                            t = t.replace(t, c)
                    }
                    u += t
                }), u
            }
            _addLeadingZero(t) {
                return parseInt(t, 10) < 10 ? "0".concat(t) : t
            }
            _pickDay(t, e) {
                var i = Pm(t),
                    {
                        min: n,
                        max: s,
                        filter: o,
                        disablePast: a,
                        disableFuture: t
                    } = this._options;
                Hm(i, n, s, o, a, t) || (this._activeDate = i, this._selectDate(i, e))
            }
            _pickYear(t) {
                var {
                    min: e,
                    max: i,
                    disablePast: n,
                    disableFuture: s
                } = this._options;
                Wm(t, e, i, n, s) || (s = Lm(t, this.activeMonth, this.activeDay), this._activeDate = s, this._selectedDate = s, this._selectYear(t))
            }
            _pickMonth(t, e) {
                var {
                    min: i,
                    max: n,
                    disablePast: s,
                    disableFuture: o
                } = this._options;
                jm(t, e, i, n, s, o) || Wm(e, i, n, s, o) || (e = Lm(e, t, this.activeDay), this._activeDate = e, this._selectMonth(t))
            }
            nextMonth() {
                var t = Im(this._activeDate, 1),
                    e = Xm(t, this._headerDate, this._options);
                this._activeDate = t, this.viewChangeButton.textContent = "".concat(this._options.monthsFull[this.activeMonth], " ").concat(this.activeYear), this.datesContainer.innerHTML = e
            }
            previousMonth() {
                var t = Im(this._activeDate, -1),
                    t = Xm(this._activeDate = t, this._headerDate, this._options);
                this.viewChangeButton.textContent = "".concat(this._options.monthsFull[this.activeMonth], " ").concat(this.activeYear), this.datesContainer.innerHTML = t
            }
            nextYear() {
                var t = Om(this._activeDate, 1);
                this._activeDate = t, this.viewChangeButton.textContent = "".concat(this.activeYear);
                t = Um(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4);
                this.datesContainer.innerHTML = t
            }
            previousYear() {
                var t = Om(this._activeDate, -1);
                this._activeDate = t, this.viewChangeButton.textContent = "".concat(this.activeYear);
                t = Um(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4);
                this.datesContainer.innerHTML = t
            }
            nextYears() {
                var t = Om(this._activeDate, 24),
                    t = Km(this._activeDate = t, this._selectedYear, this._options, 24, 4);
                this.viewChangeButton.textContent = "".concat(this.firstYearInView, " - ").concat(this.lastYearInView), this.datesContainer.innerHTML = t
            }
            previousYears() {
                var t = Om(this._activeDate, -24),
                    t = Km(this._activeDate = t, this._selectedYear, this._options, 24, 4);
                this.viewChangeButton.textContent = "".concat(this.firstYearInView, " - ").concat(this.lastYearInView), this.datesContainer.innerHTML = t
            }
            _asyncChangeView(t) {
                setTimeout(() => {
                    this._changeView(t)
                }, 0)
            }
            _changeView(t) {
                this._view = t, this.datesContainer.blur(), "days" === t && (this.datesContainer.innerHTML = Xm(this._activeDate, this._headerDate, this._options)), "months" === t && (this.datesContainer.innerHTML = Um(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4)), "years" === t && (this.datesContainer.innerHTML = Km(this._activeDate, this._selectedYear, this._options, 24, 4)), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState()
            }
            _updateViewControlsAndAttributes(t) {
                "days" === t && (this.viewChangeButton.textContent = "".concat(this._options.monthsFull[this.activeMonth], " ").concat(this.activeYear), this.viewChangeButton.setAttribute("aria-label", this._options.switchToMultiYearViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMonthLabel), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), "months" === t && (this.viewChangeButton.textContent = "".concat(this.activeYear), this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), "years" === t && (this.viewChangeButton.textContent = "".concat(this.firstYearInView, " - ").concat(this.lastYearInView), this.viewChangeButton.setAttribute("aria-label", this._options.switchToMonthViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMultiYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextMultiYearLabel))
            }
            _updateControlsDisabledState() {
                ! function(t, e, i, n, s, o, a, r) {
                    const l = new Date;
                    return l.setHours(0, 0, 0, 0), (o = t && o && Rm(o, l) < 0 || t ? l : o) && Fm(e, o, i, 0, 0, 0, a, r)
                }(this._options.disableFuture, this._activeDate, this._view, 24, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.nextButton.disabled = !1: this.nextButton.disabled = !0, ! function(t, e, i, n, s, o, a, r) {
                    const l = new Date;
                    return l.setHours(0, 0, 0, 0), (s = t && s && Rm(s, l) < 0 || t ? l : s) && Fm(e, s, i, 0, 0, 0, a, r)
                }(this._options.disablePast, this._activeDate, this._view, 24, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.previousButton.disabled = !1 : this.previousButton.disabled = !0
            }
            _handleUserInput(t) {
                var e = this._getDelimeters(this._options.format),
                    e = this._parseDate(t, this._options.format, e);
                Number.isNaN(e.getTime()) ? (this._activeDate = new Date, this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null) : (this._activeDate = e, this._selectedDate = e, this._selectedYear = Em(e), this._selectedMonth = Sm(e), this._headerDate = e)
            }
            _getDelimeters(t) {
                return t.match(/[^(dmy)]{1,}/g)
            }
            _parseDate(t, e, i) {
                let n;
                n = i[0] !== i[1] ? i[0] + i[1] : i[0];
                var i = new RegExp("[".concat(n, "]")),
                    s = t.split(i);
                const o = e.split(i);
                i = -1 !== e.indexOf("mmm");
                const a = [];
                for (let t = 0; t < o.length; t++) - 1 !== o[t].indexOf("yy") && (a[0] = {
                    value: s[t],
                    format: o[t]
                }), -1 !== o[t].indexOf("m") && (a[1] = {
                    value: s[t],
                    format: o[t]
                }), -1 !== o[t].indexOf("d") && o[t].length <= 2 && (a[2] = {
                    value: s[t],
                    format: o[t]
                });
                let r;
                return r = -1 !== e.indexOf("mmmm") ? this._options.monthsFull : this._options.monthsShort, Lm(Number(a[0].value), i ? this.getMonthNumberByMonthName(a[1].value, r) : Number(a[1].value) - 1, Number(a[2].value))
            }
            getMonthNumberByMonthName(e, t) {
                return t.findIndex(t => t === e)
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Qm);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new nv(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Qm)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        var sv = nv;
        R.find(".datepicker").forEach(t => {
            var e = nv.getInstance(t);
            e || new nv(t)
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[$m];
                t.fn[$m] = nv.jQueryInterface, t.fn[$m].Constructor = nv, t.fn[$m].noConflict = () => (t.fn[$m] = e, nv.jQueryInterface)
            }
        });
        const ov = "popconfirm",
            av = "mdb.popconfirm";
        Ot = ".".concat(av);
        const rv = "cancel".concat(Ot),
            lv = "confirm".concat(Ot),
            cv = {
                popconfirmMode: "string",
                message: "string",
                cancelText: "string",
                okText: "string",
                okClass: "string",
                popconfirmIcon: "string",
                cancelLabel: "string",
                confirmLabel: "string"
            },
            hv = {
                popconfirmMode: "inline",
                message: "Are you sure?",
                cancelText: "Cancel",
                okText: "OK",
                okClass: "btn-primary",
                popconfirmIcon: "",
                cancelLabel: "Cancel",
                confirmLabel: "Confirm"
            };
        class dv {
            constructor(t, e) {
                this._element = t, this._options = this._getConfig(e), this._cancelButtonTemplate = this._getCancelButtonTemplate(), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = d("popconfirm-"), t && p.setData(t, av, this), this._clickHandler = this.open.bind(this), I.on(this._element, "click", this._clickHandler)
            }
            static get NAME() {
                return ov
            }
            get container() {
                return R.findOne("#".concat(this._uid))
            }
            get popconfirmBody() {
                return R.findOne(".popconfirm", this.container)
            }
            dispose() {
                !this._isOpen && null === this.container || this.close(), p.removeData(this._element, av), I.on(this._element, "click", this._clickHandler), this._element = null
            }
            open() {
                this._isOpen || ("inline" === this._options.popconfirmMode ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick())
            }
            close() {
                var t;
                this._isOpen && (null !== this._popper || null !== R.findOne(".popconfirm-popover") ? (I.on(this.popconfirmBody, "transitionend", this._handlePopconfirmTransitionEnd.bind(this)), P.removeClass(this.popconfirmBody, "show")) : (t = R.findOne(".popconfirm-backdrop"), P.removeClass(this.popconfirmBody, "show"), document.body.removeChild(t), this._isOpen = !1), I.off(document, "click", this._handleOutsideClick.bind(this)), I.off(document, "keydown", this._handleEscapeKey.bind(this)))
            }
            _handlePopconfirmTransitionEnd(t) {
                var e;
                t.target === this.popconfirmBody && (e = R.findOne(".popconfirm-popover"), I.off(this.popconfirmBody, "transitionend"), this._isOpen && t && "opacity" === t.propertyName && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1))
            }
            _getPopoverTemplate() {
                const t = y("div");
                var e = this._getPopconfirmTemplate();
                return P.addClass(t, "popconfirm-popover"), P.addClass(t, "shadow-2"), t.id = this._uid, t.innerHTML = e, t
            }
            _getModalTemplate() {
                const t = y("div");
                var e = this._getPopconfirmTemplate();
                return P.addClass(t, "popconfirm-modal"), P.addClass(t, "shadow-2"), t.id = this._uid, t.innerHTML = e, t
            }
            _getPopconfirmTemplate() {
                return '<div class="popconfirm">\n      <p class="popconfirm-message">\n      '.concat(this._getMessageIcon(), '\n      <span class="popconfirm-message-text">').concat(this._options.message, '</span>\n      </p>\n      <div class="popconfirm-buttons-container">\n      ').concat(this._cancelButtonTemplate, '\n      <button type="button" id="popconfirm-button-confirm"\n      aria-label="').concat(this._options.confirmLabel, '"\n      class="btn ').concat(this._options.okClass, ' btn-sm">').concat(this._options.okText, "</button>\n      </div>\n    </div>")
            }
            _getConfig(t) {
                return t = { ...hv,
                    ...P.getDataAttributes(this._element),
                    ...t
                }, a(ov, t, cv), t
            }
            _getCancelButtonTemplate() {
                return "" === this._options.cancelText || " " === this._options.cancelText ? "" : '<button type="button" id="popconfirm-button-cancel" aria-label="'.concat(this._options.cancelLabel, '"\n    class="btn btn-secondary btn-sm">').concat(this._options.cancelText, "</button>")
            }
            _getMessageIcon() {
                return "" === this._options.popconfirmIcon ? "" : '<span class="popconfirm-icon-container"><i class="'.concat(this._options.popconfirmIcon, '"></i></span>')
            }
            _openPopover(t) {
                this._popper = Qn(this._element, t, {
                    placement: this._translatePositionValue(),
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: [0, 5]
                        }
                    }]
                }), document.body.appendChild(t), setTimeout(() => {
                    P.addClass(this.popconfirmBody, "fade"), P.addClass(this.popconfirmBody, "show"), this._isOpen = !0
                }, 0)
            }
            _openModal(t) {
                const e = y("div");
                P.addClass(e, "popconfirm-backdrop"), document.body.appendChild(e), e.appendChild(t), P.addClass(this.popconfirmBody, "show"), this._isOpen = !0
            }
            _handleCancelButtonClick() {
                var t = this.container;
                this._cancelButton = R.findOne("#popconfirm-button-cancel", t), null !== this._cancelButton && I.on(this._cancelButton, "click", () => {
                    this.close(), I.trigger(this._element, rv)
                })
            }
            _handleConfirmButtonClick() {
                var t = this.container;
                this._confirmButton = R.findOne("#popconfirm-button-confirm", t), I.on(this._confirmButton, "click", () => {
                    this.close(), I.trigger(this._element, lv)
                })
            }
            _listenToEscapeKey() {
                I.on(document, "keydown", this._handleEscapeKey.bind(this))
            }
            _handleEscapeKey(t) {
                27 === t.keyCode && this.close()
            }
            _listenToOutsideClick() {
                I.on(document, "click", this._handleOutsideClick.bind(this))
            }
            _handleOutsideClick(t) {
                const e = this.container;
                var i = t.target === e,
                    n = e && e.contains(t.target),
                    s = t.target === this._element,
                    t = this._element && this._element.contains(t.target);
                i || n || s || t || this.close()
            }
            _translatePositionValue() {
                switch (this._options.position) {
                    case "top left":
                        return h ? "top-start" : "top-end";
                    case "top":
                        return "top";
                    case "top right":
                        return h ? "top-end" : "top-start";
                    case "bottom left":
                        return h ? "bottom-start" : "bottom-end";
                    case "bottom":
                        return "bottom";
                    case "bottom right":
                        return h ? "bottom-end" : "bottom-start";
                    case "left":
                        return h ? "right" : "left";
                    case "left top":
                        return h ? "right-end" : "left-end";
                    case "left bottom":
                        return h ? "right-start" : "left-start";
                    case "right":
                        return h ? "left" : "right";
                    case "right top":
                        return h ? "left-end" : "right-end";
                    case "right bottom":
                        return h ? "left-start" : "right-start";
                    case void 0:
                        return "bottom";
                    default:
                        return this._options.position
                }
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    const t = p.getData(this, av);
                    var e = "object" == typeof i && i;
                    if (t || !/dispose/.test(i)) {
                        if (!t) return new dv(this, e);
                        if ("string" == typeof i) {
                            if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                            t[i](n)
                        }
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, av)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".popconfirm-toggle").forEach(t => {
            let e = dv.getInstance(t);
            return e = e || new dv(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[ov];
                t.fn[ov] = dv.jQueryInterface, t.fn[ov].Constructor = dv, t.fn[ov].noConflict = () => (t.fn[ov] = e, dv.jQueryInterface)
            }
        });
        var uv = dv;

        function pv(t) {
            return getComputedStyle(t)
        }

        function fv(e, i) {
            for (const n in i) {
                let t = i[n];
                "number" == typeof t && (t = "".concat(t, "px")), e.style[n] = t
            }
            return e
        }

        function gv(t) {
            const e = document.createElement("div");
            return e.className = t, e
        }
        const _v = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);

        function mv(t, e) {
            if (!_v) throw new Error("No element matching method supported");
            return _v.call(t, e)
        }

        function vv(t) {
            t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t)
        }

        function bv(t, e) {
            return Array.prototype.filter.call(t.children, t => mv(t, e))
        }
        const yv = {
            main: "ps",
            rtl: "ps__rtl",
            element: {
                thumb: t => "ps__thumb-".concat(t),
                rail: t => "ps__rail-".concat(t),
                consuming: "ps__child--consume"
            },
            state: {
                focus: "ps--focus",
                clicking: "ps--clicking",
                active: t => "ps--active-".concat(t),
                scrolling: t => "ps--scrolling-".concat(t)
            }
        };
        var xv = yv;
        const wv = {
            x: null,
            y: null
        };

        function Cv(t, e) {
            const i = t.element.classList;
            t = yv.state.scrolling(e);
            i.contains(t) ? clearTimeout(wv[e]) : i.add(t)
        }

        function kv(t, e) {
            wv[e] = setTimeout(() => t.isAlive && t.element.classList.remove(yv.state.scrolling(e)), t.settings.scrollingThreshold)
        }
        class Tv {
            constructor(t) {
                this.element = t, this.handlers = {}
            }
            bind(t, e) {
                void 0 === this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1)
            }
            unbind(e, i) {
                this.handlers[e] = this.handlers[e].filter(t => !(!i || t === i) || (this.element.removeEventListener(e, t, !1), !1))
            }
            unbindAll() {
                for (const t in this.handlers) this.unbind(t)
            }
            get isEmpty() {
                return Object.keys(this.handlers).every(t => 0 === this.handlers[t].length)
            }
        }
        class Sv {
            constructor() {
                this.eventElements = []
            }
            eventElement(e) {
                let t = this.eventElements.filter(t => t.element === e)[0];
                return t || (t = new Tv(e), this.eventElements.push(t)), t
            }
            bind(t, e, i) {
                this.eventElement(t).bind(e, i)
            }
            unbind(t, e, i) {
                const n = this.eventElement(t);
                n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1)
            }
            unbindAll() {
                this.eventElements.forEach(t => t.unbindAll()), this.eventElements = []
            }
            once(t, e, i) {
                const n = this.eventElement(t),
                    s = t => {
                        n.unbind(e, s), i(t)
                    };
                n.bind(e, s)
            }
        }

        function Ev(t) {
            if ("function" == typeof window.CustomEvent) return new CustomEvent(t);
            const e = document.createEvent("CustomEvent");
            return e.initCustomEvent(t, !1, !1, void 0), e
        }

        function Av(t, e, i, n = !0, s = !1) {
            let o;
            if ("top" === e) o = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
            else {
                if ("left" !== e) throw new Error("A proper axis should be provided");
                o = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"]
            }! function(t, e, [i, n, s, o, a, r], l = !0, c = !1) {
                const h = t.element;
                t.reach[o] = null, h[s] < 1 && (t.reach[o] = "start");
                h[s] > t[i] - t[n] - 1 && (t.reach[o] = "end");
                e && (h.dispatchEvent(Ev("ps-scroll-".concat(o))), e < 0 ? h.dispatchEvent(Ev("ps-scroll-".concat(a))) : 0 < e && h.dispatchEvent(Ev("ps-scroll-".concat(r))), l && function(t, e) {
                    Cv(t, e), kv(t, e)
                }(t, o));
                t.reach[o] && (e || c) && h.dispatchEvent(Ev("ps-".concat(o, "-reach-").concat(t.reach[o])))
            }(t, i, o, n, s)
        }

        function Mv(t) {
            return parseInt(t, 10) || 0
        }
        const Ov = {
            isWebKit: "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style,
            supportsTouch: "undefined" != typeof window && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && 0 < window.navigator.maxTouchPoints || window.DocumentTouch && document instanceof window.DocumentTouch),
            supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
            isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
        };
        var Iv = function(t) {
            const e = t.element;
            var i = Math.floor(e.scrollTop),
                n = e.getBoundingClientRect();
            t.containerWidth = Math.floor(n.width), t.containerHeight = Math.floor(n.height), t.contentWidth = e.scrollWidth, t.contentHeight = e.scrollHeight, e.contains(t.scrollbarXRail) || (bv(e, xv.element.rail("x")).forEach(t => vv(t)), e.appendChild(t.scrollbarXRail)), e.contains(t.scrollbarYRail) || (bv(e, xv.element.rail("y")).forEach(t => vv(t)), e.appendChild(t.scrollbarYRail)), !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0, t.railXWidth = t.containerWidth - t.railXMarginWidth, t.railXRatio = t.containerWidth / t.railXWidth, t.scrollbarXWidth = Dv(t, Mv(t.railXWidth * t.containerWidth / t.contentWidth)), t.scrollbarXLeft = Mv((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1, !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0, t.railYHeight = t.containerHeight - t.railYMarginHeight, t.railYRatio = t.containerHeight / t.railYHeight, t.scrollbarYHeight = Dv(t, Mv(t.railYHeight * t.containerHeight / t.contentHeight)), t.scrollbarYTop = Mv(i * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1, t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth), t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight),
                function(t, e) {
                    const i = {
                            width: e.railXWidth
                        },
                        n = Math.floor(t.scrollTop);
                    e.isRtl ? i.left = e.negativeScrollAdjustment + t.scrollLeft + e.containerWidth - e.contentWidth : i.left = t.scrollLeft;
                    e.isScrollbarXUsingBottom ? i.bottom = e.scrollbarXBottom - n : i.top = e.scrollbarXTop + n;
                    fv(e.scrollbarXRail, i);
                    const s = {
                        top: n,
                        height: e.railYHeight
                    };
                    e.isScrollbarYUsingRight ? e.isRtl ? s.right = e.contentWidth - (e.negativeScrollAdjustment + t.scrollLeft) - e.scrollbarYRight - e.scrollbarYOuterWidth - 9 : s.right = e.scrollbarYRight - t.scrollLeft : e.isRtl ? s.left = e.negativeScrollAdjustment + t.scrollLeft + 2 * e.containerWidth - e.contentWidth - e.scrollbarYLeft - e.scrollbarYOuterWidth : s.left = e.scrollbarYLeft + t.scrollLeft;
                    fv(e.scrollbarYRail, s), fv(e.scrollbarX, {
                        left: e.scrollbarXLeft,
                        width: e.scrollbarXWidth - e.railBorderXWidth
                    }), fv(e.scrollbarY, {
                        top: e.scrollbarYTop,
                        height: e.scrollbarYHeight - e.railBorderYWidth
                    })
                }(e, t), t.scrollbarXActive ? e.classList.add(xv.state.active("x")) : (e.classList.remove(xv.state.active("x")), t.scrollbarXWidth = 0, t.scrollbarXLeft = 0, e.scrollLeft = !0 === t.isRtl ? t.contentWidth : 0), t.scrollbarYActive ? e.classList.add(xv.state.active("y")) : (e.classList.remove(xv.state.active("y")), t.scrollbarYHeight = 0, t.scrollbarYTop = 0, e.scrollTop = 0)
        };

        function Dv(t, e) {
            return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)), e = t.settings.maxScrollbarLength ? Math.min(e, t.settings.maxScrollbarLength) : e
        }

        function Lv(i, [n, s, o, a, t, r, l, e, c]) {
            const h = i.element;
            let d = null,
                u = null,
                p = null;

            function f(t) {
                t.touches && t.touches[0] && (t[o] = t.touches[0].pageY), h[l] = d + p * (t[o] - u), Cv(i, e), Iv(i), t.stopPropagation(), t.preventDefault()
            }

            function g() {
                kv(i, e), i[c].classList.remove(xv.state.clicking), i.event.unbind(i.ownerDocument, "mousemove", f)
            }

            function _(t, e) {
                d = h[l], e && t.touches && (t[o] = t.touches[0].pageY), u = t[o], p = (i[s] - i[n]) / (i[a] - i[r]), e ? i.event.bind(i.ownerDocument, "touchmove", f) : (i.event.bind(i.ownerDocument, "mousemove", f), i.event.once(i.ownerDocument, "mouseup", g), t.preventDefault()), i[c].classList.add(xv.state.clicking), t.stopPropagation()
            }
            i.event.bind(i[t], "mousedown", t => {
                _(t)
            }), i.event.bind(i[t], "touchstart", t => {
                _(t, !0)
            })
        }
        const Pv = {
            "click-rail": function(i) {
                i.event.bind(i.scrollbarY, "mousedown", t => t.stopPropagation()), i.event.bind(i.scrollbarYRail, "mousedown", t => {
                    var e = t.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top > i.scrollbarYTop ? 1 : -1;
                    i.element.scrollTop += e * i.containerHeight, Iv(i), t.stopPropagation()
                }), i.event.bind(i.scrollbarX, "mousedown", t => t.stopPropagation()), i.event.bind(i.scrollbarXRail, "mousedown", t => {
                    var e = t.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left > i.scrollbarXLeft ? 1 : -1;
                    i.element.scrollLeft += e * i.containerWidth, Iv(i), t.stopPropagation()
                })
            },
            "drag-thumb": function(t) {
                Lv(t, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]), Lv(t, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"])
            },
            keyboard: function(o) {
                const a = o.element;
                o.event.bind(o.ownerDocument, "keydown", n => {
                    if (!(n.isDefaultPrevented && n.isDefaultPrevented() || n.defaultPrevented) && (mv(a, ":hover") || mv(o.scrollbarX, ":focus") || mv(o.scrollbarY, ":focus"))) {
                        let t = document.activeElement || o.ownerDocument.activeElement;
                        if (t) {
                            if ("IFRAME" === t.tagName) t = t.contentDocument.activeElement;
                            else
                                for (; t.shadowRoot;) t = t.shadowRoot.activeElement;
                            if (mv(s = t, "input,[contenteditable]") || mv(s, "select,[contenteditable]") || mv(s, "textarea,[contenteditable]") || mv(s, "button,[contenteditable]")) return
                        }
                        var s;
                        let e = 0,
                            i = 0;
                        switch (n.which) {
                            case 37:
                                e = n.metaKey ? -o.contentWidth : n.altKey ? -o.containerWidth : -30;
                                break;
                            case 38:
                                i = n.metaKey ? o.contentHeight : n.altKey ? o.containerHeight : 30;
                                break;
                            case 39:
                                e = n.metaKey ? o.contentWidth : n.altKey ? o.containerWidth : 30;
                                break;
                            case 40:
                                i = n.metaKey ? -o.contentHeight : n.altKey ? -o.containerHeight : -30;
                                break;
                            case 32:
                                i = n.shiftKey ? o.containerHeight : -o.containerHeight;
                                break;
                            case 33:
                                i = o.containerHeight;
                                break;
                            case 34:
                                i = -o.containerHeight;
                                break;
                            case 36:
                                i = o.contentHeight;
                                break;
                            case 35:
                                i = -o.contentHeight;
                                break;
                            default:
                                return
                        }
                        o.settings.suppressScrollX && 0 !== e || o.settings.suppressScrollY && 0 !== i || (a.scrollTop -= i, a.scrollLeft += e, Iv(o), function(t, e) {
                            var i = Math.floor(a.scrollTop);
                            if (0 === t) {
                                if (!o.scrollbarYActive) return;
                                if (0 === i && 0 < e || i >= o.contentHeight - o.containerHeight && e < 0) return !o.settings.wheelPropagation
                            }
                            if (i = a.scrollLeft, 0 === e) {
                                if (!o.scrollbarXActive) return;
                                if (0 === i && t < 0 || i >= o.contentWidth - o.containerWidth && 0 < t) return !o.settings.wheelPropagation
                            }
                            return 1
                        }(e, i) && n.preventDefault())
                    }
                })
            },
            wheel: function(r) {
                const l = r.element;

                function t(e) {
                    var [i, n] = function(t) {
                        let e = t.deltaX,
                            i = -1 * t.deltaY;
                        return void 0 !== e && void 0 !== i || (e = -1 * t.wheelDeltaX / 6, i = t.wheelDeltaY / 6), t.deltaMode && 1 === t.deltaMode && (e *= 10, i *= 10), e != e && i != i && (e = 0, i = t.wheelDelta), t.shiftKey ? [-i, -e] : [e, i]
                    }(e);
                    if (! function(e, i, n) {
                            if (!Ov.isWebKit && l.querySelector("select:focus")) return 1;
                            if (l.contains(e)) {
                                let t = e;
                                for (; t && t !== l;) {
                                    if (t.classList.contains(xv.element.consuming)) return 1;
                                    const o = pv(t);
                                    if (n && o.overflowY.match(/(scroll|auto)/)) {
                                        var s = t.scrollHeight - t.clientHeight;
                                        if (0 < s && (0 < t.scrollTop && n < 0 || t.scrollTop < s && 0 < n)) return 1
                                    }
                                    if (i && o.overflowX.match(/(scroll|auto)/)) {
                                        s = t.scrollWidth - t.clientWidth;
                                        if (0 < s && (0 < t.scrollLeft && i < 0 || t.scrollLeft < s && 0 < i)) return 1
                                    }
                                    t = t.parentNode
                                }
                            }
                        }(e.target, i, n)) {
                        let t = !1;
                        r.settings.useBothWheelAxes ? r.scrollbarYActive && !r.scrollbarXActive ? (n ? l.scrollTop -= n * r.settings.wheelSpeed : l.scrollTop += i * r.settings.wheelSpeed, t = !0) : r.scrollbarXActive && !r.scrollbarYActive && (i ? l.scrollLeft += i * r.settings.wheelSpeed : l.scrollLeft -= n * r.settings.wheelSpeed, t = !0) : (l.scrollTop -= n * r.settings.wheelSpeed, l.scrollLeft += i * r.settings.wheelSpeed), Iv(r), t = t || function(t, e) {
                            var i = Math.floor(l.scrollTop),
                                n = 0 === l.scrollTop,
                                s = i + l.offsetHeight === l.scrollHeight,
                                o = 0 === l.scrollLeft,
                                i = l.scrollLeft + l.offsetWidth === l.scrollWidth;
                            let a;
                            return a = Math.abs(e) > Math.abs(t) ? n || s : o || i, !a || !r.settings.wheelPropagation
                        }(i, n), t && !e.ctrlKey && (e.stopPropagation(), e.preventDefault())
                    }
                }
                void 0 !== window.onwheel ? r.event.bind(l, "wheel", t) : void 0 !== window.onmousewheel && r.event.bind(l, "mousewheel", t)
            },
            touch: function(l) {
                if (Ov.supportsTouch || Ov.supportsIePointer) {
                    const u = l.element;
                    let o = {},
                        a = 0,
                        r = {},
                        e = null;

                    function c(t, e) {
                        u.scrollTop -= e, u.scrollLeft -= t, Iv(l)
                    }

                    function h(t) {
                        return t.targetTouches ? t.targetTouches[0] : t
                    }

                    function d(t) {
                        return (!t.pointerType || "pen" !== t.pointerType || 0 !== t.buttons) && (t.targetTouches && 1 === t.targetTouches.length || !(!t.pointerType || "mouse" === t.pointerType || t.pointerType === t.MSPOINTER_TYPE_MOUSE))
                    }

                    function t(t) {
                        d(t) && (t = h(t), o.pageX = t.pageX, o.pageY = t.pageY, a = (new Date).getTime(), null !== e && clearInterval(e))
                    }

                    function i(t) {
                        var e, i, n, s;
                        d(t) && (e = (s = {
                            pageX: (n = h(t)).pageX,
                            pageY: n.pageY
                        }).pageX - o.pageX, i = s.pageY - o.pageY, function(e, i, n) {
                            if (u.contains(e)) {
                                let t = e;
                                for (; t && t !== u;) {
                                    if (t.classList.contains(xv.element.consuming)) return 1;
                                    const o = pv(t);
                                    if (n && o.overflowY.match(/(scroll|auto)/)) {
                                        var s = t.scrollHeight - t.clientHeight;
                                        if (0 < s && (0 < t.scrollTop && n < 0 || t.scrollTop < s && 0 < n)) return 1
                                    }
                                    if (i && o.overflowX.match(/(scroll|auto)/)) {
                                        s = t.scrollWidth - t.clientWidth;
                                        if (0 < s && (0 < t.scrollLeft && i < 0 || t.scrollLeft < s && 0 < i)) return 1
                                    }
                                    t = t.parentNode
                                }
                            }
                        }(t.target, e, i) || (c(e, i), o = s, 0 < (s = (n = (new Date).getTime()) - a) && (r.x = e / s, r.y = i / s, a = n), function(t, e) {
                            var i = Math.floor(u.scrollTop),
                                n = u.scrollLeft,
                                s = Math.abs(t),
                                o = Math.abs(e);
                            if (s < o) {
                                if (e < 0 && i === l.contentHeight - l.containerHeight || 0 < e && 0 === i) return 0 === window.scrollY && 0 < e && Ov.isChrome
                            } else if (o < s && (t < 0 && n === l.contentWidth - l.containerWidth || 0 < t && 0 === n)) return 1;
                            return 1
                        }(e, i) && t.preventDefault()))
                    }

                    function n() {
                        l.settings.swipeEasing && (clearInterval(e), e = setInterval(function() {
                            l.isInitialized || !r.x && !r.y || Math.abs(r.x) < .01 && Math.abs(r.y) < .01 ? clearInterval(e) : (c(30 * r.x, 30 * r.y), r.x *= .8, r.y *= .8)
                        }, 10))
                    }
                    Ov.supportsTouch ? (l.event.bind(u, "touchstart", t), l.event.bind(u, "touchmove", i), l.event.bind(u, "touchend", n)) : Ov.supportsIePointer && (window.PointerEvent ? (l.event.bind(u, "pointerdown", t), l.event.bind(u, "pointermove", i), l.event.bind(u, "pointerup", n)) : window.MSPointerEvent && (l.event.bind(u, "MSPointerDown", t), l.event.bind(u, "MSPointerMove", i), l.event.bind(u, "MSPointerUp", n)))
                }
            }
        };
        class Rv {
            constructor(t, e = {}) {
                if (!(t = "string" == typeof t ? document.querySelector(t) : t) || !t.nodeName) throw new Error("no element is specified to initialize PerfectScrollbar");
                (this.element = t).classList.add(xv.main), this.settings = {
                    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
                    maxScrollbarLength: null,
                    minScrollbarLength: null,
                    scrollingThreshold: 1e3,
                    scrollXMarginOffset: 0,
                    scrollYMarginOffset: 0,
                    suppressScrollX: !1,
                    suppressScrollY: !1,
                    swipeEasing: !0,
                    useBothWheelAxes: !1,
                    wheelPropagation: !0,
                    wheelSpeed: 1
                };
                for (const a in e) this.settings[a] = e[a];
                this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
                var i, n = () => t.classList.add(xv.state.focus),
                    s = () => t.classList.remove(xv.state.focus);
                this.isRtl = "rtl" === pv(t).direction, !0 === this.isRtl && t.classList.add(xv.rtl), this.isNegativeScroll = (i = t.scrollLeft, t.scrollLeft = -1, o = t.scrollLeft < 0, t.scrollLeft = i, o), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Sv, this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = gv(xv.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = gv(xv.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", n), this.event.bind(this.scrollbarX, "blur", s), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
                var o = pv(this.scrollbarXRail);
                this.scrollbarXBottom = parseInt(o.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = Mv(o.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = Mv(o.borderLeftWidth) + Mv(o.borderRightWidth), fv(this.scrollbarXRail, {
                    display: "block"
                }), this.railXMarginWidth = Mv(o.marginLeft) + Mv(o.marginRight), fv(this.scrollbarXRail, {
                    display: ""
                }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = gv(xv.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = gv(xv.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", n), this.event.bind(this.scrollbarY, "blur", s), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
                n = pv(this.scrollbarYRail);
                this.scrollbarYRight = parseInt(n.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = Mv(n.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? Mv((s = pv(s = this.scrollbarY)).width) + Mv(s.paddingLeft) + Mv(s.paddingRight) + Mv(s.borderLeftWidth) + Mv(s.borderRightWidth) : null, this.railBorderYWidth = Mv(n.borderTopWidth) + Mv(n.borderBottomWidth), fv(this.scrollbarYRail, {
                    display: "block"
                }), this.railYMarginHeight = Mv(n.marginTop) + Mv(n.marginBottom), fv(this.scrollbarYRail, {
                    display: ""
                }), this.railYHeight = null, this.railYRatio = null, this.reach = {
                    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
                    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
                }, this.isAlive = !0, this.settings.handlers.forEach(t => Pv[t](this)), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", t => this.onScroll(t)), Iv(this)
            }
            update() {
                this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, fv(this.scrollbarXRail, {
                    display: "block"
                }), fv(this.scrollbarYRail, {
                    display: "block"
                }), this.railXMarginWidth = Mv(pv(this.scrollbarXRail).marginLeft) + Mv(pv(this.scrollbarXRail).marginRight), this.railYMarginHeight = Mv(pv(this.scrollbarYRail).marginTop) + Mv(pv(this.scrollbarYRail).marginBottom), fv(this.scrollbarXRail, {
                    display: "none"
                }), fv(this.scrollbarYRail, {
                    display: "none"
                }), Iv(this), Av(this, "top", 0, !1, !0), Av(this, "left", 0, !1, !0), fv(this.scrollbarXRail, {
                    display: ""
                }), fv(this.scrollbarYRail, {
                    display: ""
                }))
            }
            onScroll(t) {
                this.isAlive && (Iv(this), Av(this, "top", this.element.scrollTop - this.lastScrollTop), Av(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft)
            }
            destroy() {
                this.isAlive && (this.event.unbindAll(), vv(this.scrollbarX), vv(this.scrollbarY), vv(this.scrollbarXRail), vv(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1)
            }
            removePsClasses() {
                this.element.className = this.element.className.split(" ").filter(t => !t.match(/^ps([-_].+|)$/)).join(" ")
            }
        }
        var Bv = ({
                text: t,
                entries: e,
                entriesOptions: i,
                fullPagination: n,
                rowsText: s,
                allText: o
            }, a) => {
                i = i.map(t => "All" === t ? '<option value="'.concat(t, '" ').concat(t === e ? "selected" : "", ">").concat(o, "</option>") : '<option value="'.concat(t, '" ').concat(t === e ? "selected" : "", ">").concat(t, "</option>")).join("\n");
                return '\n<div class="datatable-pagination">\n  <div class="datatable-select-wrapper">\n    <p class="datatable-select-text">'.concat(s, '</p>\n    <select name="entries"\n      ').concat(a ? 'data-mdb-disabled="true"' : "", ' class="datatable-select select">\n      ').concat(i, '\n    </select>\n  </div>\n  <div class="datatable-pagination-nav">\n  ').concat(t, '\n  </div>\n  <div class="datatable-pagination-buttons">\n    ').concat(n ? '<button data-mdb-ripple-color="dark" class="btn btn-link datatable-pagination-button datatable-pagination-start"><i class="fa fa-angle-double-left"></i></button>' : "", '\n    <button data-mdb-ripple-color="dark" class="btn btn-link datatable-pagination-button datatable-pagination-left"><i class="fa fa-chevron-').concat(h ? "right" : "left", '"></i></button>\n    <button data-mdb-ripple-color="dark" class="btn btn-link datatable-pagination-button datatable-pagination-right"><i class="fa fa-chevron-').concat(h ? "left" : "right", '"></i></button>\n    ').concat(n ? '<button data-mdb-ripple-color="dark" class="btn btn-link datatable-pagination-button datatable-pagination-end"><i class="fa fa-angle-double-right"></i></button>' : "", "\n  </div>\n</div>\n")
            },
            Nv = (e, t, i) => {
                const n = i ? '\n<th scope="col">\n  <div class="form-check d-flex align-items-center mb-0">\n    <input class="datatable-header-checkbox form-check-input" type="checkbox">\n  </div>\n</th>\n' : '<th scope="col"></th>';
                i = e.map((i, n) => {
                    var t = i.fixed ? e.filter((t, e) => t.fixed === i.fixed && e < n).reduce((t, e) => t + e.width, 0) : null;
                    return '<th style="'.concat(i.fixed ? "".concat("right" === i.fixed ? "right" : "left", ": ").concat(t, "px;") : "", '" ').concat(i.fixed ? 'class="fixed-cell"' : "", ' scope="col">').concat(i.sort ? '<i data-mdb-sort="'.concat(i.field, '" class="datatable-sort-icon fas fa-arrow-up"></i>') : "", " ").concat(i.label, "</th>")
                });
                return [t ? n : "", ...i].join("\n")
            },
            Hv = ({
                rows: t,
                columns: o,
                noFoundMessage: e,
                edit: a,
                selectable: i,
                loading: n
            }) => {
                const s = t.map(s => {
                    var t = '\n    <td data-mdb-field="checkbox">\n      <div class="form-check">\n        <input data-mdb-row-index="'.concat(s.rowIndex, '" class="datatable-row-checkbox form-check-input" type="checkbox">\n      </div>\n    </td>\n    '),
                        e = o.map((i, n) => {
                            const e = {};
                            i.width && (e["min-width"] = "".concat(i.width - 1, "px"), e["max-width"] = "".concat(i.width, "px"), e.width = "".concat(i.width, "px")), i.fixed && (t = o.filter((t, e) => t.fixed === i.fixed && e < n).reduce((t, e) => t + e.width, 0), e["right" === i.fixed ? "right" : "left"] = "".concat(t, "px"));
                            var t = Object.keys(e).map(t => "".concat(t, ": ").concat(e[t])).join("; ");
                            return '<td style="'.concat(t, '" class="').concat(i.fixed ? "fixed-cell" : "", '" data-mdb-field="').concat(i.field, '" ').concat(a && 'contenteditable="true"', ">").concat(s[i.field], "</td>")
                        }).join("");
                    return '<tr scope="row" data-mdb-index="'.concat(s.rowIndex, '">').concat(i ? t : "").concat(e, "</tr>")
                });
                return 0 < t.length || n ? s.join("\n") : "<tr><td>".concat(e, "</td></tr>")
            },
            jv = ({
                columns: t,
                rows: e,
                noFoundMessage: i,
                edit: n,
                multi: s,
                selectable: o,
                loading: a,
                loadingMessage: r,
                loaderClass: l,
                pagination: c
            }) => {
                n = Hv({
                    rows: e,
                    columns: t,
                    noFoundMessage: i,
                    edit: n,
                    loading: a,
                    selectable: o
                }), s = Nv(t, o, s);
                return {
                    table: '\n<div class="datatable-inner table-responsive">\n  <table class="table datatable-table">\n    <thead class="datatable-header">\n      <tr>\n        '.concat(s, '\n      </tr>\n    </thead>\n    <tbody class="datatable-body">\n      ').concat(a ? "" : n, "\n    </tbody>\n  </table>\n</div>\n  ").concat(a ? '\n  <div class="datatable-loader bg-light}">\n    <span class="datatable-loader-inner"><span class="datatable-progress '.concat(l, '"></span></span>\n  </div>\n  <p class="text-center text-muted my-4">').concat(r, "</p>\n") : "", "\n  ").concat(c.enable ? Bv(c, a) : "", "\n  "),
                    rows: n,
                    column: s
                }
            };
        const Wv = ({
                rows: t,
                entries: e,
                activePage: i
            }) => {
                i *= e;
                return t.slice(i, i + Number(e))
            },
            Fv = ".form-check-input",
            Vv = "selected";
        var zv = class {
            constructor(t, e, i, n, s, o, a, r, l, c, h) {
                this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = s, this.selected = o, this.disabled = a, this.hidden = r, this.secondaryText = l, this.groupId = c, this.icon = h, this.node = null, this.active = !1
            }
            select() {
                this.multiple ? this._selectMultiple() : this._selectSingle()
            }
            _selectSingle() {
                this.selected || (P.addClass(this.node, Vv), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0))
            }
            _selectMultiple() {
                if (!this.selected) {
                    const t = R.findOne(Fv, this.node);
                    t.checked = !0, P.addClass(this.node, Vv), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0)
                }
            }
            deselect() {
                this.multiple ? this._deselectMultiple() : this._deselectSingle()
            }
            _deselectSingle() {
                this.selected && (P.removeClass(this.node, Vv), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1))
            }
            _deselectMultiple() {
                if (this.selected) {
                    const t = R.findOne(Fv, this.node);
                    t.checked = !1, P.removeClass(this.node, Vv), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1)
                }
            }
            setNode(t) {
                this.node = t
            }
            setActiveStyles() {
                this.active || this.multiple || (this.active = !0, P.addClass(this.node, "active"))
            }
            removeActiveStyles() {
                this.active && (this.active = !1, P.removeClass(this.node, "active"))
            }
        };
        var Yv = class {
            constructor(t = !1) {
                this._multiple = t, this._selections = []
            }
            select(t) {
                this._multiple ? this._selections.push(t) : this._selections = [t]
            }
            deselect(e) {
                var t;
                this._multiple ? (t = this._selections.findIndex(t => e === t), this._selections.splice(t, 1)) : this._selections = []
            }
            clear() {
                this._selections = []
            }
            get selection() {
                return this._selections[0]
            }
            get selections() {
                return this._selections
            }
            get label() {
                return this._selections[0] && this.selection.label
            }
            get labels() {
                return this._selections.map(t => t.label).join(", ")
            }
            get value() {
                return this.selections[0] && this.selection.value
            }
            get values() {
                return this._selections.map(t => t.value)
            }
        };

        function Xv(t) {
            return t.filter(t => !t.disabled).every(t => t.selected)
        }
        const Uv = t => {
            "Tab" !== t.code && "Esc" !== t.code && t.preventDefault()
        };

        function Kv(t, e, i, n, s, o, a) {
            const r = document.createElement("div");
            r.classList.add("select-dropdown-container"), r.setAttribute("id", "".concat(t)), r.style.width = "".concat(i, "px");
            const l = document.createElement("div");
            l.setAttribute("tabindex", 0), l.classList.add("select-dropdown");
            const c = y("div");
            P.addClass(c, "select-options-wrapper"), c.style.maxHeight = "".concat(n, "px");
            s = $v(o, s, e);
            return c.appendChild(s), e.filter && l.appendChild(function(t) {
                const e = y("div");
                P.addClass(e, "input-group");
                const i = y("input");
                return P.addClass(i, "form-control"), P.addClass(i, "select-filter-input"), i.placeholder = t, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e
            }(e.searchPlaceholder)), l.appendChild(c), a && l.appendChild(a), r.appendChild(l), r
        }

        function $v(t, e, i) {
            const n = y("div");
            P.addClass(n, "select-options-list");
            let s;
            return s = i.multiple ? function(t, e, i) {
                let n = null;
                i.selectAll && (n = function(t, e, i) {
                    const n = Xv(e),
                        s = y("div");
                    P.addClass(s, "select-option"), P.addClass(s, "select-all-option"), P.addStyle(s, {
                        height: "".concat(i.optionHeight, "px")
                    }), s.setAttribute("role", "option"), s.setAttribute("aria-selected", n), n && P.addClass(s, "selected");
                    return s.appendChild(Zv(t, i)), t.setNode(s), s
                }(e, t, i));
                i = Qv(t, i), i = n ? [n, ...i] : i;
                return i
            }(t, e, i) : function(t, e) {
                e = Qv(t, e);
                return e
            }(t, i), s.forEach(t => {
                n.appendChild(t)
            }), n
        }

        function Qv(t, i) {
            const n = [];
            return t.forEach(t => {
                var e;
                t.hasOwnProperty("options") ? (e = function(t, e) {
                    const i = y("div");
                    P.addClass(i, "select-option-group"), i.setAttribute("role", "group"), i.setAttribute("id", t.id), t.hidden && P.addClass(i, "d-none");
                    const n = y("label");
                    return P.addClass(n, "select-option-group-label"), P.addStyle(n, {
                        height: "".concat(e.optionHeight, "px")
                    }), n.setAttribute("for", t.id), n.textContent = t.label, i.appendChild(n), t.options.forEach(t => {
                        i.appendChild(qv(t, e))
                    }), i
                }(t, i), n.push(e)) : n.push(qv(t, i))
            }), n
        }

        function qv(t, e) {
            if (t.node) return t.node;
            const i = y("div");
            return P.addClass(i, "select-option"), P.addStyle(i, {
                height: "".concat(e.optionHeight, "px")
            }), P.setDataAttribute(i, "id", t.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", t.selected), i.setAttribute("aria-disabled", t.disabled), t.selected && P.addClass(i, "selected"), t.disabled && P.addClass(i, "disabled"), t.hidden && P.addClass(i, "d-none"), i.appendChild(Zv(t, e)), t.icon && i.appendChild(function(t) {
                const e = y("span");
                P.addClass(e, "select-option-icon-container");
                const i = y("img");
                return P.addClass(i, "select-option-icon"), P.addClass(i, "rounded-circle"), i.src = t.icon, e.appendChild(i), e
            }(t)), t.setNode(i), i
        }

        function Zv(t, e) {
            const i = y("span");
            P.addClass(i, "select-option-text");
            var n = document.createTextNode(t.label);
            return e.multiple && i.appendChild(function(t) {
                const e = y("input");
                e.setAttribute("type", "checkbox"), P.addClass(e, "form-check-input");
                var i = y("label");
                t.selected && e.setAttribute("checked", !0);
                t.disabled && e.setAttribute("disabled", !0);
                return e.appendChild(i), e
            }(t)), i.appendChild(n), !t.secondaryText && "number" != typeof t.secondaryText || i.appendChild(function(t) {
                const e = y("span");
                P.addClass(e, "select-option-secondary-text");
                t = document.createTextNode(t);
                return e.appendChild(t), e
            }(t.secondaryText)), i
        }
        const Gv = {
                autoSelect: !1,
                container: "body",
                clearButton: !1,
                disabled: !1,
                displayedLabels: 5,
                formWhite: !1,
                multiple: !1,
                optionsSelectedLabel: "options selected",
                optionHeight: 38,
                selectAll: !0,
                selectAllLabel: "Select all",
                searchPlaceholder: "Search...",
                size: "default",
                visibleOptions: 5,
                filter: !1,
                filterDebounce: 300,
                noResultText: "No results",
                validation: !1,
                validFeedback: "Valid",
                invalidFeedback: "Invalid",
                placeholder: ""
            },
            Jv = {
                autoSelect: "boolean",
                container: "string",
                clearButton: "boolean",
                disabled: "boolean",
                displayedLabels: "number",
                formWhite: "boolean",
                multiple: "boolean",
                optionsSelectedLabel: "string",
                optionHeight: "number",
                selectAll: "boolean",
                selectAllLabel: "string",
                searchPlaceholder: "string",
                size: "string",
                visibleOptions: "number",
                filter: "boolean",
                filterDebounce: "number",
                noResultText: "string",
                validation: "boolean",
                validFeedback: "string",
                invalidFeedback: "string",
                placeholder: ""
            },
            tb = "select",
            eb = "mdb.select";
        i = ".".concat(eb);
        const ib = "close".concat(i),
            nb = "open".concat(i),
            sb = "optionSelect".concat(i),
            ob = "optionDeselect".concat(i),
            ab = "valueChange".concat(i);
        const rb = ".select-input",
            lb = ".select-options-list",
            cb = ".form-outline",
            hb = "select-initialized",
            db = "active";
        class ub {
            constructor(t, e) {
                this._element = t, this._config = this._getConfig(e), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Yv(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = d("select-wrapper-"), this._dropdownContainerId = d("select-dropdown-container-"), this._selectAllId = d("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.optionHeight * this._config.visibleOptions, this._popper = null, this._input = null, this._label = R.next(this._element, ".select-label")[0], this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = R.next(t, ".select-custom-content")[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && p.setData(t, eb, this)
            }
            static get NAME() {
                return tb
            }
            get filterInput() {
                return R.findOne(".select-filter-input", this._dropdownContainer)
            }
            get dropdown() {
                return R.findOne(".select-dropdown", this._dropdownContainer)
            }
            get optionsList() {
                return R.findOne(lb, this._dropdownContainer)
            }
            get optionsWrapper() {
                return R.findOne(".select-options-wrapper", this._dropdownContainer)
            }
            get clearButton() {
                return R.findOne(".select-clear-btn", this._wrapper)
            }
            get options() {
                return this._filteredOptionsList || this._plainOptions
            }
            get value() {
                return this.multiple ? this._selectionModel.values : this._selectionModel.value
            }
            get multiple() {
                return this._config.multiple
            }
            get hasSelectAll() {
                return this.multiple && this._config.selectAll
            }
            get hasSelection() {
                return this._selectionModel.selection || 0 < this._selectionModel.selections.length
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...Gv,
                    ...e,
                    ...t
                }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), a(tb, t, Jv), t
            }
            _getOptionsToRender(t) {
                const n = [],
                    e = t.childNodes;
                return e.forEach(t => {
                    if ("OPTGROUP" === t.nodeName) {
                        const e = {
                                id: d("group-"),
                                label: t.label,
                                disabled: t.hasAttribute("disabled"),
                                hidden: t.hasAttribute("hidden"),
                                options: []
                            },
                            i = t.childNodes;
                        i.forEach(t => {
                            "OPTION" === t.nodeName && e.options.push(this._createOptionObject(t, e))
                        }), n.push(e)
                    } else "OPTION" === t.nodeName && n.push(this._createOptionObject(t))
                }), n
            }
            _getPlainOptions(t) {
                if (!R.findOne("optgroup", this._element)) return t;
                const e = [];
                return t.forEach(t => {
                    t.hasOwnProperty("options") ? t.options.forEach(t => {
                        e.push(t)
                    }) : e.push(t)
                }), e
            }
            _createOptionObject(t, e = {}) {
                var i = d("option-"),
                    n = e.id || null,
                    s = e.disabled || !1,
                    o = t.selected || t.hasAttribute("selected"),
                    a = t.hasAttribute("disabled") || s,
                    r = t.hasAttribute("hidden") || e && e.hidden,
                    l = this.multiple,
                    c = t.value,
                    h = t.label,
                    s = P.getDataAttribute(t, "secondaryText"),
                    e = P.getDataAttribute(t, "icon");
                return new zv(i, t, l, c, h, o, a, r, s, n, e)
            }
            _getNavigationOptions() {
                var t = this.options.filter(t => !t.hidden);
                return this.hasSelectAll ? [this._selectAllOption, ...t] : t
            }
            _init() {
                this._renderMaterialWrapper(), this._wrapper = R.findOne("#".concat(this._wrapperId)), this._input = R.findOne(rb, this._wrapper);
                var t = this._config.container;
                this._container = "body" === t ? document.body : R.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = Kv(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent), this._setFirstActiveOption()
            }
            _renderMaterialWrapper() {
                const t = function(t, e, i) {
                    const n = document.createElement("div");
                    n.setAttribute("id", t), n.classList.add("select-wrapper");
                    const s = y("div");
                    P.addClass(s, "form-outline"), e.formWhite && P.addClass(s, "form-white");
                    const o = y("input");
                    var a = e.filter ? "combobox" : "listbox",
                        r = e.multiple ? "true" : "false",
                        t = e.disabled ? "true" : "false";
                    P.addClass(o, "form-control"), P.addClass(o, "select-input"), "sm" === e.size && P.addClass(o, "form-control-sm"), "lg" === e.size && P.addClass(o, "form-control-lg"), o.setAttribute("type", "text"), o.setAttribute("role", a), o.setAttribute("aria-multiselectable", r), o.setAttribute("aria-disabled", t), o.setAttribute("aria-haspopup", "true"), o.setAttribute("aria-expanded", !1), e.tabIndex && o.setAttribute("tabIndex", e.tabIndex), e.disabled && o.setAttribute("disabled", ""), "" !== e.placeholder && o.setAttribute("placeholder", e.placeholder), e.validation ? (P.addStyle(o, {
                        "pointer-events": "none",
                        "caret-color": "transparent"
                    }), P.addStyle(s, {
                        cursor: "pointer"
                    })) : o.setAttribute("readonly", "true"), e.validation && (o.setAttribute("required", "true"), o.setAttribute("aria-required", "true"), o.addEventListener("keydown", Uv));
                    const l = y("div");
                    P.addClass(l, "valid-feedback"), t = document.createTextNode("".concat(e.validFeedback)), l.appendChild(t);
                    const c = y("div");
                    P.addClass(c, "invalid-feedback"), t = document.createTextNode("".concat(e.invalidFeedback)), c.appendChild(t);
                    const h = y("span");
                    return P.addClass(h, "select-clear-btn"), t = document.createTextNode("✕"), h.appendChild(t), h.setAttribute("tabindex", "0"), t = y("span"), P.addClass(t, "select-arrow"), s.appendChild(o), i && s.appendChild(i), e.validation && (s.appendChild(l), s.appendChild(c)), e.clearButton && s.appendChild(h), s.appendChild(t), n.appendChild(s), n
                }(this._wrapperId, this._config, this._label);
                this._element.parentNode.insertBefore(t, this._element), P.addClass(this._element, hb), t.appendChild(this._element)
            }
            _initOutlineInput() {
                var t = R.findOne(cb, this._wrapper);
                const e = new Xo(t);
                e.init()
            }
            _bindComponentEvents() {
                this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown()
            }
            _setDefaultSelections() {
                this.options.forEach(t => {
                    t.selected && this._selectionModel.select(t)
                })
            }
            _listenToComponentKeydown() {
                I.on(this._wrapper, "keydown", this._handleKeydown.bind(this))
            }
            _handleKeydown(t) {
                this._isOpen && !this._config.filter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)
            }
            _handleOpenKeydown(t) {
                var e = t.keyCode,
                    i = 27 === e || 38 === e && t.altKey || 9 === e;
                if (9 === e && this._config.autoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) return this.close(), void this._input.focus();
                switch (e) {
                    case 40:
                        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
                        break;
                    case 38:
                        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
                        break;
                    case 36:
                        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
                        break;
                    case 35:
                        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
                        break;
                    case 13:
                        return t.preventDefault(), void(this._activeOption && (this.hasSelectAll && 0 === this._activeOptionIndex ? this._handleSelectAll() : this._handleSelection(this._activeOption)));
                    default:
                        return
                }
                t.preventDefault()
            }
            _handleClosedKeydown(t) {
                var e = t.keyCode;
                if (13 === e && t.preventDefault(), (13 === e || 40 === e && t.altKey || 40 === e && this.multiple) && this.open(), this.multiple) switch (e) {
                    case 40:
                    case 38:
                        this.open();
                        break;
                    default:
                        return
                } else switch (e) {
                    case 40:
                        this._setNextOptionActive(), this._handleSelection(this._activeOption);
                        break;
                    case 38:
                        this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
                        break;
                    case 36:
                        this._setFirstOptionActive(), this._handleSelection(this._activeOption);
                        break;
                    case 35:
                        this._setLastOptionActive(), this._handleSelection(this._activeOption);
                        break;
                    default:
                        return
                }
                t.preventDefault()
            }
            _scrollToOption(e) {
                if (e) {
                    let t;
                    const o = this.options.filter(t => !t.hidden);
                    t = this.hasSelectAll ? o.indexOf(e) + 1 : o.indexOf(e);
                    var i = this._getNumberOfGroupsBeforeOption(t),
                        n = t + i;
                    const a = this.optionsWrapper;
                    var s = a.offsetHeight,
                        e = this._config.optionHeight,
                        i = a.scrollTop; - 1 < t && (n = n * e, a.scrollTop = n < i ? n : i + s < n + e ? n - s + e : i)
                }
            }
            _getNumberOfGroupsBeforeOption(t) {
                var e = this.options.filter(t => !t.hidden),
                    i = this._optionsToRender.filter(t => !t.hidden),
                    n = this.hasSelectAll ? t - 1 : t;
                let s = 0;
                for (let t = 0; t <= n; t++) e[t].groupId && i[s] && i[s].id && e[t].groupId === i[s].id && s++;
                return s
            }
            _setNextOptionActive() {
                let t = this._activeOptionIndex + 1;
                var e = this._getNavigationOptions();
                if (e[t]) {
                    for (; e[t].disabled;)
                        if (t += 1, !e[t]) return;
                    this._updateActiveOption(e[t], t)
                }
            }
            _setPreviousOptionActive() {
                let t = this._activeOptionIndex - 1;
                var e = this._getNavigationOptions();
                if (e[t]) {
                    for (; e[t].disabled;)
                        if (--t, !e[t]) return;
                    this._updateActiveOption(e[t], t)
                }
            }
            _setFirstOptionActive() {
                var t = this._getNavigationOptions();
                this._updateActiveOption(t[0], 0)
            }
            _setLastOptionActive() {
                var t = this._getNavigationOptions(),
                    e = t.length - 1;
                this._updateActiveOption(t[e], e)
            }
            _updateActiveOption(t, e) {
                const i = this._activeOption;
                i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t
            }
            _listenToWrapperClick() {
                I.on(this._wrapper, "click", () => {
                    this.toggle()
                })
            }
            _listenToClearBtnClick() {
                I.on(this.clearButton, "click", t => {
                    t.preventDefault(), t.stopPropagation(), this._handleClear()
                })
            }
            _listenToClearBtnKeydown() {
                I.on(this.clearButton, "keydown", t => {
                    13 === t.keyCode && (this._handleClear(), t.preventDefault(), t.stopPropagation())
                })
            }
            _handleClear() {
                if (this.multiple) this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
                else {
                    const t = this._selectionModel.selection;
                    this._selectionModel.clear(), t.deselect()
                }
                this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent()
            }
            _listenToOptionsClick() {
                I.on(this.optionsWrapper, "click", t => {
                    if (!t.target.classList.contains("select-option-group-label")) {
                        const e = "DIV" === t.target.nodeName ? t.target : R.closest(t.target, ".select-option");
                        if (e.classList.contains("select-all-option")) this._handleSelectAll();
                        else {
                            const i = e.dataset.mdbId;
                            t = this.options.find(t => t.id === i);
                            t && !t.disabled && this._handleSelection(t)
                        }
                    }
                })
            }
            _handleSelectAll() {
                this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent()
            }
            _selectAllOptions(t) {
                t.forEach(t => {
                    t.selected || t.disabled || (this._selectionModel.select(t), t.select())
                })
            }
            _deselectAllOptions(t) {
                t.forEach(t => {
                    t.selected && !t.disabled && (this._selectionModel.deselect(t), t.deselect())
                })
            }
            _handleSelection(t) {
                this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility()
            }
            _handleAutoSelection(t) {
                this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility()
            }
            _handleSingleSelection(t) {
                this._singleOptionSelect(t), this.close(), this._input.focus()
            }
            _singleOptionSelect(t) {
                const e = this._selectionModel.selections[0];
                e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute("selected", !1), I.trigger(this._element, ob, {
                    value: e.value
                })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), I.trigger(this._element, sb, {
                    value: t.value
                }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent())
            }
            _handleMultiSelection(t) {
                t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute("selected", !1), I.trigger(this._element, ob, {
                    value: t.value
                })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), I.trigger(this._element, sb, {
                    value: t.value
                })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent()
            }
            _emitValueChangeEvent(t) {
                I.trigger(this._element, ab, {
                    value: t
                })
            }
            _emitNativeChangeEvent() {
                I.trigger(this._element, "change")
            }
            _updateInputValue() {
                var t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
                let e;
                e = this.multiple && -1 !== this._config.displayedLabels && this._selectionModel.selections.length > this._config.displayedLabels ? "".concat(this._selectionModel.selections.length, " ").concat(this._config.optionsSelectedLabel) : t, this.multiple || this._isSelectionValid(this._selectionModel.selection) ? this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label : this._input.value = ""
            }
            _isSelectionValid(t) {
                return !t || !t.disabled && "" !== t.value
            }
            _isLabelEmpty(t) {
                return !(!t || "" !== t.label)
            }
            _appendFakeValue() {
                if (this._selectionModel.selection && !this._selectionModel._multiple) {
                    var t = this._selectionModel.selection.label;
                    this._fakeValue = function(t) {
                        const e = y("div");
                        return e.innerHTML = t, P.addClass(e, "form-label"), P.addClass(e, "select-fake-value"), e
                    }(t);
                    const e = R.findOne(cb, this._wrapper);
                    e.appendChild(this._fakeValue)
                }
            }
            _updateLabelPosition() {
                var t = P.hasClass(this._element, hb),
                    e = "" !== this._input.value;
                this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? P.addClass(this._label, db) : P.removeClass(this._label, db))
            }
            _updateLabelPositionWhileClosing() {
                this._label && ("" !== this._input.value || this._isFakeValueActive ? P.addClass(this._label, db) : P.removeClass(this._label, db))
            }
            _updateFakeLabelPosition() {
                this._fakeValue && ("" === this._input.value && "" !== this._fakeValue.innerHTML ? (this._isFakeValueActive = !0, P.addClass(this._fakeValue, db)) : (this._isFakeValueActive = !1, P.removeClass(this._fakeValue, db)))
            }
            _updateClearButtonVisibility() {
                this.clearButton && (this._selectionModel.selection || 0 < this._selectionModel.selections.length ? P.addStyle(this.clearButton, {
                    display: "block"
                }) : P.addStyle(this.clearButton, {
                    display: "none"
                }))
            }
            _updateSelectAllState() {
                var t = this._selectAllOption.selected,
                    e = Xv(this.options);
                !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select()
            }
            toggle() {
                this._isOpen ? this.close() : this.open()
            }
            open() {
                var t = this._config.disabled,
                    e = I.trigger(this._element, nb);
                this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.filter && (setTimeout(() => {
                    this.filterInput.focus()
                }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles())
            }
            _openDropdown() {
                this._popper = Qn(this._input, this._dropdownContainer, {
                    placement: "bottom-start",
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: [0, 1]
                        }
                    }]
                }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
                    P.addClass(this.dropdown, "open")
                }, 0)
            }
            _updateDropdownWidth() {
                var t = this._input.offsetWidth;
                P.addStyle(this._dropdownContainer, {
                    width: "".concat(t, "px")
                })
            }
            _setFirstActiveOption() {
                const t = this._getNavigationOptions(),
                    e = this._activeOption;
                e && e.removeActiveStyles();
                const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
                i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(t => t === i)) : (this._activeOption = null, this._activeOptionIndex = -1)
            }
            _setInputActiveStyles() {
                P.addClass(this._input, "focused")
            }
            _listenToWindowResize() {
                I.on(window, "resize", this._handleWindowResize.bind(this))
            }
            _handleWindowResize() {
                this._dropdownContainer && this._updateDropdownWidth()
            }
            _listenToSelectSearch() {
                this.filterInput.addEventListener("input", t => {
                    var e = t.target.value,
                        t = this._config.filterDebounce;
                    this._debounceFilter(e, t)
                })
            }
            _debounceFilter(t, e) {
                this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
                    this._filterOptions(t)
                }, e)
            }
            _filterOptions(s) {
                const o = [];
                this._optionsToRender.forEach(t => {
                    var e = t.hasOwnProperty("options"),
                        i = !e && t.label.toLowerCase().includes(s.toLowerCase());
                    const n = {};
                    e && (n.label = t.label, n.options = this._filter(s, t.options), 0 < n.options.length && o.push(n)), i && o.push(t)
                });
                var t = "" !== this._config.noResultText,
                    e = 0 !== o.length;
                e ? (this._updateOptionsListTemplate(o), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(o), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption()) : !e && t && (t = this._getNoResultTemplate(), this.optionsWrapper.innerHTML = t)
            }
            _updateOptionsListTemplate(t) {
                var e = R.findOne(lb, this._dropdownContainer) || R.findOne(".select-no-results", this._dropdownContainer),
                    t = $v(t, this._selectAllOption, this._config);
                this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(t)
            }
            _getNoResultTemplate() {
                return '<div class="select-no-results" style="height: '.concat(this._config.optionHeight, 'px">').concat(this._config.noResultText, "</div>")
            }
            _filter(t, e) {
                const i = t.toLowerCase();
                return e.filter(t => t.label.toLowerCase().includes(i))
            }
            _listenToDropdownKeydown() {
                I.on(this.dropdown, "keydown", this._handleOpenKeydown.bind(this))
            }
            _listenToOutsideClick() {
                this._outsideClick = this._handleOutSideClick.bind(this), I.on(document, "click", this._outsideClick)
            }
            _handleOutSideClick(i) {
                var t = this._wrapper && this._wrapper.contains(i.target),
                    e = i.target === this._dropdownContainer,
                    n = this._dropdownContainer && this._dropdownContainer.contains(i.target);
                let s;
                this._toggleButton || (this._elementToggle = R.find("[data-mdb-toggle]")), this._elementToggle && this._elementToggle.forEach(t => {
                    var e = P.getDataAttribute(t, "toggle");
                    e !== this._element.id && !this._element.classList.contains(e) || (this._toggleButton = t, s = this._toggleButton.contains(i.target))
                }), t || e || n || s || this.close()
            }
            close() {
                var t = I.trigger(this._element, ib);
                this._isOpen && !t.defaultPrevented && (this._config.filter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), P.removeClass(this.dropdown, "open"), setTimeout(() => {
                    P.removeClass(this._input, "focused"), this._label && !this.hasSelection && (P.removeClass(this._label, db), P.removeClass(this._input, db)), this._updateLabelPositionWhileClosing()
                }, 0), setTimeout(() => {
                    this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, I.off(this.dropdown, "transitionend")
                }, 200))
            }
            _resetFilterState() {
                this.filterInput.value = "", this._filteredOptionsList = null
            }
            _removeDropdownEvents() {
                I.off(document, "click", this._outsideClick), this._config.filter && I.off(this.dropdown, "keydown"), I.off(this.optionsWrapper, "click")
            }
            _addMutationObserver() {
                this._mutationObserver = new MutationObserver(() => {
                    this._wrapper && (this._updateSelections(), this._updateDisabledState())
                }), this._observeMutationObserver()
            }
            _updateSelections() {
                this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
                var t = this._config.filter && this.filterInput && this.filterInput.value;
                this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = Kv(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent)
            }
            _updateDisabledState() {
                const t = R.findOne(rb, this._wrapper);
                this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", "")) : (this._config.disabled = !1, t.removeAttribute("disabled"))
            }
            _observeMutationObserver() {
                this._mutationObserver && this._mutationObserver.observe(this._element, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                })
            }
            _disconnectMutationObserver() {
                this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null)
            }
            _createSelectAllOption() {
                var t = this._selectAllId,
                    e = this._config.selectAllLabel,
                    i = Xv(this.options);
                return new zv(t, null, !0, "select-all", e, i, !1, !1, null, null, null)
            }
            dispose() {
                this._removeComponentEvents(), this._destroyMaterialSelect(), p.removeData(this._element, eb)
            }
            _removeComponentEvents() {
                I.off(this.input, "click"), I.off(this.wrapper, this._handleKeydown.bind(this)), I.off(this.clearButton, "click"), I.off(this.clearButton, "keydown"), I.off(window, "resize", this._handleWindowResize.bind(this))
            }
            _destroyMaterialSelect() {
                this._isOpen && this.close(), this._destroyMaterialTemplate()
            }
            _destroyMaterialTemplate() {
                const e = this._wrapper.parentNode,
                    t = R.find("label", this._wrapper);
                e.appendChild(this._element), t.forEach(t => {
                    e.appendChild(t)
                }), t.forEach(t => {
                    P.removeClass(t, db)
                }), P.removeClass(this._element, hb), e.removeChild(this._wrapper)
            }
            setValue(t) {
                this.options.filter(t => t.selected).forEach(t => t.nativeOption.selected = !1), Array.isArray(t) ? t.forEach(t => {
                    this._selectByValue(t)
                }) : this._selectByValue(t), this._updateSelections()
            }
            _selectByValue(e) {
                const t = this.options.find(t => t.value === e);
                return !!t && (t.nativeOption.selected = !0)
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, eb);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new ub(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, eb)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        var pb = ub;
        const fb = l();
        R.find(".select").forEach(t => {
            var e = ub.getInstance(t);
            e || new ub(t)
        }), c(() => {
            if (fb) {
                const t = fb.fn[tb];
                fb.fn[tb] = ub.jQueryInterface, fb.fn[tb].Constructor = ub, fb.fn[tb].noConflict = () => (fb.fn[tb] = t, ub.jQueryInterface)
            }
        });
        const gb = "datatable",
            _b = "mdb.datatable",
            mb = "datatable",
            vb = "fixed-cell";
        const bb = ".datatable-sort-icon",
            yb = ".datatable-body tr",
            xb = ".datatable-row-checkbox",
            wb = "render.mdb.datatable",
            Cb = {
                bordered: "boolean",
                borderless: "boolean",
                borderColor: "(string|null)",
                clickableRows: "boolean",
                color: "(string|null)",
                defaultValue: "string",
                edit: "boolean",
                entries: "(number|string)",
                entriesOptions: "array",
                fullPagination: "boolean",
                hover: "boolean",
                loading: "boolean",
                loadingMessage: "string",
                maxWidth: "(null|number|string)",
                maxHeight: "(null|number|string)",
                multi: "boolean",
                noFoundMessage: "string",
                pagination: "boolean",
                selectable: "boolean",
                sm: "boolean",
                sortField: "(null|string)",
                sortOrder: "string",
                loaderClass: "string",
                fixedHeader: "boolean",
                striped: "boolean",
                rowsText: "string",
                ofText: "string",
                allText: "string",
                forceSort: "boolean"
            },
            kb = {
                label: "string",
                field: "string",
                fixed: "(boolean|string)",
                format: "(function|null)",
                width: "(number|null)",
                sort: "boolean",
                columnIndex: "number"
            },
            Tb = {
                bordered: !1,
                borderless: !1,
                borderColor: null,
                clickableRows: !1,
                color: null,
                dark: !1,
                defaultValue: "-",
                edit: !1,
                entries: 10,
                entriesOptions: [10, 25, 50, 200],
                fixedHeader: !1,
                fullPagination: !1,
                hover: !1,
                loaderClass: "bg-primary",
                loading: !1,
                loadingMessage: "Loading results...",
                maxWidth: null,
                maxHeight: null,
                multi: !1,
                noFoundMessage: "No matching results found",
                pagination: !0,
                selectable: !1,
                sm: !1,
                sortField: null,
                sortOrder: "asc",
                striped: !1,
                rowsText: "Rows per page:",
                ofText: "of",
                allText: "All",
                forceSort: !1
            },
            Sb = {
                label: "",
                field: "",
                fixed: !1,
                format: null,
                width: null,
                sort: !0,
                columnIndex: 0
            };
        class Eb {
            constructor(t, e = {}, i = {}) {
                this._element = t, this._options = this._getOptions(i), this._sortField = this._options.sortField, this._sortOrder = this._options.sortOrder, this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (p.setData(t, _b, this), this._perfectScrollbar = null, this._setup())
            }
            static get NAME() {
                return gb
            }
            get columns() {
                return this._columns.map((t, e) => {
                    let i = { ...Sb,
                        field: "field_".concat(e),
                        columnIndex: e
                    };
                    return "string" == typeof t ? i.label = t : "object" == typeof t && (i = { ...i,
                        ...t
                    }), a("column", i, kb), i
                })
            }
            get rows() {
                return this._rows.map((i, t) => {
                    const n = {
                        rowIndex: t
                    };
                    return Array.isArray(i) ? this.columns.forEach((t, e) => {
                        0 === i[e] ? n[t.field] = i[e] : n[t.field] = i[e] || this._options.defaultValue
                    }) : "object" == typeof i && this.columns.forEach(t => {
                        0 === i[t.field] ? n[t.field] = i[t.field] : n[t.field] = i[t.field] || this._options.defaultValue
                    }), n
                })
            }
            get searchResult() {
                return ((t, i, n) => {
                    if (!i) return t;
                    const s = t => {
                        const e = document.createElement("div");
                        return e.innerHTML = t, (t = e.textContent || e.innerText || "").toString().toLowerCase().match(i.toLowerCase())
                    };
                    return t.filter(e => {
                        if (n && "string" == typeof n) return s(e[n]);
                        let t = Object.values(e);
                        return n && Array.isArray(n) && (t = Object.keys(e).filter(t => n.includes(t)).map(t => e[t])), 0 < t.filter(t => s(t)).length
                    })
                })(this.rows, this._search, this._searchColumn)
            }
            get computedRows() {
                let t = [...this.searchResult];
                var e, s, o;
                return this._sortOrder && (t = ([{
                    rows: e,
                    field: s,
                    order: o
                }] = [{
                    rows: t,
                    field: this._sortField,
                    order: this._sortOrder
                }], e.sort((t, e) => {
                    let i = t[s],
                        n = e[s];
                    return "string" == typeof i && (i = i.toLowerCase()), "string" == typeof n && (n = n.toLowerCase()), i < n ? "desc" === o ? 1 : -1 : i > n ? "desc" === o ? -1 : 1 : 0
                }))), this._options.pagination && (t = "All" === this._options.entries ? Wv({
                    rows: t,
                    entries: t.length,
                    activePage: this._activePage
                }) : Wv({
                    rows: t,
                    entries: this._options.entries,
                    activePage: this._activePage
                })), t
            }
            get pages() {
                return "All" === this._options.entries ? 1 : Math.ceil(this.searchResult.length / this._options.entries)
            }
            get navigationText() {
                var t = this._activePage * this._options.entries;
                return 0 === this.searchResult.length ? "0 ".concat(this._options.ofText, " 0") : ("All" === this._options.entries ? "1 - ".concat(this.searchResult.length, " ") : "".concat(1 + t, " - ").concat(this.computedRows.length + t, " ")).concat(this._options.ofText, " ").concat(this.searchResult.length)
            }
            get classNames() {
                return [mb, this._options.color, this._options.borderColor && "border-".concat(this._options.borderColor), this._options.dark && "datatable-dark", this._options.hover && "datatable-hover", this._options.bordered && "datatable-bordered", this._options.borderless && "datatable-borderless", this._options.sm && "datatable-sm", this._options.striped && "datatable-striped", this._options.loading && "datatable-loading", this._options.clickableRows && "datatable-clickable-rows"].filter(t => t)
            }
            get tableOptions() {
                return {
                    columns: this.columns,
                    rows: this.computedRows,
                    noFoundMessage: this._options.noFoundMessage,
                    edit: this._options.edit,
                    loading: this._options.loading,
                    loaderClass: this._options.loaderClass,
                    loadingMessage: this._options.loadingMessage,
                    selectable: this._options.selectable,
                    multi: this._options.multi,
                    pagination: {
                        enable: this._options.pagination,
                        text: this.navigationText,
                        entries: this._options.entries,
                        entriesOptions: this._options.entriesOptions,
                        fullPagination: this._options.fullPagination,
                        rowsText: this._options.rowsText,
                        ofText: this._options.ofText,
                        allText: this._options.allText
                    },
                    forceSort: this._options.forceSort
                }
            }
            update(t, e = {}) {
                t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options,
                    ...e
                }), this._setup()
            }
            dispose() {
                this._selectInstance && this._selectInstance.dispose(), p.removeData(this._element, _b), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null
            }
            search(t, e) {
                this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows()
            }
            sort(e, t = "asc") {
                this._sortOrder = t, this._sortField = ("string" == typeof e ? this.columns.find(t => t.label === e) : e).field;
                t = R.findOne('i[data-mdb-sort="'.concat(this._sortField, '"]'), this._element);
                this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(t)
            }
            setActivePage(t) {
                t < this.pages && this._changeActivePage(t)
            }
            _changeActivePage(t) {
                this._activePage = t, this._toggleDisableState(), this._renderRows()
            }
            _clearClassList(e) {
                this._options.color && e.color && P.removeClass(this._element, this._options.color), this._options.borderColor && e.borderColor && P.removeClass(this._element, "border-".concat(this._options.borderColor)), ["dark", "hover", "bordered", "borderless", "sm", "striped", "loading"].forEach(t => {
                    this._options[t] && !e[t] && P.removeClass(this._element, "datatable-".concat(t))
                })
            }
            _emitSelectEvent() {
                I.trigger(this._element, "selectRows.mdb.datatable", {
                    selectedRows: this.rows.filter(t => -1 !== this._selected.indexOf(t.rowIndex)),
                    selectedIndexes: this._selected,
                    allSelected: this._selected.length === this.rows.length
                })
            }
            _getRows(t = []) {
                var e = R.findOne("tbody", this._element);
                return e ? [...R.find("tr", e).map(t => R.find("td", t).map(t => t.innerHTML)), ...t] : t
            }
            _getColumns(t = []) {
                var e = R.findOne("thead", this._element);
                if (!e) return t;
                e = R.findOne("tr", e);
                return [...R.find("th", e).map(t => ({
                    label: t.innerHTML,
                    ...P.getDataAttributes(t)
                })), ...t]
            }
            _getCSSValue(t) {
                return "string" == typeof t ? t : "".concat(t, "px")
            }
            _getOptions(t) {
                t = { ...Tb,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(gb, t, Cb), t
            }
            _setActiveRows() {
                R.find(yb, this._element).forEach(t => {
                    this._selected.includes(P.getDataAttribute(t, "index")) ? P.addClass(t, "active") : P.removeClass(t, "active")
                })
            }
            _setEntries(t) {
                this._options = this._getOptions({ ...this._options,
                    entries: t.target.value
                }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows()
            }
            _setSelected() {
                R.find(xb, this._element).forEach(t => {
                    var e = P.getDataAttribute(t, "rowIndex");
                    t.checked = this._selected.includes(e)
                }), this._setActiveRows()
            }
            _setActiveSortIcon(i) {
                R.find(bb, this._element).forEach(t => {
                    var e = "desc" === this._sortOrder && t === i ? 180 : 0;
                    P.style(t, {
                        transform: "rotate(".concat(e, "deg)")
                    }), t === i && this._sortOrder ? P.addClass(t, "active") : P.removeClass(t, "active")
                })
            }
            _setClassNames() {
                this.classNames.forEach(t => {
                    P.addClass(this._element, t)
                })
            }
            _setup() {
                this._setClassNames(), this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort()
            }
            _setupClickableRows() {
                R.find(yb, this._element).forEach(t => {
                    const e = P.getDataAttribute(t, "index");
                    I.on(t, "click", t => {
                        R.matches(t.target, xb) || I.trigger(this._element, "rowClick.mdb.datatable", {
                            index: e,
                            row: this.rows[e]
                        })
                    })
                })
            }
            _setupEditable() {
                R.find(yb, this._element).forEach(t => {
                    const e = P.getDataAttribute(t, "index");
                    R.find("td", t).forEach(t => {
                        I.on(t, "input", t => this._updateRow(t, e))
                    })
                })
            }
            _setupScroll() {
                var t, e = R.findOne(".datatable-inner", this._element);
                const i = {
                    overflow: "auto",
                    position: "relative"
                };
                if (this._options.maxHeight && (i.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth && (t = this._getCSSValue(this._options.maxWidth), i.maxWidth = t, P.style(this._element, {
                        maxWidth: t
                    })), P.style(e, i), this._options.fixedHeader) {
                    let t = R.find(".datatable-header th", this._element);
                    this._options.selectable && (t = t.filter((t, e) => (P.addClass(t, vb), this._options.color && P.addClass(t, this._options.color), 0 !== e))), t.forEach((t, e) => {
                        P.addClass(t, vb), this.columns[e].fixed && P.addStyle(t, {
                            zIndex: 4
                        }), this._options.color && P.addClass(t, this._options.color)
                    })
                }
                this._perfectScrollbar = new Rv(e)
            }
            _setupSort() {
                R.find(bb, this._element).forEach(t => {
                    const e = P.getDataAttribute(t, "sort");
                    var [i] = R.parents(t, "th");
                    P.style(i, {
                        cursor: "pointer"
                    }), e === this._options.sortField && this._setActiveSortIcon(t), I.on(i, "click", () => {
                        this._sortField === e && "asc" === this._sortOrder ? this._sortOrder = "desc" : this._sortField === e && "desc" === this._sortOrder ? this._sortOrder = this._options.forceSort ? "asc" : null : this._sortOrder = "asc", this._sortField = e, this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(t)
                    })
                })
            }
            _setupSelectable() {
                this._checkboxes = R.find(xb, this._element), this._headerCheckbox = R.findOne(".datatable-header-checkbox", this._element), I.on(this._headerCheckbox, "input", t => this._toggleSelectAll(t)), this._checkboxes.forEach(t => {
                    const e = P.getDataAttribute(t, "rowIndex");
                    I.on(t, "input", t => this._toggleSelectRow(t, e))
                })
            }
            _setupPagination() {
                this._paginationRight = R.findOne(".datatable-pagination-right", this._element), this._paginationLeft = R.findOne(".datatable-pagination-left", this._element), I.on(this._paginationRight, "click", () => this._changeActivePage(this._activePage + 1)), I.on(this._paginationLeft, "click", () => this._changeActivePage(this._activePage - 1)), this._options.fullPagination && (this._paginationStart = R.findOne(".datatable-pagination-start", this._element), this._paginationEnd = R.findOne(".datatable-pagination-end", this._element), I.on(this._paginationStart, "click", () => this._changeActivePage(0)), I.on(this._paginationEnd, "click", () => this._changeActivePage(this.pages - 1))), this._toggleDisableState(), this._setupPaginationSelect()
            }
            _setupPaginationSelect() {
                this._select = R.findOne(".datatable-select", this._element), this._selectInstance && this._selectInstance.dispose(), this._selectInstance = new pb(this._select), I.on(this._select, "valueChange.mdb.select", t => this._setEntries(t))
            }
            _removeEventListeners() {
                this._options.pagination && (I.off(this._paginationRight, "click"), I.off(this._paginationLeft, "click"), I.off(this._select, "valueChange.mdb.select"), this._options.fullPagination && (I.off(this._paginationStart, "click"), I.off(this._paginationEnd, "click"))), this._options.editable && R.find("td", this._element).forEach(t => {
                    I.off(t, "input")
                }), this._options.clickableRows && R.find(yb, this._element).forEach(t => {
                    I.off(t, "click")
                }), R.find(bb, this._element).forEach(t => {
                    var [t] = R.parents(t, "th");
                    I.off(t, "click")
                }), this._options.selectable && (I.off(this._headerCheckbox, "input"), this._checkboxes.forEach(t => {
                    I.off(t, "input")
                }))
            }
            _renderTable() {
                this._element.innerHTML = jv(this.tableOptions).table, this._formatCells(), I.trigger(this._element, wb)
            }
            _renderRows() {
                const t = R.findOne("tbody", this._element);
                if (this._options.pagination) {
                    const e = R.findOne(".datatable-pagination-nav", this._element);
                    e.innerText = this.navigationText
                }
                t.innerHTML = jv(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), I.trigger(this._element, wb)
            }
            _formatCells() {
                const t = R.find(yb, this._element);
                t.forEach(t => {
                    const n = P.getDataAttribute(t, "index"),
                        e = R.find("td", t);
                    e.forEach(t => {
                        const e = P.getDataAttribute(t, "field"),
                            i = this.columns.find(t => t.field === e);
                        i && null !== i.format && i.format(t, this.rows[n][e])
                    })
                })
            }
            _toggleDisableState() {
                !1 !== this._options.pagination && (0 === this._activePage || this._options.loading ? (this._paginationLeft.setAttribute("disabled", !0), this._options.fullPagination && this._paginationStart.setAttribute("disabled", !0)) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || 0 === this.pages ? (this._paginationRight.setAttribute("disabled", !0), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", !0)) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")))
            }
            _toggleSelectAll(t) {
                t.target.checked ? this._selected = this.rows.map(t => t.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent()
            }
            _toggleSelectRow(e, i) {
                e.target.checked ? this._options.multi && !this._selected.includes(i) ? this._selected = [...this._selected, i] : (this._selected = [i], this._checkboxes.forEach(t => {
                    t !== e.target && (t.checked = !1)
                })) : this._selected = this._selected.filter(t => t !== i), this._options.multi && !e.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent()
            }
            _updateRow(t, e) {
                const i = P.getDataAttribute(t.target, "field");
                t = t.target.textContent;
                const n = this._rows[e];
                Array.isArray(n) ? (e = this.columns.find(t => t.field === i).columnIndex, n[e] = t) : n[i] = t, I.trigger(this._element, "update.mdb.datatable", {
                    rows: this._rows,
                    columns: this._columns
                })
            }
            static jQueryInterface(i, n, s) {
                return this.each(function() {
                    let t = p.getData(this, _b);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Eb(this, e, n), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n, s)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, _b)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".datatable").forEach(t => {
            let e = Eb.getInstance(t);
            return e = e || new Eb(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[gb];
                t.fn[gb] = Eb.jQueryInterface, t.fn[gb].Constructor = Eb, t.fn[gb].noConflict = () => (t.fn[gb] = e, Eb.jQueryInterface)
            }
        });
        var Ab = Eb;
        const Mb = "stepper",
            Ob = "mdb.stepper";
        Ot = ".".concat(Ob);
        const Ib = "horizontal",
            Db = "vertical",
            Lb = "mobile",
            Pb = {
                stepperType: "string",
                stepperLinear: "boolean",
                stepperNoEditable: "boolean",
                stepperActive: "string",
                stepperCompleted: "string",
                stepperInvalid: "string",
                stepperDisabled: "string",
                stepperVerticalBreakpoint: "number",
                stepperMobileBreakpoint: "number",
                stepperMobileBarBreakpoint: "number",
                animations: "boolean",
                stepperHeadClick: "boolean",
                stepperMobileNextBtn: "string",
                stepperMobileBackBtn: "string",
                stepperMobileStepTxt: "string",
                stepperMobileOfTxt: "string"
            },
            Rb = {
                stepperType: Ib,
                stepperLinear: !1,
                stepperNoEditable: !1,
                stepperActive: "",
                stepperCompleted: "",
                stepperInvalid: "",
                stepperDisabled: "",
                stepperVerticalBreakpoint: 0,
                stepperMobileBreakpoint: 0,
                stepperMobileBarBreakpoint: 4,
                animations: !0,
                stepperHeadClick: !0,
                stepperMobileNextBtn: "NEXT",
                stepperMobileBackBtn: "BACK",
                stepperMobileStepTxt: "step",
                stepperMobileOfTxt: "of"
            },
            Bb = "mousedown".concat(Ot),
            Nb = "submit".concat(Ot),
            Hb = "keydown".concat(Ot),
            jb = "keyup".concat(Ot),
            Wb = "resize".concat(Ot),
            Fb = "click".concat(Ot),
            Vb = "animationend",
            zb = "onChangeStep".concat(Ot),
            Yb = "onInvalid".concat(Ot),
            Xb = "onValid".concat(Ot),
            Ub = "".concat(Mb, "-step"),
            Kb = "".concat(Mb, "-head"),
            $b = "".concat(Mb, "-head-text"),
            Qb = "".concat(Mb, "-content"),
            qb = "".concat(Mb, "-active"),
            Zb = "".concat(Mb, "-completed"),
            Gb = "".concat(Mb, "-invalid"),
            Jb = "".concat(Mb, "-disabled"),
            ty = "".concat(Mb, "-").concat(Db),
            ey = "".concat(Mb, "-content-hide"),
            iy = "".concat(Mb, "-").concat(Ib),
            ny = "".concat(Mb, "-").concat(Lb),
            sy = "".concat(Mb, "-").concat(Lb, "-head"),
            oy = "".concat(Mb, "-").concat(Lb, "-footer"),
            ay = "".concat(Mb, "-").concat(Lb, "-progress-bar");
        i = "".concat(Mb, "-").concat(Lb, "-progress");
        const ry = "".concat(Mb, "-next-btn"),
            ly = "".concat(Mb, "-back-btn"),
            cy = "".concat(Mb, "-active-step"),
            hy = "".concat(Mb, "-all-steps"),
            dy = '\n  <div class="'.concat(i, ' gray-500">\n    <div class="').concat(ay, ' bg-primary"></div>\n  </div>\n'),
            uy = '\n  <div class="'.concat(oy, ' bg-light"></div>\n');
        class py {
            constructor(t, e) {
                this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = R.find(".".concat(Ub), this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._element && (p.setData(t, Ob, this), this._init())
            }
            static get NAME() {
                return Mb
            }
            get activeStep() {
                return this._steps[this._activeStepIndex]
            }
            get activeStepIndex() {
                return this._activeStepIndex
            }
            dispose() {
                this._steps.forEach(t => {
                    I.off(t, Bb), I.off(t, Hb)
                }), I.off(window, Wb), p.removeData(this._element, Ob), this._element = null
            }
            changeStep(t) {
                this._toggleStep(t)
            }
            nextStep() {
                this._toggleStep(this._activeStepIndex + 1)
            }
            previousStep() {
                this._toggleStep(this._activeStepIndex - 1)
            }
            _init() {
                var t = R.findOne(".".concat(qb), this._element);
                switch (t ? this._activeStepIndex = this._steps.indexOf(t) : this._toggleStepClass(this._activeStepIndex, "add", qb), this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperActive), this._setOptional(), this._options.stepperHeadClick && this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
                    case Db:
                        this._toggleVertical();
                        break;
                    case Lb:
                        this._toggleMobile();
                        break;
                    default:
                        this._toggleHorizontal()
                }(this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._options.stepperLinear && this._setValidation(), this._bindResize()
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...Rb,
                    ...e,
                    ...t
                }, a(Mb, t, Pb), t
            }
            _bindMouseDown() {
                this._steps.forEach(t => {
                    t = R.findOne(".".concat(Kb), t);
                    I.on(t, Bb, t => {
                        var e = R.parents(t.target, ".".concat(Ub))[0],
                            e = this._steps.indexOf(e);
                        t.preventDefault(), this._toggleStep(e)
                    })
                })
            }
            _bindResize() {
                I.on(window, Wb, () => {
                    this._currentView === Db && this._setSingleStepHeight(this.activeStep), this._currentView === Ib && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView()
                })
            }
            _toggleStepperView() {
                var t = this._options.stepperVerticalBreakpoint < window.innerWidth,
                    e = this._options.stepperVerticalBreakpoint > window.innerWidth,
                    i = this._options.stepperMobileBreakpoint > window.innerWidth;
                t && this._currentView !== Ib && this._toggleHorizontal(), e && !i && this._currentView !== Db && (this._steps.forEach(t => {
                    t = R.findOne(".".concat(Qb), t);
                    this._resetStepperHeight(), this._showElement(t)
                }), this._toggleVertical()), i && this._currentView !== Lb && this._toggleMobile()
            }
            _toggleStep(t) {
                var e = this._steps.length;
                if (this._validateStep(t)) {
                    if (this._options.stepperLinear && I.trigger(this.activeStep, Xb), this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(R.findOne(".".concat(Qb), this._steps[t])), this._toggleActive(t), (!this._options.stepperLinear || t > this._activeStepIndex) && this._toggleCompleted(this._activeStepIndex), this._currentView === Ib || this._currentView === Lb ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(R.findOne(".".concat(Kb), this.activeStep), R.findOne(".".concat(Kb), this._steps[t])), this._activeStepIndex = t, this._currentView === Lb) {
                        const n = R.findOne("#".concat(cy), this._element);
                        n.textContent = this._activeStepIndex + 1, e > this._options.stepperMobileBarBreakpoint && this._updateProgressBar()
                    }
                    const i = this.activeStep.querySelectorAll(".form-outline");
                    e = R.find(".form-notch", i[0]);
                    i.length && e.length < 1 && i.forEach(t => {
                        new mdb.Input(t).init()
                    })
                }
            }
            _resetStepperHeight() {
                this._element.style.height = ""
            }
            _setStepsHeight() {
                this._steps.forEach(t => {
                    const e = R.findOne(".".concat(Qb), t);
                    t = window.getComputedStyle(e);
                    this._verticalStepperStyles.push({
                        paddingTop: parseFloat(t.paddingTop),
                        paddingBottom: parseFloat(t.paddingBottom)
                    });
                    t = e.scrollHeight;
                    e.style.height = "".concat(t, "px")
                })
            }
            _setSingleStepHeight(t) {
                const e = R.findOne(".".concat(Qb), t);
                var i = this.activeStep === t,
                    t = this._steps.indexOf(t);
                let n;
                n = i ? (e.style.height = "", e.scrollHeight) : e.scrollHeight + this._verticalStepperStyles[t].paddingTop + this._verticalStepperStyles[t].paddingBottom, e.style.height = "".concat(n, "px")
            }
            _createMobileElements() {
                this._element.insertAdjacentHTML("beforeend", uy);
                const t = R.findOne(".".concat(oy), this._element);
                var e;
                this._steps.length > this._options.stepperMobileBarBreakpoint && (this._element.classList.add("stepper-progress-bar"), t.insertAdjacentHTML("afterbegin", dy), this._updateProgressBar()), t.insertAdjacentHTML("afterbegin", (e = this._options, '\n  <div class="'.concat(ly, '">\n    <button type="button" class="btn btn-link">\n      <i class="fas fa-chevron-left"></i>\n      ').concat(e.stepperMobileBackBtn, "\n    </button>\n  </div>\n"))), t.insertAdjacentHTML("beforeend", (e = this._options, '\n  <div class="'.concat(ry, '">\n    <button type="button" class="btn btn-link">\n      ').concat(e.stepperMobileNextBtn, '\n      <i class="fas fa-chevron-right"></i>\n    </button>\n  </div>\n'))), this._element.insertAdjacentHTML("afterbegin", (e = this._options, '\n  <div class ="'.concat(sy, ' bg-light">\n    ').concat(e.stepperMobileStepTxt, ' <span id="').concat(cy, '"></span> ').concat(e.stepperMobileOfTxt, ' <span id="').concat(hy, '"></span>\n  </div>\n')));
                const i = R.findOne("#".concat(hy), this._element);
                i.textContent = this._steps.length;
                const n = R.findOne("#".concat(cy), this._element);
                n.textContent = this._activeStepIndex + 1
            }
            _toggleMobile() {
                this._currentView = Lb, this._toggleStepperClass(ny), this._createMobileElements(), this._bindMobileButtons(), this._setHeight(this.activeStep), this._hideInactiveSteps()
            }
            _toggleVertical() {
                this._currentView === Lb && (this._deleteMobileElements(), this._unbindMobileButtons()), this._currentView = Db, this._toggleStepperClass(ty), this._setStepsHeight(), this._hideInactiveSteps()
            }
            _toggleHorizontal() {
                this._currentView === Lb && (this._deleteMobileElements(), this._unbindMobileButtons()), this._currentView = Ib, this._toggleStepperClass(iy), this._setHeight(this.activeStep), this._hideInactiveSteps()
            }
            _toggleStepperClass(t) {
                this._element.classList.remove(iy, ny, ty), this._element.classList.add(t), t !== ty && this._steps.forEach(t => {
                    R.findOne(".".concat(Qb), t).classList.remove(ey)
                })
            }
            _toggleStepClass(t, e, i) {
                i && this._steps[t].classList[e](i)
            }
            _deleteMobileElements() {
                const t = R.findOne(".".concat(oy), this._element),
                    e = R.findOne(".".concat(sy), this._element);
                t.remove(), e.remove()
            }
            _bindKeysNavigation() {
                this._toggleStepTabIndex(!1, R.findOne(".".concat(Kb), this.activeStep)), this._steps.forEach(t => {
                    t = R.findOne(".".concat(Kb), t);
                    I.on(t, Hb, t => {
                        var e = R.parents(t.currentTarget, ".".concat(Ub))[0],
                            i = R.next(e, ".".concat(Ub))[0],
                            n = R.prev(e, ".".concat(Ub))[0],
                            s = R.findOne(".".concat(Kb), e);
                        const o = R.findOne(".".concat(Kb), this.activeStep);
                        let a = null,
                            r = null;
                        if (i && (a = R.findOne(".".concat(Kb), i)), n && (r = R.findOne(".".concat(Kb), n)), 37 === t.keyCode && this._currentView !== Db && (!h && r ? (this._toggleStepTabIndex(s, r), this._toggleOutlineStyles(s, r), r.focus()) : h && a && (this._toggleStepTabIndex(s, a), this._toggleOutlineStyles(s, a), a.focus())), 39 === t.keyCode && this._currentView !== Db && (!h && a ? (this._toggleStepTabIndex(s, a), this._toggleOutlineStyles(s, a), a.focus()) : h && r && (this._toggleStepTabIndex(s, r), this._toggleOutlineStyles(s, r), r.focus())), 40 === t.keyCode && this._currentView === Db && (t.preventDefault(), a && (this._toggleStepTabIndex(s, a), this._toggleOutlineStyles(s, a), a.focus())), 38 === t.keyCode && this._currentView === Db && (t.preventDefault(), r && (this._toggleStepTabIndex(s, r), this._toggleOutlineStyles(s, r), r.focus())), 36 === t.keyCode) {
                            const l = R.findOne(".".concat(Kb), this._steps[0]);
                            this._toggleStepTabIndex(s, l), this._toggleOutlineStyles(s, l), l.focus()
                        }
                        if (35 === t.keyCode) {
                            n = this._steps[this._steps.length - 1];
                            const c = R.findOne(".".concat(Kb), n);
                            this._toggleStepTabIndex(s, c), this._toggleOutlineStyles(s, c), c.focus()
                        }
                        13 !== t.keyCode && 32 !== t.keyCode || (t.preventDefault(), this.changeStep(this._steps.indexOf(e))), 9 === t.keyCode && (this._toggleStepTabIndex(s, o), this._toggleOutlineStyles(s, !1), o.focus())
                    }), I.on(t, jb, t => {
                        var e = R.parents(t.currentTarget, ".".concat(Ub))[0],
                            e = R.findOne(".".concat(Kb), e);
                        const i = R.findOne(".".concat(Kb), this.activeStep);
                        9 === t.keyCode && (this._toggleStepTabIndex(e, i), this._toggleOutlineStyles(!1, i), i.focus())
                    })
                })
            }
            _bindMobileButtons() {
                var t = R.findOne(".".concat(ly), this._element),
                    e = R.findOne(".".concat(ry), this._element);
                I.on(t, Fb, () => this.previousStep()), I.on(e, Fb, () => this.nextStep())
            }
            _unbindMobileButtons() {
                var t = R.findOne(".".concat(ly), this._element),
                    e = R.findOne(".".concat(ry), this._element);
                I.off(t, Fb, () => this.previousStep()), I.off(e, Fb, () => this.nextStep())
            }
            _toggleStepTabIndex(t, e) {
                t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0)
            }
            _validateActiveStepRequiredElements() {
                return R.find("[required]", this.activeStep).every(t => !0 === t.checkValidity())
            }
            _validateStep(t) {
                var e = this._steps.length;
                let i = !0;
                t === this._activeStepIndex && (i = !1), (e <= t || t < 0) && (i = !1);
                var n = I.trigger(this.activeStep, zb);
                if (this._options.stepperLinear) {
                    var s = t - this.activeStepIndex - 1;
                    if (t > this._activeStepIndex + 1) {
                        let e = R.next(this.activeStep, "li")[0];
                        for (let t = 0; t < s; t++) e.classList.contains("stepper-completed") || (e.classList.add("stepper-invalid"), i = !1), e = R.next(e, "li")[0]
                    }
                    t < this._activeStepIndex && (this._validateActiveStepRequiredElements() || this.activeStep.classList.remove("stepper-completed")), (t > this._activeStepIndex || t === e - 1) && (this.activeStep.classList.add("was-validated"), this._validateActiveStepRequiredElements() || (this._toggleInvalid(this._activeStepIndex), I.trigger(this.activeStep, Yb), this._currentView !== Db ? setTimeout(() => {
                        this._setHeight(this.activeStep)
                    }, 210) : setTimeout(() => {
                        this._setSingleStepHeight(this.activeStep)
                    }, 210), i = !1))
                }
                return t > this._activeStepIndex && n.defaultPrevented && (i = !1), this._options.stepperNoEditable && this._steps[t].classList.contains(Jb) && (i = !1), i
            }
            _updateProgressBar() {
                var t = this._steps.length;
                const e = R.findOne(".".concat(ay), this._element);
                e.style.width = "".concat((this._activeStepIndex + 1) / t * 100, "%")
            }
            _toggleOutlineStyles(t, e) {
                t && (t.style.outline = ""), e && (e.style.outline = "revert")
            }
            _toggleDisabled() {
                this._toggleStepClass(this._activeStepIndex, "add", Jb), this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperDisabled)
            }
            _toggleActive(t) {
                this._toggleStepClass(t, "add", qb), this._toggleStepClass(this._activeStepIndex, "remove", qb), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(this._activeStepIndex, "remove", this._options.stepperActive)
            }
            _toggleCompleted(t) {
                this._toggleStepClass(t, "add", Zb), this._toggleStepClass(t, "remove", Gb), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid)
            }
            _toggleInvalid(t) {
                this._toggleStepClass(t, "add", Gb), this._toggleStepClass(t, "remove", Zb), this._toggleStepClass(t, "add", this._options.stepperInvalid), this._toggleStepClass(t, "remove", this._options.stepperCompleted)
            }
            _setOptional() {
                this._steps.forEach(t => {
                    if (P.getDataAttribute(t, "stepper-optional")) {
                        const e = R.findOne(".".concat($b), t);
                        e.setAttribute("data-mdb-content", "Optional")
                    }
                })
            }
            _hideInactiveSteps() {
                this._steps.forEach(t => {
                    t.classList.contains(qb) || this._hideElement(R.findOne(".".concat(Qb), t))
                })
            }
            _setValidation() {
                const e = R.findOne(".needs-validation.stepper-form", this._element);
                I.on(e, Nb, t => {
                    e.checkValidity() || (t.preventDefault(), t.stopPropagation()), this._steps.forEach((t, e) => {
                        this._validateStep(e) || (this._toggleInvalid(e), I.trigger(this.activeStep, Yb))
                    })
                }, !1)
            }
            _setHeight(t) {
                var e = R.findOne(".".concat(Qb), t),
                    i = R.findOne(".".concat(oy), this._element),
                    n = getComputedStyle(e),
                    s = i ? getComputedStyle(i) : "";
                let o;
                o = this._currentView === Lb ? R.findOne(".".concat(sy), this._element) : R.findOne(".".concat(Kb), t);
                t = getComputedStyle(o), n = e.offsetHeight + parseFloat(n.marginTop) + parseFloat(n.marginBottom), t = o.offsetHeight + parseFloat(t.marginTop) + parseFloat(t.marginBottom), s = s ? i.offsetHeight + parseFloat(s.marginTop) + parseFloat(s.marginBottom) : 0;
                this._element.style.height = "".concat(t + n + s, "px")
            }
            _hideElement(t) {
                R.parents(t, ".".concat(Ub))[0].classList.contains(qb) || this._currentView === Db ? t.classList.add(ey) : t.style.display = "none"
            }
            _showElement(t) {
                this._currentView === Db ? t.classList.remove(ey) : t.style.display = "block"
            }
            _animateHorizontalStep(i) {
                if (!this._animations) return this._steps.forEach((t, e) => {
                    t = R.findOne(".".concat(Qb), t);
                    e !== i && this._hideElement(t)
                }), void this._setHeight(this._steps[i]);
                var t = i > this._activeStepIndex;
                const e = R.findOne(".".concat(Qb), this._steps[i]),
                    n = R.findOne(".".concat(Qb), this.activeStep);
                let s, o;
                this._steps.forEach((t, e) => {
                    t = R.findOne(".".concat(Qb), t);
                    this._clearStepAnimation(t), e !== i && e !== this._activeStepIndex && this._hideElement(t)
                }), s = t ? (o = "slide-out-left", "slide-in-right") : (o = "slide-out-right", "slide-in-left"), this._animations && (n.classList.add(o, "animation", "fast"), e.classList.add(s, "animation", "fast")), this._setHeight(this._steps[i]), I.one(n, Vb, t => {
                    this._clearStepAnimation(t.target), this._hideElement(t.target)
                }), I.one(e, Vb, t => {
                    this._clearStepAnimation(t.target)
                })
            }
            _animateVerticalStep(t) {
                var e = R.findOne(".".concat(Qb), this._steps[t]),
                    t = R.findOne(".".concat(Qb), this.activeStep);
                this._hideElement(t), this._showElement(e)
            }
            _clearStepAnimation(t) {
                t.classList.remove("slide-out-left", "slide-in-right", "slide-out-right", "slide-in-left", "animation", "fast")
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, Ob);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new py(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Ob)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find('[data-mdb-stepper="stepper"]').forEach(t => {
            let e = py.getInstance(t);
            return e = e || new py(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Mb];
                t.fn[Mb] = py.jQueryInterface, t.fn[Mb].Constructor = py, t.fn[Mb].noConflict = () => (t.fn[Mb] = e, py.jQueryInterface)
            }
        });
        var fy = py;
        const gy = "sticky",
            _y = "mdb.sticky";
        Ot = ".".concat("sticky");
        i = ".".concat(_y);
        const my = "active".concat(i),
            vy = "inactive".concat(i),
            by = {
                stickyActiveClass: "",
                stickyAnimationSticky: "",
                stickyAnimationUnsticky: "",
                stickyBoundary: !1,
                stickyDelay: 0,
                stickyDirection: "down",
                stickyMedia: 0,
                stickyOffset: 0,
                stickyPosition: "top"
            },
            yy = {
                stickyActiveClass: "string",
                stickyAnimationSticky: "string",
                stickyAnimationUnsticky: "string",
                stickyBoundary: "(boolean|string)",
                stickyDelay: "number",
                stickyDirection: "string",
                stickyMedia: "number",
                stickyOffset: "number",
                stickyPosition: "string"
            };
        class xy {
            constructor(t, e) {
                this._element = t, this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = "", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = "", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), p.setData(t, _y, this), this._init())
            }
            static get NAME() {
                return gy
            }
            dispose() {
                var t = this._options["stickyAnimationUnsticky"];
                let e = getComputedStyle(this._element)["animationDuration"];
                e = "" !== t ? 1e3 * parseFloat(e) : 0, this._disableSticky(), setTimeout(() => {
                    p.removeData(this._element, _y), this._element = null, this._options = null, this._hiddenElement = null, this._elementPositionStyles = null, this._scrollDirection = null, this._isSticked = null, this._elementOffsetTop = null, this._scrollTop = null, this._pushPoint = null, this._manuallyDeactivated = null
                }, e)
            }
            active() {
                this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1)
            }
            inactive() {
                this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0)
            }
            _init() {
                this._userActivityListener()
            }
            _userActivityListener() {
                I.on(window, "resize", () => {
                    this._updateElementPosition(), this._updateElementOffset()
                }), I.on(window, "scroll", () => {
                    var t, e, i, n;
                    this._element && (window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated || (e = document.documentElement, i = this._options["stickyDirection"], t = window.pageYOffset || e.scrollTop, this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(t), this._clearInProgressAnimations(), n = [this._scrollDirection, "both"].includes(i), i = (e = this._pushPoint <= t) && !this._isSticked && n, n = (!e || !n) && this._isSticked, i && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), n && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({
                        styles: this._elementPositionStyles
                    }), this._changeBoundaryPosition()), this._scrollTop = t <= 0 ? 0 : t))
                })
            }
            _updatePushPoint() {
                "top" === this._options.stickyPosition ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay
            }
            _updateElementOffset() {
                this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0)
            }
            _updateElementPosition() {
                var t;
                this._hiddenElement ? (t = this._hiddenElement.getBoundingClientRect()["left"], this._elementPositionStyles = {
                    left: "".concat(t, "px")
                }) : this._elementPositionStyles = {}, this._setStyle(this._element, this._elementPositionStyles)
            }
            _updateScrollDirection(t) {
                t > this._scrollTop ? this._scrollDirection = "down" : this._scrollDirection = "up"
            }
            _clearInProgressAnimations() {
                var t = "up" === this._scrollDirection,
                    e = this._element.classList.contains(this._options.stickyAnimationUnsticky),
                    i = window.scrollY <= this._elementOffsetTop - this._element.height;
                t && e && i && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement())
            }
            _enableSticky() {
                var {
                    stickyActiveClass: t,
                    stickyAnimationSticky: e,
                    stickyAnimationUnsticky: i,
                    stickyOffset: n,
                    stickyPosition: s
                } = this._options, {
                    height: o,
                    left: a,
                    width: r
                } = this._element.getBoundingClientRect();
                "" !== e && (P.addClass(this._element, "animation"), this._toggleClass(e, i, this._element)), this._toggleClass(t, "", this._element), this._setStyle(this._element, {
                    top: "top" === s && "".concat(0 + n, "px"),
                    bottom: "bottom" === s && "".concat(0 + n, "px"),
                    height: "".concat(o, "px"),
                    width: "".concat(r, "px"),
                    left: "".concat(a, "px"),
                    zIndex: "100",
                    position: "fixed"
                }), this._hiddenElement.hidden = !1, I.trigger(this._element, my)
            }
            _changeBoundaryPosition() {
                var {
                    stickyPosition: t,
                    stickyBoundary: e,
                    stickyOffset: i
                } = this._options, n = this._element.getBoundingClientRect()["height"], s = {
                    height: this._element.parentElement.getBoundingClientRect().height,
                    ...this._getOffset(this._element.parentElement)
                };
                let o;
                var a = R.findOne(e);
                o = a ? this._getOffset(a).top - n - i : s.height + s[t] - n - i;
                var r = "bottom" === t,
                    a = e,
                    e = o < 0,
                    n = o > s.height - n;
                let l;
                "top" === t && (l = e && a ? {
                    top: "".concat(i + o, "px")
                } : {
                    top: "".concat(i + 0, "px")
                }), r && (l = e && a ? {
                    bottom: "".concat(i + o, "px")
                } : n && a ? {
                    bottom: "".concat(i + s.bottom, "px")
                } : {
                    bottom: "".concat(i + 0, "px")
                }), this._setStyle(this._element, l)
            }
            _disableSticky() {
                const {
                    stickyActiveClass: t,
                    stickyAnimationUnsticky: e,
                    stickyAnimationSticky: i
                } = this._options;
                let n = getComputedStyle(this._element)["animationDuration"];
                n = "" !== e ? 1e3 * parseFloat(n) : 0, "" !== this._options.stickyAnimationUnsticky && (P.addClass(this._element, "animation"), this._toggleClass(e, i, this._element)), setTimeout(() => {
                    this._element.classList.contains(i) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass("", t, this._element), I.trigger(this._element, vy))
                }, n)
            }
            _createHiddenElement() {
                this._hiddenElement || (this._hiddenElement = this._copyElement(this._element))
            }
            _removeHiddenElement() {
                this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null)
            }
            _removeUnstickyAnimation() {
                this._toggleClass("", this._options.stickyAnimationUnsticky, this._element)
            }
            _resetStyles() {
                this._setStyle(this._element, {
                    top: null,
                    bottom: null,
                    position: null,
                    left: null,
                    zIndex: null,
                    width: null,
                    height: null
                })
            }
            _updatePosition({
                styles: t
            }) {
                this._setStyle(this._element, t)
            }
            _toggleClass(t, e, i) {
                t && P.addClass(i, t), e && P.removeClass(i, e)
            }
            _getOffset(t) {
                var e = P.offset(t),
                    t = t.getBoundingClientRect(),
                    t = 0 === e.left && 0 === e.top ? 0 : window.innerHeight - t.bottom;
                return { ...e,
                    bottom: t
                }
            }
            _copyElement(t) {
                var {
                    height: e,
                    width: i
                } = t.getBoundingClientRect();
                const n = t.cloneNode(!1);
                return n.hidden = !0, this._setStyle(n, {
                    height: "".concat(e, "px"),
                    width: "".concat(i, "px"),
                    opacity: "0"
                }), t.parentElement.insertBefore(n, t), n
            }
            _getConfig(t = {}) {
                var e = P.getDataAttributes(this._element);
                return t = { ...by,
                    ...e,
                    ...t
                }, a(gy, t, yy), t
            }
            _setStyle(e, i) {
                Object.keys(i).forEach(t => {
                    e.style[t] = i[t]
                })
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, _y);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new xy(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, _y)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(Ot).forEach(t => {
            let e = xy.getInstance(t);
            return e = e || new xy(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[gy];
                t.fn[gy] = xy.jQueryInterface, t.fn[gy].Constructor = xy, t.fn[gy].noConflict = () => (t.fn[gy] = e, xy.jQueryInterface)
            }
        });
        var wy = xy;
        i = class {
            _getCoordinates(t) {
                var [t] = t.touches;
                return {
                    x: t.clientX,
                    y: t.clientY
                }
            }
            _getDirection({
                x: t,
                y: e
            }) {
                return {
                    x: {
                        direction: t < 0 ? "left" : "right",
                        value: Math.abs(t)
                    },
                    y: {
                        direction: e < 0 ? "up" : "down",
                        value: Math.abs(e)
                    }
                }
            }
            _getOrigin({
                x: t,
                y: e
            }, {
                x: i,
                y: n
            }) {
                return {
                    x: t - i,
                    y: e - n
                }
            }
            _getDistanceBetweenTwoPoints(t, e, i, n) {
                return Math.hypot(e - t, n - i)
            }
            _getMidPoint({
                x1: t,
                x2: e,
                y1: i,
                y2: n
            }) {
                return {
                    x: (t + e) / 2,
                    y: (i + n) / 2
                }
            }
            _getVectorLength({
                x1: t,
                x2: e,
                y1: i,
                y2: n
            }) {
                return Math.sqrt((e - t) ** 2 + (n - i) ** 2)
            }
            _getRightMostTouch(t) {
                let e = null;
                const i = Number.MIN_VALUE;
                return t.forEach(t => {
                    t.clientX > i && (e = t)
                }), e
            }
            _getAngle(t, e, i, n) {
                return Math.atan2(n - e, i - t)
            }
            _getAngularDistance(t, e) {
                return e - t
            }
            _getCenterXY({
                x1: t,
                x2: e,
                y1: i,
                y2: n
            }) {
                return {
                    x: t + (e - t) / 2,
                    y: i + (n - i) / 2
                }
            }
            _getPinchTouchOrigin(t) {
                var [e, t] = t, t = {
                    x1: e.clientX,
                    x2: t.clientX,
                    y1: e.clientY,
                    y2: t.clientY
                };
                return [this._getVectorLength(t), this._getCenterXY(t)]
            }
            _getPosition({
                x1: t,
                x2: e,
                y1: i,
                y2: n
            }) {
                return {
                    x1: t,
                    x2: e,
                    y1: i,
                    y2: n
                }
            }
        };
        const Cy = {
            time: 250,
            pointers: 1
        };
        (class extends i {});
        var ky = class extends i {
            constructor(t, e = {}) {
                super(), this._element = t, this._options = { ...Cy,
                    ...e
                }, this._timer = null
            }
            static get NAME() {
                return "press"
            }
            handleTouchStart(t) {
                const {
                    time: e,
                    pointers: i
                } = this._options;
                t.touches.length === i && (this._timer = setTimeout(() => {
                    I.trigger(this._element, "press", {
                        time: e
                    }), I.trigger(this._element, "pressup", {
                        touch: t
                    })
                }, e))
            }
            handleTouchEnd() {
                clearTimeout(this._timer)
            }
        };
        const Ty = {
            threshold: 10,
            direction: "all"
        };
        var Sy = class {
            constructor(t, e) {
                this._element = t, this._startPosition = null, this._options = { ...Ty,
                    ...e
                }
            }
            handleTouchStart(t) {
                this._startPosition = this._getCoordinates(t)
            }
            handleTouchMove(t) {
                if (this._startPosition) {
                    t = this._getCoordinates(t), t = {
                        x: t.x - this._startPosition.x,
                        y: t.y - this._startPosition.y
                    }, t = this._getDirection(t);
                    if ("all" === this._options.direction) {
                        if (t.y.value < this._options.threshold && t.x.value < this._options.threshold) return;
                        var e = (t.y.value > t.x.value ? t.y : t.x).direction;
                        return I.trigger(this._element, "swipe".concat(e)), I.trigger(this._element, "swipe", {
                            direction: e
                        }), void(this._startPosition = null)
                    }
                    e = "left" === this._options.direction || "right" === this._options ? "x" : "y";
                    t[e].direction === this._options.direction && t[e].value > this._options.threshold && (I.trigger(this._element, "swipe".concat(t[e].direction)), this._startPosition = null)
                }
            }
            handleTouchEnd() {
                this._startPosition = null
            }
            _getCoordinates(t) {
                var [t] = t.touches;
                return {
                    x: t.clientX,
                    y: t.clientY
                }
            }
            _getDirection(t) {
                return {
                    x: {
                        direction: t.x < 0 ? "left" : "right",
                        value: Math.abs(t.x)
                    },
                    y: {
                        direction: t.y < 0 ? "up" : "down",
                        value: Math.abs(t.y)
                    }
                }
            }
        };
        const Ey = {
                threshold: 20,
                direction: "all",
                pointers: 1
            },
            Ay = "pan",
            My = "".concat(Ay, "start"),
            Oy = "".concat(Ay, "end"),
            Iy = "".concat(Ay, "move");
        (class extends i {});
        var Dy = class extends i {
            constructor(t, e = {}) {
                super(), this._element = t, this._options = { ...Ey,
                    ...e
                }, this._startTouch = null
            }
            static get NAME() {
                return Ay
            }
            handleTouchStart(t) {
                this._startTouch = this._getCoordinates(t), this._movedTouch = t, I.trigger(this._element, My, {
                    touch: t
                })
            }
            handleTouchMove(t) {
                "touchmove" === t.type && t.preventDefault();
                const {
                    threshold: e,
                    direction: i
                } = this._options;
                var n = this._getCoordinates(t),
                    s = this._getCoordinates(this._movedTouch),
                    o = this._getOrigin(n, this._startTouch),
                    a = this._getOrigin(n, s),
                    r = this._getDirection(o),
                    l = this._getDirection(a),
                    {
                        x: c,
                        y: o
                    } = r;
                if ("all" === i && (o.value > e || c.value > e)) {
                    const i = (o.value > c.value ? o : c).direction;
                    I.trigger(this._element, "".concat(Ay).concat(i)), I.trigger(this._element, Ay, a)
                }
                a = "left" === i || "right" === i ? "x" : "y";
                l[a].direction === i && r[a].value > e && I.trigger(this._element, "".concat(Ay).concat(i), {
                    [a]: n[a] - s[a]
                }), this._movedTouch = t, I.trigger(this._element, Iy, {
                    touch: t
                })
            }
            handleTouchEnd(t) {
                "touchend" === t.type && t.preventDefault(), this._movedTouch = null, this._startTouch = null, I.trigger(this._element, Oy, {
                    touch: t
                })
            }
        };
        const Ly = {
                pointers: 2,
                threshold: 10
            },
            Py = "pinch",
            Ry = "".concat(Py, "end"),
            By = "".concat(Py, "start"),
            Ny = "".concat(Py, "move");
        (class extends i {});
        var Hy = class extends i {
            constructor(t, e = {}) {
                super(), this._element = t, this._options = { ...Ly,
                    ...e
                }, this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null
            }
            static get NAME() {
                return Py
            }
            get isNumber() {
                return "number" == typeof this._startTouch && "number" == typeof this._touch && !isNaN(this._startTouch) && !isNaN(this._touch)
            }
            handleTouchStart(t) {
                var e;
                t.touches.length === this._options.pointers && ("touchstart" === t.type && t.preventDefault(), [e, t] = this._getPinchTouchOrigin(t.touches), this._touch = e, this._origin = t, this._startTouch = this._touch, I.trigger(this._element, By, {
                    ratio: this._ratio,
                    origin: this._origin
                }))
            }
            handleTouchMove(t) {
                var {
                    threshold: e,
                    pointers: i
                } = this._options;
                t.touches.length === i && ("touchmove" === t.type && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, I.trigger(this._element, Py, {
                    ratio: this._ratio,
                    origin: this._origin
                }), I.trigger(this._element, Ny, {
                    ratio: this._ratio,
                    origin: this._origin
                })))
            }
            handleTouchEnd() {
                this.isNumber && (this._startTouch = null, I.trigger(this._element, Ry, {
                    ratio: this._ratio,
                    origin: this._origin
                }))
            }
        };
        const jy = {
            interval: 500,
            time: 250,
            taps: 1,
            pointers: 1
        };
        (class extends i {});
        var Wy = class extends i {
            constructor(t, e) {
                super(), this._element = t, this._options = { ...jy,
                    ...e
                }, this._timer = null, this._tapCount = 0
            }
            static get NAME() {
                return "tap"
            }
            handleTouchStart(t) {
                var {
                    x: e,
                    y: i
                } = this._getCoordinates(t), {
                    interval: n,
                    taps: s,
                    pointers: o
                } = this._options;
                return t.touches.length === o && (this._tapCount += 1, 1 === this._tapCount && (this._timer = setTimeout(() => {
                    this._tapCount = 0
                }, n)), this._tapCount === s && (clearTimeout(this._timer), this._tapCount = 0, I.trigger(this._element, "tap", {
                    origin: {
                        x: e,
                        y: i
                    }
                }))), t
            }
            handleTouchEnd() {}
            handleTouchMove() {}
        };
        const Fy = {
                angle: 0,
                pointers: 2
            },
            Vy = "rotate",
            zy = "".concat(Vy, "end"),
            Yy = "".concat(Vy, "start");
        (class extends i {});
        var Xy = class extends i {
            constructor(t, e) {
                super(), this._element = t, this._options = { ...Fy,
                    ...e
                }, this._origin = {}
            }
            static get NAME() {
                return Vy
            }
            handleTouchStart(t) {
                "touchstart" === t.type && t.preventDefault(), t.touches.length < 2 || (this._startTouch = t, this._origin = {}, I.trigger(this._element, Yy, {
                    touch: t
                }))
            }
            handleTouchMove(t) {
                "touchmove" === t.type && t.preventDefault();
                let e, i;
                var n = t.touches;
                if (1 === n.length && 1 === this._options.pointers) {
                    var {
                        left: s,
                        top: o,
                        width: a,
                        height: r
                    } = this._element.getBoundingClientRect();
                    e = {
                        x: s + a / 2,
                        y: o + r / 2
                    }, i = n[0]
                } else {
                    if (2 !== t.touches.length || 2 !== this._options.pointers) return;
                    var [r, n] = t.touches, r = {
                        x1: n.clientX,
                        x2: r.clientX,
                        y1: n.clientY,
                        y2: r.clientY
                    };
                    e = this._getMidPoint(r), i = this._getRightMostTouch(t.touches)
                }
                this.currentAngle = this._getAngle(e.x, e.y, i.clientX, i.clientY), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(this._origin.previousAngle, this.currentAngle), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {
                    currentAngle: this.currentAngle,
                    distance: this._origin.distance,
                    change: this._origin.change
                }, I.trigger(this._element, Vy, this.rotate)
            }
            handleTouchEnd(t) {
                "touchend" === t.type && t.preventDefault(), this._origin = {}, I.trigger(this._element, zy, {
                    touch: t
                })
            }
        };
        const Uy = "touch",
            Ky = "mdb.touch";
        class $y {
            constructor(t, e = "swipe", i = {}) {
                this._element = t, this._event = e, this.swipe = "swipe" === e ? new Sy(t, i) : null, this.press = "press" === e ? new ky(t, i) : null, this.pan = "pan" === e ? new Dy(t, i) : null, this.pinch = "pinch" === e ? new Hy(t, i) : null, this.tap = "tap" === e ? new Wy(t, i) : null, this.rotate = "rotate" === e ? new Xy(t, i) : null, this._touchStartHandler = t => this._handleTouchStart(t), this._touchMoveHandler = t => this._handleTouchMove(t), this._touchEndHandler = t => this._handleTouchEnd(t), this._element && p.setData(t, Ky, this)
            }
            dispose() {
                I.off(this._element, "touchstart", this._touchStartHandler), I.off(this._element, "touchmove", this._touchMoveHandler), I.off(this._element, "touchend", this._touchEndHandler), this.swipe = null, this.press = null, this.pan = null, this.pinch = null, this.tap = null, this.rotate = null
            }
            init() {
                I.on(this._element, "touchstart", this._touchStartHandler), I.on(this._element, "touchmove", this._touchMoveHandler), I.on(this._element, "touchend", this._touchEndHandler)
            }
            _handleTouchStart(t) {
                this[this._event].handleTouchStart(t)
            }
            _handleTouchMove(t) {
                this[this._event].handleTouchMove(t)
            }
            _handleTouchEnd(t) {
                this[this._event].handleTouchEnd(t)
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, Ky);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new $y(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        return t[i]
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Ky)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Uy];
                t.fn[Uy] = $y.jQueryInterface, t.fn[Uy].Constructor = $y, t.fn[Uy].noConflict = () => (t.fn[Uy] = e, $y.jQueryInterface)
            }
        });
        var Qy = $y;
        const qy = "smoothScroll",
            Zy = "mdb.".concat(qy);
        Ot = ".".concat(Zy);
        const Gy = {
                container: "string",
                offset: "number",
                easing: "string",
                duration: "number"
            },
            Jy = {
                container: "body",
                offset: 0,
                easing: "linear",
                duration: 500
            },
            t0 = "scrollStart".concat(Ot),
            e0 = "scrollEnd".concat(Ot),
            i0 = "scrollCancel".concat(Ot);
        class n0 {
            constructor(t, e = {}) {
                this._element = t, this._options = this._getConfig(e), this._href = this._element.getAttribute("href"), this.isCancel = !1, this._element && (p.setData(t, Zy, this), this._setup())
            }
            static get NAME() {
                return qy
            }
            get isWindow() {
                return "body" === this._options.container
            }
            get containerToScroll() {
                return this.isWindow ? document.documentElement : R.findOne(this._options.container, document.documentElement)
            }
            get elFromHrefExist() {
                return !!R.findOne(this._href, this.containerToScroll)
            }
            get offsetFromEl() {
                var t = this.containerToScroll.scrollTop;
                const e = R.findOne(this._href, this.containerToScroll);
                return this.isWindow ? P.offset(e).top - this._options.offset + t : e.getBoundingClientRect().y - this.containerToScroll.getBoundingClientRect().y - this._options.offset + t
            }
            get easingFunction() {
                const t = this._options.easing;
                var e = "_motion".concat(t[0].toUpperCase()).concat(t.slice(1));
                return this[e] || this._motionLinear
            }
            dispose() {
                I.off(this._element, "click", this._handleClick), p.removeData(this._element, Zy), this._element = null
            }
            cancelScroll() {
                this.isCancel = !0
            }
            _getConfig(t) {
                t = { ...Jy,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(qy, t, Gy), t
            }
            _inViewport() {
                if (this.isWindow) return !0;
                var t = this.containerToScroll.getBoundingClientRect();
                return 0 <= t.top && t.bottom <= (window.innerHeight || document.documentElement.clientHeight)
            }
            _setup() {
                var t = void 0 !== this._href,
                    e = this._href.includes("#");
                t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll())
            }
            _scrollOnClickEvent() {
                I.on(this._element, "click", t => {
                    this._handleClick(t)
                })
            }
            _handleClick(t) {
                t.preventDefault(), this.isCancel = !1, I.trigger(this._element, t0);
                const e = this.containerToScroll,
                    i = this.containerToScroll.scrollTop,
                    n = this.offsetFromEl,
                    s = 1 / this._options.duration,
                    o = this.easingFunction;
                this._inViewport() ? this._scrollOnNextTick(e, i, n, 0, s, 4.25, o) : (this._scrollOnNextTick(document.documentElement, document.documentElement.scrollTop, this.containerToScroll.offsetTop, 0, s, 4.25, o), setTimeout(() => {
                    this._scrollOnNextTick(e, i, n, 0, s, 4.25, o), this.isCancel = !1
                }, this._options.duration))
            }
            _scrollOnNextTick(t, e, i, n, s, o, a) {
                if (n < 0 || 1 < n || s <= 0 || this.isCancel) return this.isCancel ? (this.isInViewport && (this.isCancel = !1), void I.trigger(this._element, i0)) : (I.trigger(this._element, e0), void(t.scrollTop = i));
                t.scrollTo({
                    top: e - (e - i) * a(n)
                }), n += s * o, setTimeout(() => {
                    this._scrollOnNextTick(t, e, i, n, s, o, a)
                })
            }
            _preventDefault(t) {
                t.preventDefault()
            }
            _preventNativeScroll() {
                let t = !1;
                try {
                    window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                        get: () => t = !0
                    }))
                } catch (t) {
                    this._scrollError = t
                }
                var e = !!t && {
                        passive: !1
                    },
                    i = "onwheel" in y("div") ? "wheel" : "mousewheel";
                this.isWindow && (this._deleteScrollOnStart(e, i), this._addScrollOnEnd(e, i), this._addScrollOnCancel(e, i))
            }
            _deleteScrollOnStart(t, e) {
                I.on(this._element, "scrollStart.mdb.smoothScroll", () => {
                    window.addEventListener(e, this._preventDefault, t), window.addEventListener("touchmove", this._preventDefault, t)
                })
            }
            _addScrollOnEnd(t, e) {
                I.on(this._element, "scrollEnd.mdb.smoothScroll", () => {
                    window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t)
                })
            }
            _addScrollOnCancel(t, e) {
                I.on(this._element, "scrollCancel.mdb.smoothScroll", () => {
                    window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t)
                })
            }
            _motionLinear(t) {
                return t
            }
            _motionEaseInQuad(t) {
                return t * t
            }
            _motionEaseInCubic(t) {
                return t * t * t
            }
            _motionEaseInQuart(t) {
                return t * t * t * t
            }
            _motionEaseInQuint(t) {
                return t * t * t * t * t
            }
            _motionEaseInOutQuad(t) {
                return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
            }
            _motionEaseInOutCubic(t) {
                return (t /= .5) < 1 ? t * t * t / 2 : ((t -= 2) * t * t + 2) / 2
            }
            _motionEaseInOutQuart(t) {
                return (t /= .5) < 1 ? .5 * t * t * t * t : -((t -= 2) * t * t * t - 2) / 2
            }
            _motionEaseInOutQuint(t) {
                return (t /= .5) < 1 ? t * t * t * t * t / 2 : ((t -= 2) * t * t * t * t + 2) / 2
            }
            _motionEaseOutQuad(t) {
                return -t * (t - 2)
            }
            _motionEaseOutCubic(t) {
                return --t * t * t + 1
            }
            _motionEaseOutQuart(t) {
                return -(--t * t * t * t - 1)
            }
            _motionEaseOutQuint(t) {
                return --t * t * t * t * t + 1
            }
            static getInstance(t) {
                return p.getData(t, Zy)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, Zy);
                    var e = "object" == typeof i && i;
                    if (t = t || new n0(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](this)
                    }
                })
            }
        }
        R.find('a[data-mdb-smooth-scroll="smooth-scroll"]').forEach(t => {
            let e = n0.getInstance(t);
            return e = e || new n0(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[qy];
                t.fn[qy] = n0.jQueryInterface, t.fn[qy].Constructor = n0, t.fn[qy].noConflict = () => (t.fn[qy] = e, n0.jQueryInterface)
            }
        });
        var s0 = n0;
        const o0 = "perfectScrollbar",
            a0 = "mdb.perfectScrollbar";
        i = "mdb", Ot = "ps";
        const r0 = [{
                mdb: "scrollX.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-x"
            }, {
                mdb: "scrollY.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-y"
            }, {
                mdb: "scrollUp.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-up"
            }, {
                mdb: "scrollDown.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-down"
            }, {
                mdb: "scrollLeft.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-left"
            }, {
                mdb: "scrollRight.".concat(i, ".").concat(Ot),
                ps: "ps-scroll-right"
            }, {
                mdb: "scrollXEnd.".concat(i, ".").concat(Ot),
                ps: "ps-x-reach-end"
            }, {
                mdb: "scrollYEnd.".concat(i, ".").concat(Ot),
                ps: "ps-y-reach-end"
            }, {
                mdb: "scrollXStart.".concat(i, ".").concat(Ot),
                ps: "ps-x-reach-start"
            }, {
                mdb: "scrollYStart.".concat(i, ".").concat(Ot),
                ps: "ps-y-reach-start"
            }],
            l0 = {
                handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
                wheelSpeed: 1,
                wheelPropagation: !0,
                swipeEasing: !0,
                minScrollbarLength: null,
                maxScrollbarLength: null,
                scrollingThreshold: 1e3,
                useBothWheelAxes: !1,
                suppressScrollX: !1,
                suppressScrollY: !1,
                scrollXMarginOffset: 0,
                scrollYMarginOffset: 0
            },
            c0 = {
                handlers: "(string|array)",
                wheelSpeed: "number",
                wheelPropagation: "boolean",
                swipeEasing: "boolean",
                minScrollbarLength: "(number|null)",
                maxScrollbarLength: "(number|null)",
                scrollingThreshold: "number",
                useBothWheelAxes: "boolean",
                suppressScrollX: "boolean",
                suppressScrollY: "boolean",
                scrollXMarginOffset: "number",
                scrollYMarginOffset: "number"
            };
        class h0 {
            constructor(t, e = {}) {
                this._element = t, this._options = this._getConfig(e), this.perfectScrollbar = null, this._element && (p.setData(t, a0, this), P.addClass(this._element, "perfect-scrollbar")), this.init()
            }
            static get NAME() {
                return o0
            }
            _getConfig(t) {
                const e = P.getDataAttributes(this._element);
                return void 0 !== e.handlers && (e.handlers = e.handlers.split(" ")), t = { ...l0,
                    ...e,
                    ...t
                }, a(o0, t, c0), t
            }
            dispose() {
                p.removeData(this._element, a0), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(r0), this.perfectScrollbar = null
            }
            init() {
                this.perfectScrollbar = new hg(this._element, this._options), this._initEvents(r0)
            }
            update() {
                return this.perfectScrollbar.update()
            }
            _initEvents(t = []) {
                t.forEach(({
                    ps: t,
                    mdb: e
                }) => I.on(this._element, t, t => I.trigger(this._element, e, {
                    e: t
                })))
            }
            removeEvent(e) {
                let t = [];
                "string" == typeof e && (t = r0.filter(({
                    mdb: t
                }) => t === e)), t.forEach(({
                    ps: t,
                    mdb: e
                }) => {
                    I.off(this._element, t), I.off(this._element, e)
                })
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, a0);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new h0(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i]()
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, a0)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find('[data-mdb-perfect-scrollbar="true"]').forEach(t => {
            let e = h0.getInstance(t);
            return e = e || new h0(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[o0];
                t.fn[o0] = h0.jQueryInterface, t.fn[o0].Constructor = h0, t.fn[o0].noConflict = () => (t.fn[o0] = e, h0.jQueryInterface)
            }
        });
        var d0 = h0;
        const u0 = "loading",
            p0 = "mdb.loading";
        const f0 = {
                backdrop: "(null|boolean)",
                backdropColor: "string",
                backdropOpacity: "(number|string)",
                delay: "(null|number)",
                loader: "string",
                loadingIcon: "boolean",
                loadingText: "boolean",
                scroll: "boolean"
            },
            g0 = {
                backdrop: !0,
                backdropColor: "rgba(0, 0, 0)",
                backdropOpacity: .4,
                backdropID: "",
                delay: null,
                loader: "",
                parentSelector: null,
                scroll: !0,
                loadingText: !0,
                loadingIcon: !0
            };
        class _0 {
            constructor(t, e = {}) {
                this._element = t, this._options = this._getConfig(e), this._element && p.setData(t, p0, this), this._backdropElement = null, this._parentElement = R.findOne(this._options.parentSelector), this._loadingIcon = R.findOne(".loading-icon", this._element), this._loadingText = R.findOne(".loading-text", this._element), this.init()
            }
            static get NAME() {
                return u0
            }
            toggle() {
                P.hasClass(this._element, "show") || this.init()
            }
            init() {
                const t = this._loadingIcon.cloneNode(!0),
                    e = this._loadingText.cloneNode(!0);
                this._removeElementsOnStart(), setTimeout(() => {
                    P.addClass(this._element, "loading-spinner"), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), I.trigger(this._element, "show.mdb.loading")
                }, this._options.delay)
            }
            dispose() {
                p.removeData(this._element, p0), this._backdropElement = null, this._element = null, this._options = null
            }
            _setBackdrop() {
                var t = this._options["backdrop"];
                t && (this._backdropElement = function({
                    backdropID: t,
                    backdropOpacity: e,
                    backdropColor: i
                }) {
                    const n = y("div");
                    return P.addClass(n, "loading-backdrop"), n.id = t, P.addStyle(n, {
                        opacity: e,
                        backgroundColor: i
                    }), n
                }(this._options), null !== this._parentElement ? (P.addClass(this._element, "position-absolute"), P.addClass(this._parentElement, "position-relative"), P.addClass(this._backdropElement, "position-absolute"), this._parentElement.appendChild(this._backdropElement)) : (P.addClass(this._element, "position-fixed"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)))
            }
            _setLoadingIcon(t) {
                this._options.loadingIcon ? (this._element.appendChild(t), t.id = this._options.loader) : t.remove()
            }
            _setLoadingText(t) {
                this._options.loadingText ? this._element.appendChild(t) : t.remove()
            }
            _removeElementsOnStart() {
                null !== this._element && (this._loadingIcon.remove(), this._loadingText.remove())
            }
            _setScrollOption() {
                this._options.scroll ? null !== this._parentElement ? P.addStyle(this._parentElement, {
                    overflow: ""
                }) : document.body.style.overflow = "" : null !== this._parentElement ? P.addStyle(this._parentElement, {
                    overflow: "hidden"
                }) : document.body.style.overflow = "hidden"
            }
            _getConfig(t) {
                t = { ...g0,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(u0, t, f0), t
            }
            static getInstance(t) {
                return p.getData(t, p0)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, p0);
                    var e = "object" == typeof i && i;
                    if (t = t || new _0(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](this)
                    }
                })
            }
        }
        R.find(".loading").forEach(t => {
            let e = _0.getInstance(t);
            return e = e || new _0(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[u0];
                t.fn[u0] = _0.jQueryInterface, t.fn[u0].Constructor = _0, t.fn[u0].noConflict = () => (t.fn[u0] = e, _0.jQueryInterface)
            }
        });
        var m0 = _0;
        const v0 = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
        const b0 = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
            y0 = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
            x0 = (t, e) => {
                var i = t.nodeName.toLowerCase();
                if (e.includes(i)) return !v0.has(i) || Boolean(t.nodeValue.match(b0) || t.nodeValue.match(y0));
                const n = e.filter(t => t instanceof RegExp);
                for (let t = 0, e = n.length; t < e; t++)
                    if (n[t].test(i)) return !0;
                return !1
            },
            w0 = {
                "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            };

        function C0(t, i, e) {
            if (!t.length) return t;
            if (e && "function" == typeof e) return e(t);
            const n = new window.DOMParser,
                s = n.parseFromString(t, "text/html"),
                o = Object.keys(i);
            var a = [].concat(...s.body.querySelectorAll("*"));
            for (let t = 0, e = a.length; t < e; t++) {
                const l = a[t];
                var r = l.nodeName.toLowerCase();
                if (-1 !== o.indexOf(r)) {
                    const c = [].concat(...l.attributes),
                        h = [].concat(i["*"] || [], i[r] || []);
                    c.forEach(t => {
                        x0(t, h) || l.removeAttribute(t.nodeName)
                    })
                } else l.parentNode.removeChild(l)
            }
            return s.body.innerHTML
        }
        const k0 = "autocomplete-item";

        function T0(t = [], e) {
            const i = e.displayValue,
                n = e.itemContent;
            return "\n    ".concat(t.map((t, e) => {
                t = "function" == typeof n ? C0(n(t), w0, null) : i(t);
                return '<li data-mdb-index="'.concat(e, '" role="option" class="').concat(k0, '">').concat(t, "</li>")
            }).join(""), "\n  ")
        }
        const S0 = {
                autoSelect: !1,
                container: "body",
                customContent: "",
                debounce: 300,
                displayValue: t => t,
                filter: null,
                itemContent: null,
                listHeight: 190,
                noResults: "No results found",
                threshold: 0
            },
            E0 = {
                autoSelect: "boolean",
                container: "string",
                customContent: "string",
                debounce: "number",
                displayValue: "function",
                filter: "(null|function)",
                itemContent: "(null|function)",
                listHeight: "number",
                noResults: "string",
                threshold: "number"
            },
            A0 = "autocomplete",
            M0 = "mdb.autocomplete",
            O0 = "active",
            I0 = ".autocomplete-items-list",
            D0 = ".autocomplete-item";
        Ot = ".".concat(M0);
        const L0 = "close".concat(Ot),
            P0 = "open".concat(Ot),
            R0 = "itemSelect".concat(Ot),
            B0 = "update".concat(Ot);
        class N0 {
            constructor(t, e) {
                this._element = t, this._options = this._getConfig(e), this._getContainer(), this._input = R.findOne(".form-control", t), this._label = R.findOne(".form-label", t), this._customContent = R.findOne(".autocomplete-custom-content", t), this._loader = function() {
                    const t = y("div");
                    return P.addClass(t, "autocomplete-loader"), P.addClass(t, "spinner-border"), t.setAttribute("role", "status"), t.innerHTML = '<span class="sr-only">Loading...</span>', t
                }(), this._popper = null, this._debounceTimeoutId = null, this._loaderTimeout = null, this._activeItemIndex = -1, this._activeItem = null, this._filteredResults = null, this._lastQueryValue = null, this._canOpenOnFocus = !0, this._isOpen = !1, this._outsideClickHandler = this._handleOutsideClick.bind(this), this._inputFocusHandler = this._handleInputFocus.bind(this), this._userInputHandler = this._handleUserInput.bind(this), this._keydownHandler = this._handleKeydown.bind(this), t && p.setData(t, M0, this), this._init()
            }
            static get NAME() {
                return A0
            }
            get filter() {
                return this._options.filter
            }
            get dropdown() {
                return R.findOne(".autocomplete-dropdown", this._dropdownContainer)
            }
            get items() {
                return R.find(D0, this._dropdownContainer)
            }
            get itemsList() {
                return R.findOne(I0, this._dropdownContainer)
            }
            initSearch(t) {
                this._filterResults(t)
            }
            _getContainer() {
                this._container = R.findOne(this._options.container)
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...S0,
                    ...e,
                    ...t
                }, a(A0, t, E0), t
            }
            _init() {
                this._initDropdown(), this._setInputAndLabelClasses(), this._updateLabelPosition(), this._setInputAriaAttributes(), this._listenToInputFocus(), this._listenToUserInput(), this._listenToKeydown()
            }
            _initDropdown() {
                this._dropdownContainerId = d("autocomplete-dropdown-");
                var t = {
                    id: this._dropdownContainerId,
                    items: [],
                    width: this._input.offsetWidth,
                    options: this._options
                };
                this._dropdownContainer = function(t) {
                    var {
                        id: e,
                        items: i,
                        width: n,
                        options: t
                    } = t;
                    const s = y("div");
                    P.addClass(s, "autocomplete-dropdown-container"), P.addStyle(s, {
                        width: "".concat(n, "px")
                    }), s.setAttribute("id", e);
                    const o = y("div");
                    P.addClass(o, "autocomplete-dropdown");
                    const a = y("ul");
                    return e = t.listHeight, P.addClass(a, "autocomplete-items-list"), P.addStyle(a, {
                        maxHeight: "".concat(e, "px")
                    }), a.setAttribute("role", "listbox"), t = T0(i, t), a.innerHTML = t, o.appendChild(a), s.appendChild(o), s
                }(t), "" !== this._options.customContent && (t = C0(this._options.customContent, w0, null), this.dropdown.insertAdjacentHTML("beforeend", t))
            }
            _setInputAndLabelClasses() {
                P.addClass(this._input, "autocomplete-input"), this._label && P.addClass(this._label, "autocomplete-label")
            }
            _setInputAriaAttributes() {
                this._input.setAttribute("role", "combobox"), this._input.setAttribute("aria-expanded", !1), this._input.setAttribute("aria-owns", this._dropdownContainerId), this._input.setAttribute("aria-haspopup", !0), this._input.setAttribute("autocomplete", "off")
            }
            _updateLabelPosition() {
                this._label && ("" !== this._input.value || this._isOpen ? P.addClass(this._label, O0) : P.removeClass(this._label, O0))
            }
            _listenToInputFocus() {
                I.on(this._input, "focus", this._inputFocusHandler)
            }
            _handleInputFocus(t) {
                var e = t.target["value"],
                    t = this._options.threshold;
                this._canOpenOnFocus ? e.length < t || (this._lastQueryValue !== e ? this._filterResults(e) : this.open()) : this._canOpenOnFocus = !0
            }
            _listenToWindowResize() {
                I.on(window, "resize", this._handleWindowResize.bind(this))
            }
            _handleWindowResize() {
                this._dropdownContainer && this._updateDropdownWidth()
            }
            _updateDropdownWidth() {
                var t = this._input.offsetWidth;
                P.addStyle(this._dropdownContainer, {
                    width: "".concat(t, "px")
                })
            }
            _listenToUserInput() {
                I.on(this._input, "input", this._userInputHandler)
            }
            _handleUserInput(t) {
                var e = t.target["value"],
                    i = this._options.threshold,
                    t = this._options.debounce;
                this.filter && (e.length < i ? this._isOpen && this.close() : this._debounceFilter(e, t))
            }
            _debounceFilter(t, e) {
                this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
                    this._filterResults(t)
                }, e)
            }
            _filterResults(t) {
                this._lastQueryValue = t;
                t = this.filter(t);
                this._isPromise(t) ? this._asyncUpdateResults(t) : this._updateResults(t)
            }
            _isPromise(t) {
                return !!t && "function" == typeof t.then
            }
            _asyncUpdateResults(t) {
                this._resetActiveItem(), this._showLoader(), t.then(t => {
                    this._updateResults(t), this._loaderTimeout = setTimeout(() => {
                        this._hideLoader(), this._loaderTimeout = null
                    }, 300)
                })
            }
            _resetActiveItem() {
                var t = this._activeItem;
                t && (P.removeClass(t, "active"), this._activeItem = null, this._activeItemIndex = -1)
            }
            _showLoader() {
                this._element.appendChild(this._loader)
            }
            _hideLoader() {
                R.findOne(".autocomplete-loader", this._element) && this._element.removeChild(this._loader)
            }
            _updateResults(t) {
                this._resetActiveItem(), this._filteredResults = t, I.trigger(this._element, B0, {
                    results: t
                });
                const e = R.findOne(".autocomplete-items-list", this._dropdownContainer);
                var i, n = T0(t, this._options),
                    i = (i = this._options.noResults, '<li class="'.concat("autocomplete-item autocomplete-no-results", '">').concat(i, "</li>"));
                0 === t.length && "" !== this._options.noResults ? e.innerHTML = i : e.innerHTML = n, this._isOpen || this.open(), this._popper.forceUpdate()
            }
            _listenToKeydown() {
                I.on(this._element, "keydown", this._keydownHandler)
            }
            _handleKeydown(t) {
                this._isOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)
            }
            _handleOpenKeydown(t) {
                var e, i = t.keyCode;
                if (9 === i && this._options.autoSelect && this._selectActiveItem(), 27 === i || 38 === i && t.altKey) return this._input.value || P.addClass(this._input, "focusing"), this.close(), this._input.focus(), void(this._input.value || setTimeout(() => {
                    P.removeClass(this._input, "focusing")
                }, 10));
                if (27 === i || 38 === i && t.altKey || 9 === i) return this.close(), void this._input.focus();
                switch (i) {
                    case 40:
                        this._setActiveItem(this._activeItemIndex + 1), this._scrollToItem(this._activeItem);
                        break;
                    case 38:
                        this._setActiveItem(this._activeItemIndex - 1), this._scrollToItem(this._activeItem);
                        break;
                    case 36:
                        this._setActiveItem(0), this._scrollToItem(this._activeItem);
                        break;
                    case 35:
                        this._setActiveItem(this.items.length - 1), this._scrollToItem(this._activeItem);
                        break;
                    case 13:
                        return t.preventDefault(), void(-1 < this._activeItemIndex && (e = this._filteredResults[this._activeItemIndex], this._handleSelection(e)));
                    default:
                        return
                }
                t.preventDefault()
            }
            _setActiveItem(t) {
                var e = this.items;
                e[t] && this._updateActiveItem(e[t], t)
            }
            _updateActiveItem(t, e) {
                var i = this._activeItem;
                i && P.removeClass(i, "active"), P.addClass(t, "active"), this._activeItemIndex = e, this._activeItem = t
            }
            _scrollToItem(t) {
                if (t) {
                    const s = this.itemsList;
                    var e = s.offsetHeight,
                        i = this.items.indexOf(t),
                        n = t.offsetHeight,
                        t = s.scrollTop; - 1 < i && (i = i * n, s.scrollTop = i < t ? i : t + e < i + n ? i - e + n : t)
                }
            }
            _handleClosedKeydown(t) {
                "Enter" === t.key && t.preventDefault();
                t = t.keyCode;
                13 !== t && 40 !== t && 40 !== t || this.open()
            }
            open() {
                var t = I.trigger(this._element, P0);
                this._isOpen || t.defaultPrevented || (this._updateDropdownWidth(), this._listenToWindowResize(), this._popper = Qn(this._element, this._dropdownContainer, {
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: [0, 1]
                        }
                    }]
                }), this._container.appendChild(this._dropdownContainer), this._listenToOutsideClick(), this._listenToItemsClick(), setTimeout(() => {
                    P.addClass(this.dropdown, "open"), this._isOpen = !0, this._setInputActiveStyles(), this._updateLabelPosition()
                }, 0))
            }
            _listenToOutsideClick() {
                I.on(document, "click", this._outsideClickHandler)
            }
            _handleOutsideClick(t) {
                var e = this._input === t.target,
                    i = t.target === this._dropdownContainer,
                    t = this._dropdownContainer && this._dropdownContainer.contains(t.target);
                e || i || t || this.close()
            }
            _listenToItemsClick() {
                var t = R.findOne(I0, this._dropdownContainer);
                I.on(t, "click", this._handleItemsClick.bind(this))
            }
            _handleItemsClick(t) {
                t = R.closest(t.target, D0), t = P.getDataAttribute(t, "index"), t = this._filteredResults[t];
                this._handleSelection(t)
            }
            _selectActiveItem() {
                var t = this._filteredResults[this._activeItemIndex];
                if (t) {
                    const e = this._options.displayValue(t);
                    I.trigger(this._element, R0, {
                        value: t
                    }).defaultPrevented || setTimeout(() => {
                        this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateLabelPosition()
                    }, 0)
                }
            }
            _handleSelection(t) {
                const e = this._options.displayValue(t);
                var i = I.trigger(this._element, R0, {
                    value: t
                });
                void 0 !== t && (i.defaultPrevented || setTimeout(() => {
                    this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateLabelPosition(), this._input.focus(), this.close()
                }, 0))
            }
            _updateInputValue(t) {
                this._input.value = t
            }
            _setInputActiveStyles() {
                P.addClass(this._input, "focused")
            }
            close() {
                var t = I.trigger(this._element, L0);
                this._isOpen && !t.defaultPrevented && (this._resetActiveItem(), this._removeDropdownEvents(), P.removeClass(this.dropdown, "open"), I.on(this.dropdown, "transitionend", this._handleDropdownTransitionEnd.bind(this)), P.removeClass(this._input, "focused"), P.removeClass(this._input, O0), this._input.value || P.removeClass(this._label, O0))
            }
            _removeDropdownEvents() {
                var t = R.findOne(I0, this._dropdownContainer);
                I.off(t, "click"), I.off(document, "click", this._outsideClickHandler), I.off(window, "resize", this._handleWindowResize.bind(this))
            }
            _handleDropdownTransitionEnd(t) {
                this._isOpen && t && "opacity" === t.propertyName && (this._popper.destroy(), this._dropdownContainer && this._container.removeChild(this._dropdownContainer), this._isOpen = !1, I.off(this.dropdown, "transitionend"))
            }
            dispose() {
                this._isOpen && this.close(), this._removeInputAndElementEvents(), p.removeData(this._element, M0)
            }
            _removeInputAndElementEvents() {
                I.off(this._input, "focus", this._inputFocusHandler), I.off(this._input, "input", this._userInputHandler), I.off(this._element, "keydown", this._keydownHandler)
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, M0);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new N0(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, M0)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        var H0 = N0;
        c(() => {
            const t = l();
            if (t) {
                const e = t.fn[A0];
                t.fn[A0] = N0.jQueryInterface, t.fn[A0].Constructor = N0, t.fn[A0].noConflict = () => (t.fn[A0] = e, N0.jQueryInterface)
            }
        });
        const j0 = ".".concat("bs.modal");
        const W0 = "hide".concat(j0),
            F0 = "hidePrevented".concat(j0),
            V0 = "hidden".concat(j0),
            z0 = "show".concat(j0),
            Y0 = "shown".concat(j0),
            X0 = "resize".concat(j0),
            U0 = "click.dismiss".concat(j0),
            K0 = "mousedown.dismiss".concat(j0),
            $0 = "keydown.dismiss".concat(j0);
        Ot = "click".concat(j0).concat(".data-api");
        const Q0 = "modal-open",
            q0 = "modal-static";
        const Z0 = {
                backdrop: !0,
                focus: !0,
                keyboard: !0
            },
            G0 = {
                backdrop: "(boolean|string)",
                focus: "boolean",
                keyboard: "boolean"
            };
        class J0 extends Et {
            constructor(t, e) {
                super(t, e), this._dialog = Kt.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new pe, this._addEventListeners()
            }
            static get Default() {
                return Z0
            }
            static get DefaultType() {
                return G0
            }
            static get NAME() {
                return "modal"
            }
            toggle(t) {
                return this._isShown ? this.hide() : this.show(t)
            }
            show(t) {
                this._isShown || this._isTransitioning || vt.trigger(this._element, z0, {
                    relatedTarget: t
                }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Q0), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)))
            }
            hide() {
                this._isShown && !this._isTransitioning && (vt.trigger(this._element, W0).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove("show"), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())))
            }
            dispose() {
                for (const t of [window, this._dialog]) vt.off(t, j0);
                this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
            }
            handleUpdate() {
                this._adjustDialog()
            }
            _initializeBackDrop() {
                return new ve({
                    isVisible: Boolean(this._config.backdrop) && Boolean(!this._config.modalNonInvasive),
                    isAnimated: this._isAnimated()
                })
            }
            _initializeFocusTrap() {
                return new Te({
                    trapElement: this._element
                })
            }
            _showElement(t) {
                document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
                const e = Kt.findOne(".modal-body", this._dialog);
                e && (e.scrollTop = 0), $(this._element), this._element.classList.add("show");
                this._queueCallback(() => {
                    this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, vt.trigger(this._element, Y0, {
                        relatedTarget: t
                    })
                }, this._dialog, this._isAnimated())
            }
            _addEventListeners() {
                vt.on(this._element, $0, t => {
                    if ("Escape" === t.key) return this._config.keyboard ? (t.preventDefault(), void this.hide()) : void this._triggerBackdropTransition()
                }), vt.on(window, X0, () => {
                    this._isShown && !this._isTransitioning && this._adjustDialog()
                }), vt.on(this._element, K0, e => {
                    vt.one(this._element, U0, t => {
                        this._element === e.target && this._element === t.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                    })
                })
            }
            _hideModal() {
                this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
                    document.body.classList.remove(Q0), this._resetAdjustments(), this._scrollBar.reset(), vt.trigger(this._element, V0)
                })
            }
            _isAnimated() {
                return this._element.classList.contains("fade")
            }
            _triggerBackdropTransition() {
                if (!vt.trigger(this._element, F0).defaultPrevented) {
                    var t = this._element.scrollHeight > document.documentElement.clientHeight;
                    const e = this._element.style.overflowY;
                    "hidden" === e || this._element.classList.contains(q0) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(q0), this._queueCallback(() => {
                        this._element.classList.remove(q0), this._queueCallback(() => {
                            this._element.style.overflowY = e
                        }, this._dialog)
                    }, this._dialog), this._element.focus())
                }
            }
            _adjustDialog() {
                var t, e = this._element.scrollHeight > document.documentElement.clientHeight,
                    i = this._scrollBar.getWidth(),
                    n = 0 < i;
                n && !e && (t = Z() ? "paddingLeft" : "paddingRight", this._element.style[t] = "".concat(i, "px")), !n && e && (e = Z() ? "paddingRight" : "paddingLeft", this._element.style[e] = "".concat(i, "px"))
            }
            _resetAdjustments() {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
            }
            static jQueryInterface(e, i) {
                return this.each(function() {
                    const t = J0.getOrCreateInstance(this, e);
                    if ("string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "'.concat(e, '"'));
                        t[e](i)
                    }
                })
            }
        }
        vt.on(document, Ot, '[data-mdb-toggle="modal"]', function(t) {
            const e = W(this);
            ["A", "AREA"].includes(this.tagName) && t.preventDefault(), vt.one(e, z0, t => {
                t.defaultPrevented || vt.one(e, V0, () => {
                    Y(this) && this.focus()
                })
            });
            const i = Kt.find(".modal.show");
            i.forEach(t => {
                t.classList.contains("modal-non-invasive-show") || J0.getInstance(t).hide()
            });
            const n = J0.getOrCreateInstance(e);
            n.toggle(this)
        }), Se(J0), G(J0);
        Ot = J0;
        const tx = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
            ex = ".sticky-top";
        const ix = (t, i) => {
            R.find(t).forEach(t => {
                var e = P.getDataAttribute(t, i);
                void 0 === e ? t.style.removeProperty(i) : (P.removeDataAttribute(t, i), t.style[i] = e)
            })
        };
        const nx = "modal",
            sx = "bs.modal";
        Se = ".".concat(sx);
        const ox = "modal-non-invasive-open",
            ax = "modal-non-invasive-show";
        const rx = ".".concat("modal-content"),
            lx = ".".concat("modal-bottom"),
            cx = ".".concat("modal-bottom-right"),
            hx = ".".concat("modal-bottom-left"),
            dx = ".".concat("modal-top-right"),
            ux = ".".concat("modal-top-left"),
            px = ".".concat("modal-dialog-scrollable"),
            fx = ".".concat("modal-dialog");
        G = "mousedown".concat(Se).concat(".data-api");
        const gx = "show".concat(Se),
            _x = "shown".concat(Se),
            mx = "hidden".concat(Se),
            vx = "hide.bs.modal",
            bx = "hidePrevented.bs.modal",
            yx = {
                backdrop: !0,
                keyboard: !0,
                focus: !0,
                show: !0,
                modalNonInvasive: !1
            },
            xx = {
                backdrop: "(boolean|string)",
                keyboard: "boolean",
                focus: "boolean",
                show: "boolean",
                modalNonInvasive: "boolean"
            };
        class wx extends Ot {
            constructor(t, e) {
                super(t, e), this._config = this._getConfig(e), this._modalContentRect = "", this._modalContentComputedStyles = "", this._isNonInvasive = this._config.modalNonInvasive, this._isScrollable = "", this._isBottomRight = "", this._isBottomLeft = "", this._isTopRight = "", this._isTopLeft = "", this._isSideTopModal = "", this._isSideBottomModal = "", this._isSideModal = "", this._isModalBottom = "", this._isNonInvasive && (this._config.backdrop = !1, this._config.focus = !1, this._isBodyOverflowing = !0, this._onModalShow(), this._onModalShown(), this._onModalHidden(), this._listenToWindowResize()), p.setData(t, sx, this), this._bindEvents()
            }
            static get NAME() {
                return nx
            }
            dispose() {
                I.off(this._element, gx), I.off(this._element, _x), I.off(this._element, vx), I.off(this._element, mx), I.off(this._element, bx), this._modalContentRect = null, this._modalContentComputedStyles = null, this._isNonInvasive = null, this._isScrollable = null, this._isBottomRight = null, this._isBottomLeft = null, this._isTopRight = null, this._isTopLeft = null, this._isSideTopModal = null, this._isSideBottomModal = null, this._isSideModal = null, this._isModalBottom = null, super.dispose()
            }
            _onModalShow() {
                I.on(this._element, gx, () => {
                    this._addNonInvasiveClass()
                })
            }
            _onModalShown() {
                I.on(this._element, _x, () => {
                    const t = R.findOne(rx, this._element);
                    this._isScrollable = R.findOne(px, this._element), this._isBottomRight = R.findOne(cx, this._element), this._isBottomLeft = R.findOne(hx, this._element), this._isTopRight = R.findOne(dx, this._element), this._isTopLeft = R.findOne(ux, this._element), this._isSideTopModal = this._isTopLeft || this._isTopRight, this._isSideBottomModal = this._isBottomLeft || this._isBottomRight, this._isSideModal = this._isSideTopModal || this._isSideBottomModal, this._isModalBottom = R.findOne(lx, this._element), this._modalContentRect = t.getBoundingClientRect(), this._modalContentComputedStyles = window.getComputedStyle(t), this._modalDialogComputedStyles = window.getComputedStyle(R.findOne(fx, this._element)), this._topOffset = parseInt(this._modalDialogComputedStyles.top, 0), this._leftOffset = parseInt(this._modalDialogComputedStyles.left, 0), this._rightOffset = parseInt(this._modalDialogComputedStyles.right, 0), this._bottomOffset = parseInt(this._modalDialogComputedStyles.bottom, 0), this._addOpenClass(), this._setStyles()
                })
            }
            _listenToWindowResize() {
                I.on(window, "resize", this._handleWindowResize.bind(this))
            }
            _handleWindowResize() {
                const t = R.findOne(rx, this._element);
                if (this._resetStyles(), this._modalContentRect = t.getBoundingClientRect(), this._modalContentComputedStyles = window.getComputedStyle(t), this._isSideTopModal || this._isSideBottomModal) {
                    let t = 0,
                        e = 0;
                    (this._isBottomRight || this._isBottomLeft) && (e = -this._bottomOffset), (this._isBottomRight || this._isTopRight) && (t = -this._rightOffset), (this._isBottomLeft || this._isTopLeft) && (t = this._leftOffset), this._setStyles(t, e)
                }
            }
            _showBackdrop(t) {
                this._isNonInvasive ? "function" == typeof t && t() : super._showBackdrop(t)
            }
            _adjustDialog() {
                super._adjustDialog();
                var t = document.body.classList.contains(ox);
                (this._isNonInvasive || t) && (this._isBodyOverflowing = !1), this._isNonInvasive && (this._resetAdjustments(), ix("body", "overflow"), ix("body", "paddingRight"), ix(tx, "paddingRight"), ix(ex, "marginRight"))
            }
            _onModalHidden() {
                I.on(this._element, mx, t => {
                    t.stopImmediatePropagation(), this._removeOpenClass(), this._resetStyles(), this._removeNonInvasiveClass()
                })
            }
            _addOpenClass() {
                this._element.classList.add(ax)
            }
            _removeOpenClass() {
                this._element.classList.remove(ax)
            }
            _addNonInvasiveClass() {
                document.body.classList.add(ox)
            }
            _removeNonInvasiveClass() {
                R.findOne(".".concat("modal", ".").concat("show", ".").concat(ax), document.body) ? document.body.classList.add("modal-open") : document.body.classList.remove(ox)
            }
            _setStyles(t = 0, e = 0) {
                var i = 992 <= window.innerWidth;
                this._element.style.left = "".concat(this._modalContentRect.left + t, "px"), this._element.style.width = this._modalContentComputedStyles.width, this._isScrollable || (this._element.style.height = this._modalContentComputedStyles.height, this._element.style.display = ""), i && ((this._isSideBottomModal || this._isModalBottom) && (this._element.style.top = "".concat(this._modalContentRect.top + e, "px")), this._isSideModal && (this._element.style.overflowX = "auto"))
            }
            _resetStyles() {
                this._element.style.left = "", this._element.style.top = "", this._element.style.height = "", this._element.style.width = "", this._isScrollable || (this._element.style.display = ""), this._isSideModal && (this._element.style.overflowX = "")
            }
            _getConfig(t) {
                let e;
                this._element && (e = o(this._element));
                t = { ...yx,
                    ...P.getDataAttributes(this._element),
                    ...P.getDataAttributes(e),
                    ...t
                };
                return a(nx, t, xx), t
            }
            _bindEvents() {
                this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent(), this._bindHidePreventedEvent()
            }
            _bindShowEvent() {
                I.on(this._element, gx, t => {
                    I.trigger(this._element, "show.mdb.modal", {
                        relatedTarget: t.relatedTarget
                    })
                })
            }
            _bindShownEvent() {
                I.on(this._element, _x, t => {
                    I.trigger(this._element, "shown.mdb.modal", {
                        relatedTarget: t.relatedTarget
                    })
                })
            }
            _bindHideEvent() {
                I.on(this._element, vx, () => {
                    I.trigger(this._element, "hide.mdb.modal")
                })
            }
            _bindHiddenEvent() {
                I.on(this._element, mx, () => {
                    I.trigger(this._element, "hidden.mdb.modal")
                })
            }
            _bindHidePreventedEvent() {
                I.on(this._element, bx, () => {
                    I.trigger(this._element, "hidePrevented.mdb.modal")
                })
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, sx);
                    var e = { ...yx,
                        ...P.getDataAttributes(this),
                        ..."object" == typeof i && i ? i : {}
                    };
                    if (t = t || new wx(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    } else e.show && t.show(n)
                })
            }
        }
        I.on(document, G, '[data-mdb-toggle="modal"]', function(t) {
            var e = o(t.target),
                t = p.getData(e, sx);
            t || (t = { ...P.getDataAttributes(e),
                ...P.getDataAttributes(this._element)
            }, new wx(e, t))
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[nx];
                t.fn[nx] = wx.jQueryInterface, t.fn[nx].Constructor = wx, t.fn[nx].noConflict = () => (t.fn[nx] = e, wx.jQueryInterface)
            }
        });
        var Cx = wx;
        const kx = "clipboard",
            Tx = "mdb.clipboard";
        Se = ".".concat(Tx);
        const Sx = {
                clipboardTarget: null
            },
            Ex = {
                clipboardTarget: "null|string"
            },
            Ax = "copy".concat(Se);
        class Mx {
            constructor(t, e = {}) {
                this._element = t, this._options = e, this._element && (p.setData(t, Tx, this), this._initCopy = this._initCopy.bind(this), this._setup())
            }
            static get NAME() {
                return kx
            }
            get options() {
                var t = { ...Sx,
                    ...P.getDataAttributes(this._element),
                    ...this._options
                };
                return a(kx, t, Ex), t
            }
            get clipboardTarget() {
                return R.findOne(this.options.clipboardTarget)
            }
            get copyText() {
                var t = this.clipboardTarget.hasAttribute("data-mdb-clipboard-text"),
                    e = this.clipboardTarget.value,
                    i = this.clipboardTarget.textContent;
                return t ? this.clipboardTarget.getAttribute("data-mdb-clipboard-text") : e || i
            }
            dispose() {
                I.off(this._element, "click", this._initCopy), p.removeData(this._element, Tx), this._element = null
            }
            _setup() {
                I.on(this._element, "click", this._initCopy)
            }
            _initCopy() {
                const t = this._createNewInput();
                document.body.appendChild(t), this._selectInput(t), I.trigger(this._element, Ax, {
                    copyText: this.copyText
                }), t.remove()
            }
            _createNewInput() {
                const t = y("input");
                return t.value = this.copyText, P.style(t, {
                    left: "-9999px",
                    position: "absolute"
                }), t
            }
            _selectInput(t) {
                t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand("copy")
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, Tx);
                    var e = "object" == typeof i && i;
                    if (t = t || new Mx(this, e), "string" == typeof i) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](this)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Tx)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".clipboard").forEach(t => {
            let e = Mx.getInstance(t);
            return e = e || new Mx(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[kx];
                t.fn[kx] = Mx.jQueryInterface, t.fn[kx].Constructor = Mx, t.fn[kx].noConflict = () => (t.fn[kx] = e, Mx.jQueryInterface)
            }
        });
        var Ox = Mx;
        const Ix = "chip",
            Dx = "mdb.".concat(Ix),
            Lx = ".close",
            Px = {
                text: "string",
                closeIcon: "boolean",
                img: "object"
            },
            Rx = {
                text: "",
                closeIcon: !1,
                img: {
                    path: "",
                    alt: ""
                }
            };
        class Bx {
            constructor(t, e = {}) {
                this._element = t, this._options = this._getConfig(e)
            }
            static get NAME() {
                return Ix
            }
            init() {
                this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip()
            }
            dispose() {
                this._element = null, this._options = null, I.off(this._element, "click")
            }
            appendChip() {
                var {
                    text: t,
                    closeIcon: e
                } = this._options;
                return e = [{
                    text: t
                }["text"]][0], '<div class="chip btn"><span class="text-chip">'.concat(e, '</span> <i class="close fas fa-times"></i></div>')
            }
            _appendCloseIcon(t = this._element) {
                if (!(0 < R.find(Lx, this._element).length) && this._options.closeIcon) {
                    const e = y("i");
                    e.classList = "close fas fa-times", t.insertAdjacentElement("beforeend", e)
                }
            }
            _handleClickOnChip() {
                I.on(this._element, "click", t => {
                    const e = t.target["textContent"],
                        i = {};
                    i.tag = e.trim(), I.trigger("select.mdb.chip", {
                        event: t,
                        obj: i
                    })
                })
            }
            _handleDelete() {
                0 !== R.find(Lx, this._element).length && I.on(this._element, "click", Lx, () => {
                    I.trigger(this._element, "delete.mdb.chips"), this._element.remove()
                })
            }
            _handleTextChip() {
                "" === this._element.innerText && (this._element.innerText = this._options.text)
            }
            _getConfig(t) {
                t = { ...Rx,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(Ix, t, Px), t
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, Dx);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new Bx(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i]()
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, Dx)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".".concat(Ix)).forEach(t => {
            let e = Bx.getInstance(t);
            return e = e || new Bx(t), e.init()
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn.chip;
                t.fn.chip = Bx.jQueryInterface, t.fn.chip.Constructor = Bx, t.fn.chip.noConflict = () => (t.fn.chip = e, Bx.jQueryInterface)
            }
        });
        var Nx = Bx;
        const Hx = "chips",
            jx = "mdb.".concat(Hx),
            Wx = "active",
            Fx = "".concat(Hx, "-initial"),
            Vx = "".concat(Hx, "-placeholder"),
            zx = "chip-opacity",
            Yx = "".concat(Hx, "-padding"),
            Xx = "".concat(Hx, "-transition"),
            Ux = "".concat(Hx, "-input-wrapper"),
            Kx = "".concat(".chip", ".").concat(Wx),
            $x = "delete.mdb.chips",
            Qx = "select.mdb.chips",
            qx = {
                inputID: "string",
                parentSelector: "string",
                initialValues: "array",
                editable: "boolean",
                labelText: "string"
            },
            Zx = {
                inputID: "",
                parentSelector: "",
                initialValues: [{
                    tag: "init1"
                }, {
                    tag: "init2"
                }],
                editable: !1,
                labelText: "Example label"
            };
        class Gx extends Nx {
            constructor(t, e = {}) {
                var i, n, s;
                super(t, e), s = ({
                    target: t
                }) => {
                    0 < t.value.length && this._handleCreateChip(t, t.value), 0 < this.allChips.length ? (P.addClass(t, Wx), P.addClass(this.chipsInputWrapper, Yx)) : (P.removeClass(t, Wx), P.removeClass(this.chipsInputWrapper, Yx)), this.allChips.forEach(t => P.removeClass(t, Wx))
                }, (n = "_handleBlurInput") in (i = this) ? Object.defineProperty(i, n, {
                    value: s,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : i[n] = s, this._options = this._getConfig(e), this._element = t, this.numberClicks = 0, this.init()
            }
            static get NAME() {
                return Hx
            }
            get activeChip() {
                return R.findOne(Kx, this._element)
            }
            get input() {
                return R.findOne("input", this._element)
            }
            get allChips() {
                return R.find(".chip", this._element)
            }
            get chipsInputWrapper() {
                return R.findOne(".".concat(Ux), this._element)
            }
            init() {
                this._setChipsClass(), this._appendInputToElement(Vx), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips()
            }
            dispose() {
                this._element = null, this._options = null
            }
            _setChipsClass() {
                P.addClass(this._element, "chips")
            }
            _handleDeleteEvents(t) {
                const [e] = this.allChips.slice(-1);
                if (null === this.activeChip) e.remove(), this._handleEvents(t, $x);
                else {
                    var i = this.allChips.findIndex(t => t === this.activeChip),
                        n = this._handleActiveChipAfterRemove(i);
                    const s = [];
                    null !== this.activeChip && (this.activeChip.remove(), this._handleEvents(t, $x), this.numberClicks = i, P.addClass(n, Wx), this.allChips.forEach(t => {
                        P.hasClass(t, Wx) && (s.push(t), 1 < s.length && this.allChips.forEach(t => t.remove()))
                    }))
                }
            }
            _handleUpEvents(t) {
                this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(t, "arrowRight.mdb.chips"), this._handleEvents(t, "arrowUp.mdb.chips")
            }
            _handleDownEvents(t) {
                --this.numberClicks, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(t, "arrowLeft.mdb.chips"), this._handleEvents(t, "arrowDown.mdb.chips")
            }
            _keyboardEvents(t) {
                var {
                    target: e,
                    keyCode: i,
                    ctrlKey: n
                } = t;
                0 < e.value.length || 0 === this.allChips.length || (8 === i || 46 === i ? this._handleDeleteEvents(t) : 39 === i || 38 === i ? this._handleUpEvents(t) : 37 === i || 40 === i ? this._handleDownEvents(t) : 65 === i && n && this._handleAddActiveClass())
            }
            _handleKeyboard() {
                I.on(this.input, "keydown", t => this._keyboardEvents(t))
            }
            _handleEditable() {
                var t = this._options["editable"];
                t && this.allChips.forEach(s => {
                    I.on(s, "dblclick", t => {
                        const e = R.findOne(".close", s);
                        s.contentEditable = !0, s.focus(), setTimeout(() => {
                            P.addStyle(e, {
                                display: "none"
                            })
                        }, 200), P.addClass(e, "close-opacity");
                        t.target.textContent, I.trigger(s, Qx, {
                            event: t,
                            allChips: this.allChips
                        })
                    }), I.on(document, "click", ({
                        target: t
                    }) => {
                        const e = R.findOne(".close", s);
                        var i = R.findOne(".text-chip", s),
                            n = t === s,
                            t = s && s.contains(t);
                        n || t || (s.contentEditable = !1, "" !== i.textContent && setTimeout(() => {
                            P.addStyle(e, {
                                display: "block"
                            }), P.removeClass(e, "close-opacity")
                        }, 160)), "" === i.textContent && (setTimeout(() => {
                            P.addClass(s, zx)
                        }, 200), setTimeout(() => {
                            s.remove()
                        }, 300))
                    })
                })
            }
            _handleRemoveActiveClass() {
                this.allChips.forEach(t => P.removeClass(t, Wx))
            }
            _handleAddActiveClass() {
                this.allChips.forEach(t => P.addClass(t, Wx))
            }
            _handleRightKeyboardArrow(t) {
                this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(t = 0 === t ? 1 : t)
            }
            _handleLeftKeyboardArrow(t) {
                this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(t)
            }
            _handleActiveChipAfterRemove(t) {
                return this.allChips[0 === t ? 1 : t - 1]
            }
            _handleClicksOnChips() {
                I.on(this._element, "click", () => {
                    0 === this.allChips.length && (P.removeClass(this.chipsInputWrapper, Yx), P.removeClass(this.input, Wx))
                })
            }
            _handleTextContent() {
                const e = [];
                return this.allChips.forEach(t => e.push({
                    tag: t.textContent.trim()
                })), e
            }
            _handleEvents(t, e) {
                var i = this._handleTextContent();
                const n = this.allChips.filter(t => P.hasClass(t, Wx) && t);
                I.trigger(this._element, e, {
                    event: t,
                    allChips: this.allChips,
                    arrOfObjects: i,
                    active: n,
                    activeObj: {
                        tag: n.length <= 0 ? "" : n[0].textContent.trim()
                    }
                })
            }
            _handleChipsFocus() {
                I.on(this._element, "click", ({
                    target: {
                        classList: t
                    }
                }) => {
                    t.contains("chip") || t.contains("close") || t.contains("text-chip") || this.input.focus()
                })
            }
            _handleInitialValue() {
                if (this._appendInputToElement(Fx), P.hasClass(this._element, Fx)) {
                    const t = this._options["initialValues"];
                    t.forEach(({
                        tag: t
                    }) => this._handleCreateChip(this.input, t)), P.addClass(this.input, Wx)
                }
                0 < this.allChips.length && (P.addClass(this.chipsInputWrapper, Yx), P.addClass(this.chipsInputWrapper, Xx))
            }
            _handleKeysInputToElement(t) {
                const {
                    keyCode: e,
                    target: i
                } = t;
                if (P.hasClass(i, "chip")) {
                    const n = R.findOne(".close", i);
                    13 === e && (i.contentEditable = !1, "" !== i.textContent ? setTimeout(() => {
                        P.addStyle(n, {
                            display: "block"
                        }), P.removeClass(n, "close-opacity")
                    }, 160) : "" === i.textContent && (setTimeout(() => {
                        P.addClass(i, zx)
                    }, 200), setTimeout(() => {
                        i.remove()
                    }, 300)))
                } else {
                    if (13 === e) {
                        if ("" === i.value) return;
                        this._handleCreateChip(i, i.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(t, "add.mdb.chips")
                    }
                    0 < this.allChips.length ? (P.addClass(this.chipsInputWrapper, Yx), P.addClass(this.chipsInputWrapper, Xx)) : P.removeClass(this.chipsInputWrapper, Yx)
                }
            }
            _handleInputText() {
                var t = R.findOne(Vx, this._element);
                I.on(this._element, "keyup", t, t => this._handleKeysInputToElement(t)), I.on(this.input, "blur", t => this._handleBlurInput(t))
            }
            _appendInputToElement(t) {
                var e;
                P.hasClass(this._element, t) && ([{
                    inputID: e,
                    labelText: t
                }] = [this._options], t = '<div class="form-outline chips-input-wrapper">\n      <input type="text" id="'.concat(e, '" class="form-control chips-input" />\n      <label class="form-label" for="').concat(e, '">\n        ').concat(t, '\n      </label>\n\n      <div class="form-notch">\n        <div class="form-notch-leading" style="width: 9px;"></div>\n        <div class="form-notch-middle" style="width: 87.2px;"></div>\n        <div class="form-notch-trailing"></div>\n      </div>\n    </div>'), this._element.insertAdjacentHTML("beforeend", t))
            }
            _handleCreateChip(t, e) {
                var i = y("div"),
                    i = Nx.getInstance(i);
                const n = new Nx(i, {
                    text: e
                });
                if ("" !== this._options.parentSelector) {
                    const s = document.querySelector(this._options.parentSelector);
                    s.insertAdjacentHTML("beforeend", n.appendChip())
                } else t.insertAdjacentHTML("beforebegin", n.appendChip());
                t.value = "", R.find(".chip").forEach(t => {
                    let e = Nx.getInstance(t);
                    return e = e || new Nx(t), e.init()
                }), this._handleEditable()
            }
            _handleChipsOnSelect() {
                this.allChips.forEach(e => {
                    I.on(this._element, "click", t => {
                        I.trigger(e, Qx, {
                            event: t,
                            allChips: this.allChips
                        })
                    })
                })
            }
            _handleAddActiveClassWithKebyboard(t) {
                let e;
                e = void 0 === this.allChips[t - 1] ? this.allChips[t - 2] : this.allChips[t - 1], P.addClass(e, Wx)
            }
            _getConfig(t) {
                t = { ...Zx,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(Hx, t, qx), t
            }
            static jQueryInterface(i) {
                return this.each(function() {
                    let t = p.getData(this, jx);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new Gx(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i]()
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, jx)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".".concat(Hx)).forEach(t => {
            let e = Gx.getInstance(t);
            return e = e || new Gx(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[Hx];
                t.fn[Hx] = Gx.jQueryInterface, t.fn[Hx].Constructor = Gx, t.fn[Hx].noConflict = () => (t.fn[Hx] = e, Gx.jQueryInterface)
            }
        });
        var Jx = Gx;
        const tw = t => {
                return ("touchmove" === t.type ? t.touches[0] : t).clientX
            },
            ew = "multiRangeSlider";
        const iw = "mdb.multiRangeSlider",
            nw = "value.mdb.multiRangeSlider",
            sw = ".multi-range-slider-hand",
            ow = "active",
            aw = {
                direction: "string",
                margin: "(string||number||null)",
                max: "number",
                min: "number",
                numberOfRanges: "number",
                orientation: "string",
                padding: "(string||number||null)",
                startValues: "array",
                step: "(string||null||number)",
                tooltips: "boolean"
            },
            rw = {
                direction: "",
                margin: null,
                max: 100,
                min: 0,
                numberOfRanges: 2,
                orientation: "horizontal",
                padding: null,
                startValues: [0, 100],
                step: null,
                tooltips: !1
            };
        class lw {
            constructor(t, e = {}) {
                this._element = t, this._options = this._getConfig(e), this._mousemove = !1, this.init()
            }
            static get NAME() {
                return ew
            }
            get hands() {
                return R.find(sw, this._element)
            }
            get connect() {
                return R.findOne(".multi-range-slider-connect", this._element)
            }
            get leftConnectRect() {
                return this.connect.getBoundingClientRect().left
            }
            get handsNoActive() {
                return this.hands.filter(t => !P.hasClass(t, "active"))
            }
            get handActive() {
                return R.findOne("".concat(sw, ".active"))
            }
            get activeTooltip() {
                return R.findOne(".multi-range-slider-tooltip")
            }
            get activeTooltipValue() {
                return R.findOne("".concat(sw, ".active")).children[1].children[0]
            }
            init() {
                this._setClassHorizontalOrVertical(), this._setRangeConnectsElement(), this._setRangeHandleElements(), this._setTransofrmationOnStart(), this._handleClickEventOnHand(), this._handleEndMoveEventDocument(), this._handleClickOnRange(), this._setValueEventOnMouseDown(), this._setPercentEventOnMouseDown(), this._setTooltipToHand()
            }
            dispose() {
                p.removeData(this._element, iw), this._element = null, this._input = null, this._options = null, this._view = null, this._focusTrap = null
            }
            _setTransofrmationOnStart() {
                const {
                    startValues: i,
                    max: n,
                    min: s
                } = this._options;
                0 === i.length ? this.hands.forEach(t => {
                    var e = -t.offsetWidth;
                    P.setDataAttribute(t, "translation", Math.round(e)), P.addStyle(t, {
                        transform: "translate(".concat(e, "px,-25%)")
                    })
                }) : this.hands.forEach((t, e) => {
                    i[e] > n || i[e] < s || (e = i[e] * this.connect.offsetWidth / n - t.offsetWidth / 2, P.setDataAttribute(t, "translation", Math.round(e)), P.addStyle(t, {
                        transform: "translate(".concat(e, "px,-25%)")
                    }))
                })
            }
            _handleClickEventOnHand() {
                const {
                    max: o,
                    min: a
                } = this._options;
                this.hands.forEach((n, s) => {
                    O.on(n, "mousedown touchstart", t => {
                        this._mousemove = !0;
                        var e = tw(t) - this.leftConnectRect - n.offsetWidth / 2,
                            i = (tw(t) - this.leftConnectRect) / (this.connect.offsetWidth / (o - a)) % (o - a);
                        P.addStyle(n, {
                            transform: "translate(".concat(e, "px,-25%)")
                        }), P.setDataAttribute(n, "translation", e), P.addClass(n, ow), this._options.tooltip && (P.addClass(n.children[1], "active"), this.activeTooltipValue.innerText = Math.round(i)), this._handleMoveEvent(n, s), this._handleEndMoveEvent(n, t)
                    })
                })
            }
            _setPercentEventOnMouseDown() {
                O.on(this.connect, "mousedown touchstart", t => {
                    var e = (tw(t) - this.leftConnectRect) / t.target.offsetWidth,
                        t = "".concat(Math.round(100 * e), "%");
                    I.trigger(this._element, "showPercent.mdb.multiRangeSlider", {
                        percents: {
                            value: e,
                            percent: t
                        }
                    })
                })
            }
            _setValueEventOnMouseDown() {
                O.on(this.connect, "mousedown touchstart", t => {
                    var {
                        max: e,
                        min: i,
                        numberOfRanges: n
                    } = this._options;
                    n < 2 && (e = Math.round((tw(t) - this.leftConnectRect) / (t.target.offsetWidth / (e - i))) % (e - i), I.trigger(this._element, "start.mdb.multiRangeSlider", {
                        values: {
                            value: e + i,
                            rounded: Math.round(e + i)
                        }
                    }))
                })
            }
            _setClassHorizontalOrVertical() {
                P.addClass(this._element, "multi-range-slider"), "horizontal" === this._options.orientation ? P.addClass(this._element, "multi-range-slider-horizontal") : P.addClass(this._element, "multi-range-slider-vertical")
            }
            _setRangeConnectsElement() {
                this._element.insertAdjacentHTML("afterbegin", '<div class="multi-range-slider-connects">\n<div class="multi-range-slider-connect"></div>\n</div>')
            }
            _setRangeHandleElements() {
                for (let t = 0; t < this._options.numberOfRanges; t++) this._element.insertAdjacentHTML("beforeend", '<div class="multi-range-slider-hand">\n  <div class="multi-range-slider-handle"></div>\n</div>');
                this.hands.forEach((t, e) => {
                    t.setAttribute("aria-orientation", this._options.orientation), t.setAttribute("role", "slider"), P.setDataAttribute(t, "handle", e)
                })
            }
            _setTooltipToHand() {
                this._options.tooltips && this.hands.forEach(t => t.insertAdjacentHTML("beforeend", '\n  <span class="multi-range-slider-tooltip">\n    <span class="multi-range-slider-tooltip-value">'.concat(void 0, "</span>\n  </span>\n  ")))
            }
            _handleMoveEvent(l) {
                const {
                    tooltip: c,
                    step: h
                } = this._options;
                O.on(document, "mousemove touchmove", i => {
                    "mousemove" === i.type && i.preventDefault();
                    var {
                        max: n,
                        min: s,
                        numberOfRanges: o
                    } = this._options;
                    if (P.hasClass(l, ow)) {
                        var a = (tw(i) - this.leftConnectRect) / this.connect.offsetWidth * n;
                        let t = (tw(i) - this.leftConnectRect) / (this.connect.offsetWidth / (n - s)) % (n - s) + s,
                            e = tw(i) - this.leftConnectRect - l.offsetWidth / 2;
                        var r = P.getDataAttribute(this.handActive, "handle"),
                            i = P.getDataAttribute(this.handActive, "translation");
                        if (t < s) e = s - l.offsetWidth, t = s;
                        else if (n <= a) return;
                        n = this.handsNoActive.map(t => P.getDataAttribute(t, "handle")), a = this.handsNoActive.map(t => P.getDataAttribute(t, "translation"));
                        r < n && i <= a ? (Math.round(t) % h == 0 && null !== h || null === h) && (P.addStyle(l, {
                            transform: "translate(".concat(e, "px,-25%)")
                        }), c && (this.activeTooltipValue.innerText = Math.round(t))) : n < r && a <= i && (Math.round(t) % h == 0 && null !== h || null === h) && (P.addStyle(l, {
                            transform: "translate(".concat(e, "px,-25%)")
                        }), c && (this.activeTooltipValue.innerText = Math.round(t))), o < 2 && (Math.round(t) % h == 0 && null !== h || null === h) && (P.addStyle(l, {
                            transform: "translate(".concat(e, "px,-25%)")
                        }), c && (this.activeTooltipValue.innerText = Math.round(t))), P.setDataAttribute(l, "translation", e), o < 2 ? I.trigger(this._element, nw, {
                            values: {
                                value: t + s,
                                rounded: Math.round(t + s)
                            }
                        }) : this._handleMultiValuesOnRange()
                    }
                })
            }
            _handleMultiValuesOnRange() {
                const {
                    max: n,
                    min: s
                } = this._options, o = [];
                this.hands.forEach(t => {
                    var e = t.getBoundingClientRect().left - this.leftConnectRect + t.offsetWidth / 2;
                    let i = e / (this.connect.offsetWidth / (n - s)) % (n - s);
                    e === this.connect.offsetWidth ? i = n : i += s, P.setDataAttribute(t, "value", Math.round(10 * i) / 10), o.push({
                        value: i
                    })
                }), I.trigger(this._element, nw, {
                    values: {
                        value: o.map(({
                            value: t
                        }) => t),
                        rounded: o.map(({
                            value: t
                        }) => Math.round(t))
                    }
                })
            }
            _handleEndMoveEventDocument() {
                O.on(document, "mouseup touchend", () => {
                    this._mousemove && (this.hands.forEach(t => {
                        I.off(t, "mousemove"), P.removeClass(t, ow), this._options.tooltip && P.removeClass(t.children[1], "active")
                    }), this._mousemove = !1)
                })
            }
            _handleEndMoveEvent(t) {
                O.on(t, "mouseup touchend", () => {
                    I.off(t, "mousemove"), P.removeClass(t, ow), this._options.tooltip && P.removeClass(t.children[1], "active"), this._mousemove = !1
                })
            }
            _handleClickOnRange() {
                O.on(this.connect, "mousedown touchstart", e => {
                    this.hands.forEach(t => {
                        P.addClass(t, ow), this._mousemove = !0, this._options.numberOfRanges < 2 ? P.addStyle(t, {
                            transform: "translate(".concat(tw(e) - this.leftConnectRect - t.offsetWidth / 2, "px,-25%)")
                        }) : P.addStyle(this.hands[0], {
                            transform: "translate(".concat(tw(e) - this.leftConnectRect - t.offsetWidth / 2, "px,-25%)")
                        })
                    })
                })
            }
            _handlePadding() {
                O.on(this.connect, "mousedown touchstart", t => {
                    var {
                        padding: e,
                        numberOfRanges: i
                    } = this._options;
                    let n;
                    return i < 2 && (n = Math.round((tw(t) - this.leftConnectRect) / (t.target.offsetWidth / e)) % e), n
                })
            }
            _setMovingTooltipEvent() {
                O.on(this.connect, "mousemove", t => {
                    var e = (tw(t) - this.leftConnectRect) / t.target.offsetWidth,
                        t = "".concat(Math.round(100 * e), "%");
                    I.trigger(this._element, "movetooltip", {
                        percents: {
                            value: e,
                            percent: t
                        }
                    })
                })
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, iw);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose|hide/.test(i)) && (t = t || new lw(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            _getConfig(t) {
                t = { ...rw,
                    ...P.getDataAttributes(this._element),
                    ...t
                };
                return a(ew, t, aw), t
            }
            static getInstance(t) {
                return p.getData(t, iw)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(".multi-range-slider").forEach(t => {
            let e = lw.getInstance(t);
            return e = e || new lw(t), e
        }), c(() => {
            const t = l();
            if (t) {
                const e = t.fn[ew];
                t.fn[ew] = lw.jQueryInterface, t.fn[ew].Constructor = lw, t.fn[ew].noConflict = () => (t.fn[ew] = e, lw.jQueryInterface)
            }
        });
        var cw = lw;
        const hw = "datetimepicker",
            dw = "mdb.".concat(hw);
        Ot = ".".concat(dw);
        const uw = "datepicker",
            pw = "timepicker";
        G = "".concat(hw, "-toggle-button");
        const fw = "invalid-feedback",
            gw = "is-invalid";
        Se = ".".concat(hw);
        const _w = ".".concat(pw),
            mw = ".".concat(uw),
            vw = '[data-mdb-toggle="'.concat(hw, '"]'),
            bw = ".".concat(G),
            yw = ".".concat(fw),
            xw = "open".concat(Ot),
            ww = "close".concat(Ot),
            Cw = "datetimeChange".concat(Ot),
            kw = "close.mdb.datepicker",
            Tw = "input.mdb.timepicker",
            Sw = y("div"),
            Ew = {
                appendValidationInfo: !0,
                inline: !1,
                toggleButton: !0,
                container: "body",
                disabled: !1,
                disablePast: !1,
                disableFuture: !1,
                defaultTime: "",
                defaultDate: "",
                timepicker: {},
                datepicker: {},
                invalidLabel: "Invalid Date or Time Format",
                showFormat: !1
            },
            Aw = {
                appendValidationInfo: "boolean",
                inline: "boolean",
                toggleButton: "boolean",
                container: "string",
                disabled: "boolean",
                disablePast: "boolean",
                disableFuture: "boolean",
                defaultTime: "(string|date|number)",
                defaultDate: "(string|date|number)",
                timepicker: "object",
                datepicker: "object",
                invalidLabel: "string",
                showFormat: "boolean"
            };
        class Mw {
            constructor(t, e) {
                this._element = t, this._input = R.findOne("input", this._element), this._options = this._getConfig(e), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate || "", this._timeValue = this._options.defaultTime || "", this._isInvalidTimeFormat = !1, this._validationInfo = null, this._format = this._options.datepicker.format || "dd/mm/yyyy", this._cancel = !1, this._scrollBar = new pe, this._element && p.setData(t, dw, this), this._init()
            }
            static get NAME() {
                return hw
            }
            get toggleButton() {
                return R.findOne(bw, this._element)
            }
            dispose() {
                I.off(this._element, "click", this._openDatePicker), I.off(this._input, "input", this._handleInput), I.off(this._element, "click"), p.removeData(this._element, dw), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton.remove(), this._options = Ew, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null, this._validationInfo = null
            }
            update(t = {}) {
                t = this._getConfig({ ...this._options,
                    ...t
                });
                this.dispose(), this._options = t, this._init()
            }
            _init() {
                this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._appendValidationInfo(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture()
            }
            _removeDatepicker() {
                const t = this._element.querySelector(".datepicker");
                t && t.remove()
            }
            _addDatepicker() {
                const t = y("div");
                t.id = d("datepicker-");
                t.innerHTML = '<input type="text" class="form-control">', P.addClass(t, uw), this._element.appendChild(t), P.style(t, {
                    display: "none"
                });
                let e = { ...this._options.datepicker,
                    container: this._options.container,
                    disablePast: this._options.disablePast,
                    disableFuture: this._options.disableFuture
                };
                (this._options.inline || this._options.datepicker.inline) && (e = { ...e,
                    inline: !0
                }), this._datepicker = new sv(t, e), this._datepicker._input.value = this._dateValue
            }
            _removeTimePicker() {
                const t = this._element.querySelector(".timepicker");
                t && (t.remove(), this._scrollBar.reset())
            }
            _addTimePicker() {
                const t = y("div");
                t.id = d("timepicker-");
                t.innerHTML = '<input type="text" class="form-control">', P.addClass(t, pw), this._element.appendChild(t), P.style(t, {
                    display: "none"
                });
                let e = { ...this._options.timepicker,
                    container: this._options.container
                };
                (this._options.inline || this._options.timepicker.inline) && (e = {
                    timepickerOptions: e,
                    inline: !0
                }), this._timepicker = new rm(t, e), this._timepicker.input.value = this._timeValue
            }
            _addIconButtons() {
                if (P.addClass(Sw, "buttons-container"), Sw.innerHTML = '\n  <button type="button" class="datepicker-button-toggle"  data-mdb-toggle="datepicker">\n    <i class="far fa-calendar datepicker-toggle-icon"></i>\n  </button>\n  <button type="button" class="timepicker-button-toggle" data-mdb-toggle="timepicker">\n    <i class="far fa-clock fa-sm timepicker-icon"></i>\n  </button>\n', !this._options.inline && !this._options.datepicker.inline)
                    if (this._scrollBar.hide(), this._datepicker._isOpen) {
                        const e = R.findOne("".concat(mw, "-header"), document.body);
                        e.appendChild(Sw)
                    } else if (this._timepicker._modal && !this._options.timepicker.inline) {
                    const i = R.findOne("".concat(_w, "-elements"), document.body);
                    var t = R.findOne("".concat(_w, "-clock-wrapper"), document.body);
                    i.insertBefore(Sw, t)
                }
            }
            _enableOrDisableToggleButton() {
                this._options.disabled ? (this.toggleButton.disabled = !0, this.toggleButton.style.pointerEvents = "none") : (this.toggleButton.disabled = !1, this.toggleButton.style.pointerEvents = "pointer")
            }
            _appendToggleButton() {
                this._options.toggleButton && (this._element.insertAdjacentHTML("beforeend", '\n  <button type="button" class="datetimepicker-toggle-button" data-mdb-toggle="datetimepicker">\n    <i class="far fa-calendar datepicker-toggle-icon"></i>\n  </button>\n'), this._enableOrDisableToggleButton())
            }
            _appendValidationInfo() {
                var {
                    invalidLabel: t,
                    appendValidationInfo: e
                } = this._options;
                e && (this._validationInfo = y("div"), P.addClass(this._validationInfo, fw), this._validationInfo.innerHTML = t, P.addStyle(this._input, {
                    marginBottom: 0
                }), P.addStyle(this._validationInfo, {
                    bottom: "-23px"
                }))
            }
            _applyFormatPlaceholder() {
                this._options.showFormat && (this._input.placeholder = this._format)
            }
            _listenToCancelClick() {
                const t = R.findOne("".concat(mw, "-cancel-btn"), document.body);
                I.one(t, "mousedown", () => {
                    this._cancel = !0, this._scrollBar.reset(), I.off(t, "mousedown")
                })
            }
            _listenToToggleClick() {
                I.on(this._element, "click", vw, t => {
                    t.preventDefault(), this._openDatePicker()
                })
            }
            _listenToUserInput() {
                I.on(this._input, "input", t => {
                    this._handleInput(t.target.value)
                })
            }
            _disableInput() {
                this._options.disabled && (this._input.disabled = "true")
            }
            _getConfig(t) {
                var e = P.getDataAttributes(this._element);
                return t = { ...Ew,
                    ...e,
                    ...t
                }, a(hw, t, Aw), t
            }
            _handleInput(t) {
                var e = t.split(", "),
                    i = this._format.match(/[^(dmy)]{1,}/g),
                    n = e[0],
                    t = e[1] || "",
                    i = ((t, e, i) => {
                        let n;
                        n = i[0] !== i[1] ? i[0] + i[1] : i[0];
                        var i = new RegExp("[".concat(n, "]")),
                            s = t.split(i);
                        const o = e.split(i);
                        var a, e = -1 !== e.indexOf("mmm");
                        const r = [];
                        for (let t = 0; t < o.length; t++) - 1 !== o[t].indexOf("yy") && (r[0] = {
                            value: s[t],
                            format: o[t]
                        }), -1 !== o[t].indexOf("m") && (r[1] = {
                            value: s[t],
                            format: o[t]
                        }), -1 !== o[t].indexOf("d") && o[t].length <= 2 && (r[2] = {
                            value: s[t],
                            format: o[t]
                        });
                        return Lm(Number(r[0].value), e ? (a = r[1].value, (void 0).findIndex(t => t === a)) : Number(r[1].value) - 1, Number(r[2].value))
                    })(n, this._format, i);
                n ? 2 === e.length && ((i = i) && "[object Date]" === Object.prototype.toString.call(i) && !isNaN(i) && ((i = t).match(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9] [APap][mM]$/) || i.match(/^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/))) ? (this._dateValue = n, this._timeValue = t, this._removeInvalidClass(this._input), this._datepicker._input.value = this._dateValue, this._timepicker.input.value = this._timeValue) : this._addInvalidClass(this._input, this._validationInfo) : this._removeInvalidClass(this._input)
            }
            _addInvalidClass() {
                var t = this._options["appendValidationInfo"];
                t && (P.addClass(this._input, gw), R.findOne(yw) || this._input.parentNode.insertBefore(this._validationInfo, this._input.nextSibling))
            }
            _removeInvalidClass(t) {
                P.removeClass(t, gw), this._isInvalidTimeFormat = !1;
                const e = R.findOne(yw);
                null !== e && e.remove()
            }
            _openDatePicker() {
                var t;
                I.trigger(this._element, xw).defaultPrevented || (this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && (this.toggleButton.style.pointerEvents = "none"), I.one(this._datepicker._element, kw, () => {
                    this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel ? this._cancel = !1 : (I.on(this._datepicker.container, "click", t => {
                        !this._datepicker._selectedDate && t.target.classList.contains("datepicker-ok-btn") || this._openTimePicker()
                    }), setTimeout(() => {
                        R.findOne("".concat(_w, "-wrapper"), document.body) || this._scrollBar.reset()
                    }, 10), this._options.inline && (this.toggleButton.style.pointerEvents = "auto"))
                }), t = R.findOne("".concat(_w, "-button-toggle"), document.body), I.on(t, "click", () => {
                    this._datepicker.close(), this._scrollBar.hide(), I.trigger(this._datepicker._element, kw)
                }))
            }
            _handleTimepickerDisablePast() {
                const t = new Date;
                t.setHours(0, 0, 0, 0), I.on(this._datepicker._element, "dateChange.mdb.datepicker", () => {
                    this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({
                        disablePast: !0
                    }) : this._timepicker.update({
                        disablePast: !1
                    })
                })
            }
            _handleTimepickerDisableFuture() {
                const t = new Date;
                t.setHours(0, 0, 0, 0), I.on(this._datepicker._element, "dateChange.mdb.datepicker", () => {
                    this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({
                        disableFuture: !0
                    }) : this._timepicker.update({
                        disableFuture: !1
                    })
                })
            }
            _handleEscapeKey() {
                I.one(document.body, "keyup", () => {
                    setTimeout(() => {
                        R.findOne("".concat(_w, "-wrapper"), document.body) || this._scrollBar.reset()
                    }, 250)
                })
            }
            _handleCancelButton() {
                var t = R.findOne("".concat(_w, "-cancel"), document.body);
                I.one(t, "mousedown", () => {
                    this._scrollBar.reset()
                })
            }
            _openDropdownDate() {
                const t = this._datepicker._popper;
                t.state.elements.reference = this._input, this._scrollBar.reset()
            }
            _openTimePicker() {
                I.trigger(this._timepicker.elementToggle, "click"), setTimeout(() => {
                    if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {
                        const e = R.findOne("".concat(_w, "-cancel"), document.body);
                        this._handleEscapeKey(), this._handleCancelButton(), I.on(this._timepicker._modal, "click", t => {
                            (t.target.classList.contains("".concat(pw, "-wrapper")) || t.target.classList.contains("".concat(pw, "-submit"))) && setTimeout(() => {
                                this._scrollBar.reset()
                            }, 200), t.target.classList.contains("".concat(pw, "-clear")) && I.trigger(this._timepicker._element, Tw), t.target.classList.contains("".concat(uw, "-button-toggle")) && (I.trigger(e, "click"), setTimeout(() => {
                                this._openDatePicker(), this._scrollBar.hide()
                            }, 200))
                        })
                    }
                }), I.one(this._timepicker._element, Tw, () => {
                    this._timeValue = this._timepicker.input.value, this._updateInputValue(), I.trigger(this._element, ww)
                })
            }
            _openDropdownTime() {
                const t = this._timepicker._popper;
                t.state.elements.reference = this._input, t.update(), this._scrollBar.reset()
            }
            _setInitialDefaultInput() {
                (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue()
            }
            _updateInputValue() {
                var t = this._timeValue && this._dateValue;
                if (t && (this._input.value = "".concat(this._dateValue, ", ").concat(this._timeValue), I.trigger(this._element, Cw).defaultPrevented)) return;
                I.trigger(this._input, "focus")
            }
            static jQueryInterface(i, n) {
                return this.each(function() {
                    let t = p.getData(this, dw);
                    var e = "object" == typeof i && i;
                    if ((t || !/dispose/.test(i)) && (t = t || new Mw(this, e), "string" == typeof i)) {
                        if (void 0 === t[i]) throw new TypeError('No method named "'.concat(i, '"'));
                        t[i](n)
                    }
                })
            }
            static getInstance(t) {
                return p.getData(t, dw)
            }
            static getOrCreateInstance(t, e = {}) {
                return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
            }
        }
        R.find(Se).forEach(t => {
            var e = Mw.getInstance(t);
            e || new Mw(t)
        });
        const Ow = l();
        if (Ow) {
            const Dw = Ow.fn[hw];
            Ow.fn[hw] = Mw.jQueryInterface, Ow.fn[hw].Constructor = Mw, Ow.fn[hw].noConflict = () => (Ow.fn[hw] = Dw, Mw.jQueryInterface)
        }
        var Iw = Mw
    }], n = {}, s.m = i, s.c = n, s.d = function(t, e, i) {
        s.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }, s.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, s.t = function(e, t) {
        if (1 & t && (e = s(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var i = Object.create(null);
        if (s.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: e
            }), 2 & t && "string" != typeof e)
            for (var n in e) s.d(i, n, function(t) {
                return e[t]
            }.bind(null, n));
        return i
    }, s.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return s.d(e, "a", e), e
    }, s.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, s.p = "", s(s.s = 134);

    function s(t) {
        if (n[t]) return n[t].exports;
        var e = n[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return i[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports
    }
    var i, n
});
//# sourceMappingURL=mdb.min.js.map